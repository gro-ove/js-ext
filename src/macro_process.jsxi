	function macrosParse (source, level, lineNumberPrefix){
		// TODO: Don't allow "macro" name

		function parseMacroDefine (){
			var name = found.raw [1],
				position,
				argument,
				arguments,
				blockMode,
				temp,
				body,
				converted;

			temp = liteParser.whatNext (/[^\s]/);

			if (temp.value === '('){
				liteParser.moveTo (temp);

				position 	= liteParser.index;
				arguments 	= [];

				while (temp = liteParser.findHere (',', ')')){
					argument = liteParser.substring (position, liteParser.index - 1).trim ();

					if (argument.length)
						arguments.push (argument);
					else if (arguments.length || temp.value === ',')
						throwError (liteParser.getPosition (), 'Missing argument');

					position = liteParser.index;

					if (temp.value === ')')
						break;
				}

				temp = liteParser.whatNext (/[^\s]/);
			} else 
				arguments = null;

			blockMode = temp && temp.value === '{';
			position = liteParser.index;

			if (blockMode){
				liteParser.moveTo (temp);
				temp = liteParser.findHere ('}');
			} else 
				temp = liteParser.findHere (';', LiteParser.EOF);

			if (!temp)
				throwError (liteParser.getPosition (), 'End of macro\'s body not found');

			body = liteParser.substring (position, liteParser.index).trim ();

			temp = liteParser.whatNext (/[^\s]/);
			if (temp && temp.value === ';')
				liteParser.moveTo (temp);

			liteParser.replace (found.index, liteParser.index, '/* There was definition of @' + name + ' */');
			macroStorage.add (new Macro (name, level, arguments, body));
		}

		function parseMacroCall (){
			var name 		= found.raw [1],
				arguments 	= [],
				position,
				argument,
				quotesCount,
				temp;

			temp = liteParser.whatNext (/[^\s]/);
			if (temp && (temp.value === '{' || temp.value === '(')){
				liteParser.moveTo (temp);

				if (temp.value === '{'){
					quotesCount = 1;

					while (liteParser.current === '{'){
						liteParser.index ++;
						quotesCount ++;
					}

					position = liteParser.index;

					if (quotesCount > 1)
						temp = liteParser.findSimple (new Array (quotesCount + 1).join ('}'));
					else 
						temp = liteParser.findHere ([ '{' ], '}');

					if (!temp)
						throwError (liteParser.getPosition (), 'End of argument not found');

					argument = liteParser.substring (position, liteParser.index - 1);
					arguments.push (JSON.stringify (argument));
				} else {
					position = liteParser.index;

					while (temp = liteParser.findHere (',', ')')){
						argument = liteParser.substring (position, liteParser.index - 1).trim ();

						if (argument.length)
							arguments.push (argument);
						else if (arguments.length || temp.value === ',')
							throwError (liteParser.getPosition (), 'Missing argument');

						if (temp.value === ')')
							break;
						else
							position = liteParser.index;
					}

					if (!temp)
						throwError (liteParser.getPosition (), 'Invalid arguments list');
				}
			}

			var replacement = '@call.' + calls.length;
			
			calls.push (new MacroCall (name, level, arguments, replacement));
			liteParser.replace (found.index, liteParser.index, replacement);
		}

		function levelDown ()
			level += '.' + lineNumberPrefix + '_' + found.index;

		function levelUp ()
			level = level.replace (/\.[\d_]+$/, '');

		var calls 		= [],
			liteParser 	= new LiteParser (source)
				.on ('//', lambda this.findSimple ('\n', '\r', LiteParser.EOF)) // FIXME: EOF
				.on ('/*', lambda this.findSimple ('*/'))
				.on ('\'', '"', '`', lambda {
					for (var temp; temp = liteParser.findSimple ('\\' + arg.value, arg.value); )
						if (temp.value === arg.value)
							return true;
					return false;
				}),
			found;

		while (found = liteParser.findNext (
				/@macro\s+([_$a-zA-Z][_$a-zA-Z0-9]*)/, 
				/@([_$a-zA-Z][_$a-zA-Z0-9]*)/, 
				'{', 
				'}')){
			switch (found.id){
				case 0:
					parseMacroDefine ();
					break;
				case 1:
					parseMacroCall ();
					break;
				case 2:
					levelDown ();
					break;
				case 3:
					levelUp ();
					break;
			}
		}

		return {
			data: 		liteParser.data,
			calls: 		calls
		}
	}

	function macrosProcess (data, level, callback){
		var file 	= 's';

		if (typeof level === 'number'){
			file 	= level;
			level 	= '';
		}

		console.assert (typeof callback === 'function', 'Wrong arguments');

		var temp 	= macrosParse (data, level, file),
			queue 	= new Queue (Queue.MODE_PARALLEL).description ('macros process');

		for (var call in-array temp.calls)
			queue.add (call, call.process.bind (call));

		queue.run (lambda {
			for (var entry in-array arg)
				temp.data = temp.data.replace (entry.data.replacement, entry.result [0]);
			callback (temp.data);
		});
	}
