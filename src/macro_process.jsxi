	var anonymousMacroId = +new Date;

	function macrosParse (source, level, context){
		console.assert (context instanceof Context, 'Context required');

		function parseMacroDefine (){
			var name = found.raw [1],
				position,
				argument,
				arguments,
				blockMode,
				temp,
				body,
				converted,
				insertCall = false,
				from;

			try {
				if (name === 'macro')
					throwError (liteParser.getPosition (), 'This word is reserved');

				temp = liteParser.whatNext (/[^\s]/);
				from = liteParser.index;

				if (temp.value === '('){
					liteParser.moveTo (temp);

					position 	= liteParser.index;
					arguments 	= [];

					while (temp = liteParser.findHere (',', ')')){
						argument = liteParser.substring (position, liteParser.index - 1).trim ();

						if (argument.length){
							arguments.push (argument);

							if (!/^[a-z$_][a-z$_\d]*(\:[a-z\-]+)?$/i.test (argument)){
								arguments = null;
								liteParser.index = from;
								break;
							}
						} else if (arguments.length || temp.value === ',')
							throwError (liteParser.getPosition (), 'Missing argument');

						position = liteParser.index;

						if (temp.value === ')')
							break;
					}

					temp = liteParser.whatNext (/[^\s]/);
				} else 
					arguments = null;

				blockMode = temp && temp.value === '{';
				position = liteParser.index;

				if (blockMode){
					liteParser.moveTo (temp);
					temp = liteParser.findHere ('}');
				} else 
					temp = liteParser.findHere (';', LiteParser.EOF);

				if (!temp || temp.value === LiteParser.EOF){
					throw new Error ('End of macro\'s body not found' + fromfrom);
				} else if (temp.value === '}'){
					temp = liteParser.whatNext (/[^\s]/);
					if (temp && temp.value === '(')
						insertCall = true;
				}

				body = liteParser.substring (position, liteParser.index).trim ();

				temp = liteParser.whatNext (/[^\s]/);
				if (temp && temp.value === ';')
					liteParser.moveTo (temp);

				if (!name){
					if (insertCall)
						name = '__anonymous_macro_' + ++ anonymousMacroId;
					else
						throwError (liteParser.getPosition (), 'Name required');
				}

				liteParser.replace (found.index, liteParser.index, '/* There was definition of @' + name + ' */');

				var macro = new Macro (name, level, context, arguments, body);
				macroStorage.add (macro);

				if (insertCall){
					liteParser.replace (liteParser.index, liteParser.index, '@' + macro.name);
					liteParser.index = found.index;
				}
			} catch {
				throw new Error ('Macro parsing failed (' + found.raw [0] + '):\n' + e.stack);
			}
		}

		function parseMacroCall (){
			var name 		= found.raw [1],
				arguments 	= [],
				position,
				argument,
				quotesCount,
				temp;

			if (name === 'macro')
				throwError (liteParser.getPosition (), 'This word is reserved');

			temp = liteParser.whatNext (/[^\s]/);
			if (temp && (temp.value === '{' || temp.value === '(')){
				liteParser.moveTo (temp);

				if (temp.value === '{'){
					quotesCount = 1;

					while (liteParser.current === '{'){
						liteParser.index ++;
						quotesCount ++;
					}

					position = liteParser.index;

					if (quotesCount > 1)
						temp = liteParser.findSimple (new Array (quotesCount + 1).join ('}'));
					else 
						temp = liteParser.findHere ([ '{' ], '}');

					if (!temp)
						throwError (liteParser.getPosition (), 'End of argument not found');

					argument = liteParser.substring (position, liteParser.index - 1);
					arguments.push (argument);
				} else {
					position = liteParser.index;

					while (temp = liteParser.findHere (',', ')')){
						argument = liteParser.substring (position, liteParser.index - 1).trim ();

						if (argument.length)
							arguments.push (argument);
						else if (arguments.length || temp.value === ',')
							throwError (liteParser.getPosition (), 'Missing argument');

						if (temp.value === ')')
							break;
						else
							position = liteParser.index;
					}

					if (!temp)
						throwError (liteParser.getPosition (), 'Invalid arguments list');
				}
			}

			var replacement = '@__call(' + calls.length + ')';
			
			calls.push (new MacroCall (name, arguments, level, context, replacement));
			liteParser.replace (found.index, liteParser.index, replacement);
		}

		function levelDown ()
			level += '.' + context.id + '_' + found.index;

		function levelUp ()
			level = level.replace (/\.[\d_]+$/, '');

		var calls 		= [],
			liteParser 	= new LiteParser (source)
				.on ('//', lambda this.findSimple ('\n', '\r', LiteParser.EOF)) 
				.on ('/*', lambda this.findSimple ('*/'))
				.on ('/',  lambda {
					for (var temp; temp = liteParser.findSimple ('\\\\', '\\/', '/'); )
						if (temp.value === '/')
							return true;
					return false;
				}) 
				.on ('\'', '"', '`', lambda {
					for (var temp; temp = liteParser.findSimple ('\\' + arg.value, arg.value); )
						if (temp.value === arg.value)
							return true;
					return false;
				}),
			found;

		while (found = liteParser.findNext (
				/@macro\s+([_$a-zA-Z][_$a-zA-Z0-9\.\-]*(?:\:[a-z\-]+)?)?/, 
				/@([_$a-zA-Z][_$a-zA-Z0-9\.\-]*)/, 
				'{', 
				'}')){
			switch (found.id){
				case 0:
					parseMacroDefine ();
					break;
				case 1:
					parseMacroCall ();
					break;
				case 2:
					levelDown ();
					break;
				case 3:
					levelUp ();
					break;
			}
		}

		return {
			data: 		liteParser.data,
			calls: 		calls
		}
	}

	function macrosProcess (data, level, context, callback){
		if (level instanceof Context){
			callback 	= context;
			context 	= level;
			level 		= '';
		}

		console.assert (context instanceof Context, 'Context required');
		console.assert (typeof callback === 'function', 'Function required');

		var temp 	= macrosParse (data, level, context),
			queue 	= new Queue (Queue.MODE_PARALLEL).description ('macros process');

		for (var call in-array temp.calls)
			queue.add (call, call.process.bind (call));

		queue.run (lambda {
			for (var entry in-array arg)
				temp.data = temp.data.split (entry.data.replacement).join (entry.result [0]);
			callback (temp.data);
		});
	}
