	function parseMacrosAndCalls (source, level, lineNumberPrefix){
		// TODO: Don't allow "macro" name

		function parseMacroDefine (){
			var name = found.raw [1],
				position,
				argument,
				arguments,
				blockMode,
				temp,
				body,
				converted;

			temp = liteParser.whatNext (/[^\s]/);

			if (temp.value === '('){
				liteParser.moveTo (temp);

				position 	= liteParser.index;
				arguments 	= [];

				while (temp = liteParser.findHere (',', ')')){
					argument = liteParser.substring (position, liteParser.index - 1).trim ();

					if (argument.length)
						arguments.push (argument);
					else if (arguments.length || temp.value === ',')
						throwError (liteParser.getPosition (), 'Missing argument');

					position = liteParser.index;

					if (temp.value === ')')
						break;
				}

				temp = liteParser.whatNext (/[^\s]/);
			} else 
				arguments = null;

			blockMode = temp && temp.value === '{';
			position = liteParser.index;

			if (blockMode){
				liteParser.moveTo (temp);
				temp = liteParser.findHere ('}');
			} else 
				temp = liteParser.findHere (';', LiteParser.EOF);

			if (!temp)
				throwError (liteParser.getPosition (), 'End of macro\'s body not found');

			body = liteParser.substring (position, liteParser.index).trim ();

			temp = liteParser.whatNext (/[^\s]/);
			if (temp && temp.value === ';')
				liteParser.moveTo (temp);

			liteParser.replace (found.index, liteParser.index, '/* There was definition of @' + name + ' */');
			macroStorage.add (new Macro (name, level, arguments, body));
		}

		function parseMacroCall (){
			var name 		= found.raw [1],
				arguments 	= [],
				position,
				argument,
				quotesCount,
				temp;

			temp = liteParser.whatNext (/[^\s]/);
			if (temp && (temp.value === '{' || temp.value === '(')){
				liteParser.moveTo (temp);

				if (temp.value === '{'){
					quotesCount = 1;

					while (liteParser.current === '{'){
						liteParser.index ++;
						quotesCount ++;
					}

					position = liteParser.index;

					if (quotesCount > 1)
						temp = liteParser.findSimple (new Array (quotesCount + 1).join ('}'));
					else 
						temp = liteParser.findHere ([ '{' ], '}');

					if (!temp)
						throwError (liteParser.getPosition (), 'End of argument not found');

					argument = liteParser.substring (position, liteParser.index - 1);
					arguments.push (JSON.stringify (argument));
				} else {
					position = liteParser.index;

					while (temp = liteParser.findHere (',', ')')){
						argument = liteParser.substring (position, liteParser.index - 1).trim ();

						if (argument.length)
							arguments.push (argument);
						else if (arguments.length || temp.value === ',')
							throwError (liteParser.getPosition (), 'Missing argument');

						if (temp.value === ')')
							break;
						else
							position = liteParser.index;
					}

					if (!temp)
						throwError (liteParser.getPosition (), 'Invalid arguments list');
				}
			}

			var pos = calls.push (new MacroCall (name, level, arguments)) - 1;
			liteParser.replace (found.index, liteParser.index, '@call.' + pos);
		}

		function levelDown ()
			level += '.' + lineNumberPrefix + '_' + found.index;

		function levelUp ()
			level = level.replace (/\.[\d_]+$/, '');

		var calls 		= [],
			liteParser 	= new LiteParser (source)
				.on ('//', lambda this.findSimple ('\n', '\r', LiteParser.EOF)) // FIXME: EOF
				.on ('/*', lambda this.findSimple ('*/'))
				.on ('\'', '"', '`', lambda {
					for (var temp; temp = liteParser.findSimple ('\\' + arg.value, arg.value); )
						if (temp.value === arg.value)
							return true;
					return false;
				}),
			found;

		while (found = liteParser.findNext (
				/@macro\s+([_$a-zA-Z][_$a-zA-Z0-9]*)/, 
				/@([_$a-zA-Z][_$a-zA-Z0-9]*)/, 
				'{', 
				'}')){
			switch (found.id){
				case 0:
					parseMacroDefine ();
					break;
				case 1:
					parseMacroCall ();
					break;
				case 2:
					levelDown ();
					break;
				case 3:
					levelUp ();
					break;
			}
		}

		return {
			data: 		liteParser.data,
			calls: 		calls
		}
	}

	function callMacros (source, level, macros, calls, callback){

		function macroCall (call, callback){
		}

		if (typeof level === 'function'){
			callback 	= level;
			level 		= '';
			topMacros 	= [];
		}

		console.assert (typeof callback === 'function', 'Invalid argument');

		if (data.search (/@[_$a-zA-Z]/) === -1){
			callback (data);
			return;
		}

		var macros 		= topMacros.slice (),
			calls 		= [],
			liteParser 	= new LiteParser (data)
				.on ('//', lambda this.findSimple ('\n', '\r', LiteParser.EOF)) // FIXME: EOF
				.on ('/*', lambda this.findSimple ('*/'))
				.on ('\'', '"', '`', lambda {
					while (temp = liteParser.findSimple ('\\' + arg.value, arg.value))
						if (temp.value === arg.value)
							return true;
					return false;
				}),
			found,
			queue 		= new Queue (),
			delta 		= 0;

		while (found = liteParser.findNext (
				/@macro\s+([_$a-zA-Z][_$a-zA-Z0-9]*)/, 
				/@([_$a-zA-Z][_$a-zA-Z0-9]*)/, 
				'{', 
				'}'))
			switch (found.id){
				case 0:
					parseMacroDefine ();
					break;
				case 1:
					parseMacroCall ();
					break;
				case 2:
					levelDown ();
					break;
				case 3:
					levelUp ();
					break;
			}

		if (calls.length === 0){
			callback (data);
			return;
		}

		for (var macro in-array macros)
			macro.initialize (macros);

		liteParser.update (0);

		while (found = liteParser.findNext (/@call\.(\d+)/)){
			var call = calls [+found.raw [1]];
			console.assert (call, 'Wrong call identifier');

			queue.add ({ from: found.index, to: liteParser.index }, macroCall, call);
		}

		queue.run (lambda {
			for (var entry in-array arg)
				delta += partReplace (entry.data.from + delta, entry.data.to + delta, entry.result [0]);

			callback (data);
		});
	}