	// Обработка метода класса
	function processClassFunction (classEntry, functionEntry){
		console.assert (classEntry && functionEntry, 'Wrong arguments: ' + classEntry + ', ' + functionEntry);

		// Для отладки
		// console.log ('[processClassFunction]', classEntry.id.name + '::' + functionEntry.id.name);

		// Тут будут лежать имена локальных переменных — им не нужно будет подставлять «this»
		var exclusions = {};

		// Ссылка на ноду AST текущей обрабатываемой функции
		var currentFunction;

		// Если какому-то из кусков AST понадобится ссылка на this, он поменяет эту переменную
		var usingThat = false;

		// Заменяем содержимое одного объекта содержимым другого
		function set (to, from){
			for (var n in to)
				delete to [n];
			for (var n in from)
				to [n] = from [n];
		}

		// Получаем «this» или «that» в зависимости от того, какая функция сейчас обрабатывается
		function getThis (){
			// Определяем, дочерняя ли эта функция по отношению к основной обрабатываемой
			var childFunction = currentFunction !== functionEntry;

			// Если дочерняя, просим обеспечить ссылку на «this».
			if (childFunction)
				usingThat = true;

			return childFunction ? identifier (thatVariable) : thisExpression ();
		}

		// Ищет в переданном куске AST имена переменных, функций и прочей мути
		function lookForExclusions (obj, target)
			if (typeof obj === 'object' && obj !== null){
				if (obj instanceof Array){
					// Массивы пробегаем в ускоренном темпе
					for (var child in-array obj)
						lookForExclusions (child, target);

				} else if ('type' in obj){
					if (obj.type === Syntax.VariableDeclarator || obj.type === Syntax.FunctionDeclaration){
						// Переменные и функции записываем
						target [obj.id.name] = true;

					} else if (obj.type !== Syntax.FunctionExpression){
						// А по содержимое функций не трогаем
						for (var key, value in obj)
							lookForExclusions (value, target);
					}
				}
			}

		// Обработка функции
		function processFunction (obj, parent){
			console.assert (typeof obj === 'object' && obj.type === Syntax.FunctionDeclaration, 'Wrong argument');

			// Сохраняем текущие значения, а после переустанавливаем на свои
			var oldExclusions = clone (exclusions),
				oldCurrentFunction = currentFunction;

			exclusions = {};
			currentFunction = obj;

			// Заносим в исключения аргументы функции
			obj.params.forEach (lambda exclusions [arg.name] = true);

			// И ищем внутри переменные
			lookForExclusions (obj.body.body, exclusions);

			// Обновляем содержимое
			process (obj.body.body);

			// Если кто-то попросил ссылку на «this», а мы — главная функция, обеспечим ссылку.
			if (usingThat && functionEntry === obj){
				var temp = [ variableDeclarator (thatVariable, thisExpression ()) ];

				if (0 in obj.body && obj.body.body [0].type === Syntax.VariableDeclaration)
					// Если первым идёт список переменных, кидаем в начало списка
					obj.body.body [0].declarations = temp.concat (obj.body.body [0].declarations);
				else
					// Иначе — в начало функции
					obj.body.body = [ variableDeclaration (temp) ].concat (obj.body.body);
			}

			// Возвращаем старые значения
			exclusions = oldExclusions;
			currentFunction = oldCurrentFunction;
		}

		function processProperty (obj, parent){
			process (obj.value, parent);
		}

		function processIdentifier (obj, parent){
			// Несколько адовая функция

			function replaceObject (member){
				// Из статичных свойств обращаться к свойствам объекта как-то неправильно (functionEntry -
				// нода AST основной обрабатываемой функции, на неё и смотрим)
				if (functionEntry.static)
					throwError (obj, Messages.ObjectAccessError, obj.name);

				// Не даём обращаться и к скрытым полям
				if (member.publicMode === 'locked')
					throwError (obj, Messages.PrivateAccessError, obj.name);

				// Получаем ссылку на «this» (или «that»)
				var that = getThis ();

				// Собираем результат
				var result = memberExpression (that, member.id.name);

				// Если обращались к функции и при этом она не вызывается, имеет смысл привязать её к объекту
				if (member.method && parent.type !== Syntax.CallExpression)
					result = callExpression (memberExpression (result, 'bind'), [ that ]);

				return result;
			}

			function replaceStatic (member){
				// Да, тут всё куда проще

				// Бьём по рукам за попытку обратиться к скрытому
				if (member.publicMode === 'locked')
					throwError (obj, Messages.PrivateAccessError, obj.name);

				// Имя класса, в котором определено то нечто, к чему мы обращаемся
				var className = member.className;

				// Используем «className.name», потому что иначе две ноды AST будут представлены одним и тем же
				// объектом, что может выйти боком (а при передаче именно строки будет создана новая нода)
				return memberExpression (className.name, member.id.name);
			}

			// Проверяем, нет ли в исключениях такого же идентификатора
			if (!(obj.name in exclusions)){
				var result = null,
					member;

				if (obj.name in classEntry.members){
					// Обрабатываем метод или поле (приватные статические методы или поля ставятся 
					// иначе, и замена для них не нужна)

					member = classEntry.members [obj.name];
					if (!member.static)
						result = replaceObject (member);
					else if (member.publicMode !== 'private')
						result = replaceStatic (member);

				} else if (classesByNames [obj.name])
					// Если внезапно нашли имя другого класса, отмечаем, что, вероятно, обрабатываемый класс 
					// использует этот другой класс и имело бы смысл по возможности поместить обрабатываемый 
					// класс ниже
					classEntry.probablyUseOther ++;

				// Меняем объект, если что-то нашлось
				if (result)
					set (obj, result);
			}
		}

		function processMemberExpression (obj, parent){
			if (obj.object.type === Syntax.ThisExpression 
				&& obj.computed === false 
				&& obj.property.type === Syntax.Identifier 
				&& classEntry.members.hasOwnProperty (obj.property.name)
				&& !classEntry.members [obj.property.name].static)
				obj.property.name = classEntry.members [obj.property.name].id.name;

			// Всё довольно просто — обрабатываем объект ...
			process (obj.object, obj);

			// ... и, если обращение выполняется через квадратные скобки, заодно и их содержимое
			if (obj.computed)
				process (obj.property, obj);
		}

		function processThisExpression (obj, parent){
			// Если нужно, заменяем «this» на что-то ещё
			set (obj, getThis ());
		}

		function processSuperExpression (obj, parent){
			// TODO: static

			// Либо «super» используется в корне одной из функций объекта, или у него есть
			// имя вызываемого супер-метода
			if (currentFunction !== functionEntry && obj.callee === null)
				throwError (obj, Messages.WtfMan);

			// Ищем название нужного класса, идя по дереву классов
			var currentClass = classEntry;

			// В поле «super» хранится, на сколько нужно подняться
			for (var i = 0; i < obj ['super']; i ++){
				currentClass = byName (currentClass.dependsOn.parent.name);

				// Если вдруг родителей не хватает, вываливаемся
				if (!currentClass)
					throwError (obj, Messages.SuperMethodIsNotAvailable);
			}

			// Имя вызываемого метода
			var callee = obj.callee ? obj.callee.name : functionEntry.id.name;

			// У кого вызывать метод
			var target;

			if (callee && callee [0] !== '@'){
				// Если имя где-то, но есть, и при этом это не конструктор или деструктор, вызываем метод из прототипа
				target = memberExpression (memberExpression (currentClass.id, 'prototype'), callee);
			} else {
				// Иначе вызываем конструктор
				target = currentClass.id;
			}

			// Вызываемая функция
			obj.callee = memberExpression (target, 'call');

			// Получаем ссылку на «this»
			var that = getThis ();

			// Не забываем добавить «this» в аргументы
			obj.arguments = [ that ].concat (obj.arguments);
		}

		function process (obj, parent){
			if (typeof obj === 'object' && obj !== null){
				// Как-нибудь обойдёмся и без строк, чисел, null'ов и прочей мути

				if (obj instanceof Array){
					// Массивы пробегаем в ускоренном темпе
					for (var child in-array obj)
						process (child, obj);

				} else if ('type' in obj){
					// Тут всё и так вполне очевидно

					switch (obj.type){
						case Syntax.FunctionDeclaration:
						case Syntax.FunctionExpression:
							processFunction (obj, parent);
							break;

						case Syntax.Property:
							processProperty (obj, parent);
							break;

						case Syntax.Identifier:
							processIdentifier (obj, parent);
							break;

						case Syntax.MemberExpression:
							processMemberExpression (obj, parent);
							break;

						case Syntax.ThisExpression:
							processThisExpression (obj, parent);
							break;

						case Syntax.CallExpression:
							if ('super' in obj)
								processSuperExpression (obj, parent);
							// Оператор «break» пропущен специально

						default:
							for (var key, value in obj){
								// console.log (key, value);
								process (value, obj);
							}
					}
				}
			}
		}

		process (functionEntry);
	}