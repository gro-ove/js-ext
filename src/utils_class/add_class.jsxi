// Записываем класс в список
function addClass (classEntry){
	// Если класс с таким именем уже есть, вываливаемся
	if (byName (classEntry.id.name))
		throwError (classEntry.id, Messages.ClassAlreadyDefined, classEntry.id.name);

	// Вспомогательный атрибут на будущее
	classEntry.classObject = true;

	// Обновляем поля и методы
	for (var name, member in classEntry.members)
		updateMember (member, classEntry);

	// Находим, а если понадобится, то создаём конструктор
	var constructor = classEntry.members ['@constructor'];
	if (constructor === undefined){
		constructor = updateMember (functionDeclaration ('@constructor'), classEntry);
		constructor.autocreated = true;
	}

	// Аналогично со статическим инициализатором
	var initializer = classEntry.members ['@initializer'];
	if (initializer === undefined){
		initializer = updateMember (functionDeclaration ('@initializer'), classEntry);
		initializer.static = true;
		initializer.autocreated = true;
	}

	// Находим список полей объекта, требующих инициализации
	var fields = filter (classEntry.members, lambda !arg.method && !arg.static && arg.init !== null);

	// Собираем присваивания для инициализации
	var initialization = fields.map (
		lambda $.extend (
			expressionStatement (assignmentExpression (memberExpression (thisExpression (), arg.id.name), arg.init)),
			{ comment: arg.id.name, autocreated: true }));

	// Запихиваем присваивания в начало конструктора
	constructor.body.body = initialization.concat (constructor.body.body);

	// И записываем результат
	classesByNames [classEntry.id.name] = $.extend (
		classEntry, 
		{
			childs: 			[],
			probablyUseOther: 	0
		});

	classes.push (classesByNames [classEntry.id.name]);
}

// Получаем заменённое имя в зависимости от видимости переменной
function replacement (member, classEntry){
	// Конструкторам, инициализаторам и приватным статическим переменным имя не меняем
	if (member.static && member.publicMode === 'private' || member.id.name [0] === '@')
		return member.id.name;

	switch (member.publicMode){
		case 'protected':
			return '__' + member.id.name;

		case 'private':
			return '__' + classEntry.id.name + '_' + member.id.name;

		case 'public':
			return member.id.name;

		default:
			console.assert (false, 'Unsupported publicMode (' + member.publicMode + ')');
	}
}

// Обновляем метод или поле
function updateMember (member, classEntry){
	// Если вдруг такого метода или поля в классе нет, добавим
	if (!classEntry.members.hasOwnProperty (member.id.name))
		classEntry.members [member.id.name] = member;

	// Если нужно, меняем publicMode на значение по умолчанию
	if (member.publicMode === null)
		member.publicMode = classEntry.publicMode || 'private';

	// Обновляем имя
	member.id = identifier (replacement (member, classEntry));

	// И добавляем пару вспомогательных атрибутов
	member.className = classEntry.id;
	member.method = member.type === Syntax.FunctionDeclaration;

	return member;
}