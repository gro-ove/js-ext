// Ключевая функция для обработки класса (конвертирует его в стандартное AST-дерево)
function processClass (classEntry){
	if (typeof classEntry === 'string'){
		classEntry = byName (classEntry);
		console.assert (classEntry, 'Class not found');
	}

	console.assert (!('element' in classEntry), 'Already processed');

	// Биндим нужные функции
	var processClassFunctionBinded 	= processClassFunction.bind (null, classEntry),
		filterBinded 				= filter.bind (null, classEntry);

	// Находим конструкторы
	var constructor 				= classEntry.members ['@constructor'],
		initializer 				= classEntry.members ['@initializer'];

	// И поля с методами
	var filtered 					= filterBinded (lambda arg.className === classEntry.id && arg.id.name [0] !== '@'),
		objectMethods 				= filtered.filter (lambda  arg.method && !arg.static),
		staticMethods 				= filtered.filter (lambda  arg.method &&  arg.static),
		objectFields 				= filtered.filter (lambda !arg.method && !arg.static),
		staticFields 				= filtered.filter (lambda !arg.method &&  arg.static);

	if (!classEntry.params.abstract && filterBinded (lambda arg.abstract)[0])
		classEntry.params.abstract = true;

	// Обрабатываем конструктор, инициализатор и методы
	processClassFunctionBinded (constructor);
	processClassFunctionBinded (initializer);

	objectMethods.forEach (processClassFunctionBinded);
	staticMethods.forEach (processClassFunctionBinded);

	// Слегка меняем конструктор и инициализатор
	$.extend (constructor, { id: null, type: Syntax.FunctionExpression });
	$.extend (initializer, { id: null, type: Syntax.FunctionExpression });

	// Режим сборки
	var mode = 'default';

	if (!classEntry.childs.length &&
		!classEntry.dependsOn.parent && 
		!objectMethods.length && 
		!objectFields.length &&
		!constructor.body.body.length){

		// Для статических классов
		classEntry.mode = 'static';

		// Для пустых классов или для классов, состоящих лишь из одного иницилизатора
		if (!staticFields.length && !staticMethods.length)
			classEntry.mode = initializer.body.body.length > 0 ? 'initializer-only' : 'empty';
	}

	if (mode === 'empty'){
		// Роль класса будет играть пустой объект
		classEntry.element = variableDeclarator (classEntry.id.name, objectExpression ());
		classEntry.uses = [];

	} else if (mode === 'initializer-only'){
		// Здесь скорее анонимная функция
		classEntry.element = variableDeclarator (classEntry.id.name, sequenceExpression ([ 
			callExpression (classEntry.staticInitialization),
			objectExpression ()
		]));

	} else {
		// А тут всё уже несколько посерьёзнее
		var variables = [],
			resultFunction = [ variableDeclaration (variables) ];

		if (mode === 'default'){
			// Добавляем конструктор как основную фунцию
			variables.push (variableDeclarator (classEntry.id, constructor));

			// Лепим муть, нужную для наследования
			if (classEntry.dependsOn.parent)
				resultFunction.push (expressionStatement (callExpression ('__pe', [ classEntry.id.name, classEntry.dependsOn.parent.name ])));

			// Цепляем к прототипу методы объекта
			for (var method in-array objectMethods)
				if (!method.abstract || method.body.body.length > 0){
					var target = memberExpression (memberExpression (classEntry.id, 'prototype'), method.id.name),
						value = functionExpression (method.params, method.body);

					resultFunction.push (expressionStatement (assignmentExpression (target, value)));
				} else
					abstract = true;

			// Если класс внезапно абстрактен, ставим проверку
			// TODO: Сделать вставку проверки опциональной
			if (classEntry.params.abstract)
				constructor.body.body = [ 
					ifStatement (
						binaryExpression (memberExpression (thisExpression (), 'constructor'), '===', classEntry.id.name),
						throwStatement (newExpression ('Error', [ literal ('Trying to instantiate abstract class ' + classEntry.id.name) ])))
				].concat (constructor.body.body);
		} else if (mode === 'static')
			// Вместо функции добавляем пустой объект
			variables.push (variableDeclarator (classEntry.id, objectExpression ()));

		// Добавляем статические поля ...
		for (var field in-array staticFields)
			if (field.publicMode !== 'private'){
				var temp = expressionStatement (assignmentExpression (
					memberExpression (classEntry.id, field.id), field.init || 'undefined'));

				if (findByReplacement (classEntry, field.id.name).publicMode === 'protected')
					temp.comment = field.id.name;

				resultFunction.push (temp);
			} else 
				variables.push (field);

		// ... после — статические методы ...
		for (var method in-array staticMethods){
			if (method.publicMode !== 'private'){
				var temp = expressionStatement (assignmentExpression (
					memberExpression (classEntry.id, method.id), functionExpression (method.params, method.body)))
				resultFunction.push (temp);
			} else
				resultFunction.push (method);
		}

		// ... инициализатор ...
		if (initializer && initializer.body.body.length > 0)
			resultFunction.push (expressionStatement (callExpression (initializer)));

		// ... и оператор «return»
		resultFunction.push (returnStatement (classEntry.id));

		// И втыкаем куда-нибудь получившийся кусок AST, чтобы после забрать
		classEntry.element = variableDeclarator (classEntry.id.name, callExpression (functionExpression ([], resultFunction)));
	}
}

function processClasses (){
	for (var classEntry in-array classes)
		processClass (classEntry);
}