var OutputMode = {
	Default: 				'Default',
	Static: 				'Static',
	InitializerOnly: 		'InitializerOnly',
	Empty: 					'Empty'
};

// Ключевая функция для обработки класса (конвертирует его в стандартное AST-дерево)
function processClass (classEntry){
	// Функция для определения режима конвертации
	function classMode (){
		// Если нет дочерних или родительских классов, нет объектных членов, а конструктор пустой
		if (classEntry.childs.length === 0 && !classEntry.dependsOn.parent 
			&& objectMembers.length === 0 && constructor.body.body.length === 0){

			// Есть статическое поле или метод
			if (staticFields.length > 0 || staticMethods.length > 0)
				return OutputMode.Static;

			// В инициализаторе что-то есть
			if (initializer.body.body.length > 0)
				return OutputMode.InitializerOnly;

			return OutputMode.Empty;
		}

		return OutputMode.Default;
	}

	// Небольшая проверка на всякий случай
	console.assert (!classEntry.elements, 'Already processed');

	// Находим конструктор и инициализатор
	var constructor 	= classEntry.members ['@constructor'],
		initializer 	= classEntry.members ['@initializer'];

	// Объектные и статические поля и методы данного класса
	var filtered 		= filter (classEntry, lambda arg.className === classEntry.id && arg.id.name [0] !== '@'),
		objectMembers 	= filtered.filter (lambda !arg.static),
		staticMembers 	= filtered.filter (lambda  arg.static);

	// Отделяем статические от объектных поля от методов
	var objectMethods 	= objectMembers.filter (lambda  arg.method),
		objectFields 	= objectMembers.filter (lambda !arg.method),
		staticMethods 	= staticMembers.filter (lambda  arg.method),
		staticFields 	= staticMembers.filter (lambda !arg.method);

	// Слегка меняем конструктор и инициализатор
	constructor.id = null;
	initializer.id = null;

	// Если хоть одно из полей абстрактно, то и класс абстрактен
	if (!classEntry.params.abstract && objectMethods.filter (lambda arg.abstract).length > 0)
		classEntry.params.abstract = true;

	// Исключение в конструктор для абстрактных классов
	if (classEntry.params.abstract)
		constructor.body.body = [ 
			ifStatement (
				binaryExpression (memberExpression (thisExpression (), identifier ('constructor')), '===', classEntry.id.name),
				throwStatement (newExpression ('Error', [ 
					stringLiteralWithQuotes ('Trying to instantiate abstract class ' + classEntry.id.name) 
				])))
		].concat (constructor.body.body);

	// Режим сборки
	var mode = classMode ();

	// Пустой объект
	if (mode === OutputMode.Empty)
		return [ oneVariableDeclaration (classEntry.id.name, objectExpression ([])) ];

	// Одна лишь анонимная функция
	if (mode === OutputMode.InitializerOnly)
		return [ oneVariableDeclaration (classEntry.id.name, callExpression (initializer)) ];

	// А тут всё несколько посерьёзнее
	var anonymousFunction = staticMembers.filter (lambda arg.publicMode === 'private').length > 0,
		result,
		mainObj;

	if (mode === OutputMode.Default){
		// Конструктор
		result = [ anonymousFunction 
			? oneVariableDeclaration (classEntry.id, constructor)
			: functionDeclaration (classEntry.id, constructor.params, constructor.body) ];

		// Вызов «prototypeExtend» для наследования
		if (classEntry.dependsOn.parent)
			result.push (expressionStatement (callExpression ('__prototypeExtend', [ classEntry.id.name, classEntry.dependsOn.parent.name ])));

		// Поля объекта (уже добавлены в конструктор)
		for (var field in-array objectFields){}

		// Методы объекта
		for (var method in-array objectMethods){
			if (!method.abstract)
				result.push (assignmentStatement (
					memberExpression (memberExpression (classEntry.id.name, 'prototype'), method.id), 
					functionExpression (null, method.params, method.body)));
		}

		// Статические поля
		for (var field in-array staticFields){
			if (field.publicMode === 'private')
				result [0].declarations.push (field);
			else 
				result.push (assignmentStatement (memberExpression (classEntry.id.name, field.id), field.init || 'undefined'));
		}

		// Статические методы
		for (var method in-array staticMethods){
			if (method.publicMode === 'private')
				result.push (method);
			else
				result.push (expressionStatement (assignmentExpression (
					memberExpression (classEntry.id.name, method.id),
					functionExpression (null, method.params, method.body))));
		}
	} else {
		var properties = [];
		result = [ oneVariableDeclaration (classEntry.id, objectExpression (properties)) ];

		// Статические поля
		for (var field in-array staticFields){
			if (field.publicMode === 'private')
				result [0].declarations.push (field);
			else 
				properties.push (property (field.id, field.init || 'undefined'));
		}

		// Статические методы
		for (var method in-array staticMethods){
			if (method.publicMode === 'private')
				result.push (method);
			else
				properties.push (property (method.id, functionExpression (null, method.params, method.body)));
		}
	}

	// Инициализатор
	if (initializer.body.body.length > 0)
		result.push (expressionStatement (callExpression (initializer)));

	// Если есть приватные статические члены, результатом будет анонимная функция
	if (anonymousFunction){
		result.push (returnStatement (classEntry.id.name));
		return [ oneVariableDeclaration (classEntry.id, callFunctionExpression (result)) ];
	}

	return result;
}

function processClasses (){
	for (var classEntry in-array classes)
		classEntry.elements = processClass (classEntry);
}
