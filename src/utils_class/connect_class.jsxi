function connectClass (current, from){
	if (from !== undefined)
		current.childs.push (from);

	if (current.connected)
		return;

	if (current.dependsOn.parent !== null){
		var parent = byName (current.dependsOn.parent.name);

		if (!parent)
			throwError (current.dependsOn.parent, Messages.ParentClassNotFound, current.dependsOn.parent.name);

		connectClass (parent, current);

		for (var id, member in parent.members)
			if (!current.members.hasOwnProperty (id))
				current.members [id] = $.extend (true, {}, member, { publicMode: member.publicMode === 'private' ? 'locked' : member.publicMode });

		var parentConstructor = parent.members ['@constructor'],
			currentConstructor = current.members ['@constructor'];

		if (!parentConstructor)
			return;

		if (!currentConstructor){
			addMember (current, functionExpression (parentConstructor.params, 
					[ expressionStatement (superExpression (parentConstructor.params)) ]))

		} else if (!currentConstructor.body.body.filter (lambda arg.type === Syntax.ExpressionStatement && 'super' in arg.expression).length){ 	// FIXME: Deep search
			if (currentConstructor.autocreated || parentConstructor.params.length === 0){
				if (currentConstructor.autocreated)
					currentConstructor.params = parentConstructor.params;
				currentConstructor.body.body = [ expressionStatement (superExpression (null, parentConstructor.params)) ].concat (currentConstructor.body.body);
			} else 
				throwError (currentConstructor, Messages.SuperConstructorCallNeeded);
		}
	}

	for (var use in-array current.dependsOn.uses){
		var used = byName (use.name);
		if (!used)
			throwError (use, Messages.UsingClassNotFound, use.name);
	}

	current.connected = true;
}

function connectClasses (){
	for (var classEntry in-array classes)
		connectClass (classEntry);
}