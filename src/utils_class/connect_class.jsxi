function searchSuperExpression (obj)
	if (obj.type === Syntax.CallExpression && 'super' in obj && obj.callee === null){
		return true;
	} else if (obj && obj.body && obj.body.body){
		for (var child in-array obj.body.body){
			if (searchSuperExpression (child))
				return true;
		}
	} else {
		for (var key, child in obj)
			if (child && typeof child.type === 'string' && searchSuperExpression (child))
				return true;
	}

function connectClass (current, from){
	if (from !== undefined)
		current.childs.push (from);

	if (current.connected)
		return;

	if (current.dependsOn.parent !== null){
		var parent = byName (current.dependsOn.parent.name);

		if (!parent)
			throw new TypeError ('Parent class not found', current.dependsOn.parent);

		connectClass (parent, current);

		for (var id, member in parent.members)
			if (!current.members.hasOwnProperty (id))
				current.members [id] = $.extend (true, {}, member, { publicMode: member.publicMode === 'private' ? 'locked' : member.publicMode });

		var parentConstructor = parent.members ['@constructor'],
			constructor = current.members ['@constructor'];

		if (parentConstructor.body.body.length > 0 && !searchSuperExpression (constructor)){
			if (constructor.autocreated || parentConstructor.params.length === 0){
				var updated = [];

				for (var statement in-array constructor.body.body){
					if (statement.autocreated)
						updated.push (statement);
					else
						break;
				}

				updated.push (expressionStatement (superExpression (null)) );
				[].push.apply (updated, constructor.body.body.slice (updated.length));

				constructor.body.body = updated;
			} else
				throw new TypeError ('Super constructor call is required', constructor);
		}
	}

	for (var use in-array current.dependsOn.uses){
		var used = byName (use.name);
		if (!used)
			throw new TypeError ('Used class "' + use.name + '" not found', use);
	}

	current.connected = true;
}

function connectClasses (){
	for (var classEntry in-array classes)
		connectClass (classEntry);
}