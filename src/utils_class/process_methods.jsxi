// Обработка метода класса
function processClassMethod (classEntry, methodEntry){
	console.assert (classEntry && methodEntry, 'Wrong arguments');

	options.filename = methodEntry.filename;

	// Тут будут лежать имена локальных переменных
	var exclusions = {};

	// Ссылка на ноду AST текущей обрабатываемой функции
	var currentFunction;

	// Если какому-то из кусков AST понадобится ссылка на this,  он поменяет эту
	// переменную
	var usingThat = false;

	// Возвращает «this» или «that» в зависимости от того,  какая функция сейчас
	// обрабатывается
	function getThis (){
		// Определяем, дочерняя ли эта функция по отношению к основной обрабатываемой
		var childFunction = currentFunction !== methodEntry;

		// Если дочерняя, просим обеспечить ссылку на «this».
		if (childFunction)
			usingThat = true;

		return childFunction ? identifier (thatVariable) : thisExpression ();
	}

	// Ищет в переданном куске AST имена переменных, функций и прочей мути
	function lookForExclusions (obj, target)
		if (typeof obj === 'object' && obj !== null){
			if (obj instanceof Array){
				// Массивы пробегаем в ускоренном темпе
				for (var child in-array obj)
					lookForExclusions (child, target);

			} else if ('type' in obj){
				if (obj.type === Syntax.VariableDeclarator || obj.type === Syntax.FunctionDeclaration){
					// Переменные и функции записываем
					target [obj.id.name] = true;

				} else if (obj.type !== Syntax.FunctionExpression){
					// А по содержимое функций не трогаем
					for (var key, value in obj)
						lookForExclusions (value, target);
				}
			}
		}

	// Обработка функции
	function processFunction (obj, parent){
		console.assert (typeof obj === 'object' 
			&& (obj.type === Syntax.FunctionDeclaration || obj.type === Syntax.FunctionExpression), 'Wrong argument');

		// Сохраняем текущие значения, а после переустанавливаем на свои
		var oldExclusions = $.extend (true, {}, exclusions),
			oldCurrentFunction = currentFunction;

		currentFunction = obj;

		// Заносим в исключения аргументы функции
		obj.params.forEach (lambda exclusions [arg.name] = true);

		// И ищем внутри переменные
		lookForExclusions (obj.body.body, exclusions);

		// Обновляем содержимое
		process (obj.body.body, obj);

		// Если кто-то попросил ссылку на «this», а мы — главная функция, добавим её.
		if (usingThat && methodEntry === obj){
			var temp = variableDeclarator (thatVariable, thisExpression ());

			if (obj.body.body [0] && obj.body.body [0].type === Syntax.VariableDeclaration)
				// Если первым идёт список переменных, кидаем в начало списка
				obj.body.body [0].declarations.unshift (temp);
			else
				// Иначе — в начало функции
				obj.body.body.unshift (variableDeclaration ([ temp ]));
		}

		// Возвращаем старые значения
		exclusions = oldExclusions;
		currentFunction = oldCurrentFunction;
	}

	function processProperty (obj, parent){
		process (obj.value, parent);
	}

	function processIdentifier (obj, parent){
		// Несколько адовая функция

		function replaceObject (member){
			// Из статичных свойств обращаться к свойствам объекта как-то непра-
			// вильно (methodEntry  -  нода AST основной обрабатываемой функции,
			// на неё и смотрим)
			if (methodEntry.static)
				throw new TypeError ('Member "' + obj.name + '" is static', obj);

			// Получаем ссылку на «this» (или «that»)
			var that = getThis ();

			// Результат
			var result;

			// Если обращались к функции и при этом она не вызывается, имеет смысл привязать её к объекту
			if (member.method && parent.type !== Syntax.CallExpression){
				helpers.set ('bindOnce', obj);
				result = callExpression ('__bindOnce', [ that, stringLiteralWithQuotes (member.id.name) ]);
			} else {
				result = memberExpression (that, member.id.name);
			}

			return result;
		}

		function replaceStatic (member){
			// Да, тут всё куда проще

			// Имя класса, в котором определено то нечто, к чему мы обращаемся
			var className = member.className;

			// Используем «className.name», потому что иначе две ноды AST будут представлены одним и тем же
			// объектом, что может выйти боком (а при передаче именно строки будет создана новая нода)
			return memberExpression (className.name, member.id.name);
		}

		// Проверяем, нет ли в исключениях такого же идентификатора
		if (!(obj.name in exclusions)){
			var result = null,
				member;

			if (obj.name in classEntry.members){
				// Обрабатываем метод или поле (приватные статические методы или
				// поля ставятся иначе, и замена для них не нужна)

				member = classEntry.members [obj.name];

				// Не даём обращаться и к скрытым полям
				if (member.publicMode === 'locked')
					throw new TypeError ('Member "' + obj.name + '" has private access', obj);

				if (!member.static)
					result = replaceObject (member);
				else if (member.publicMode !== 'private')
					result = replaceStatic (member);

			} else if (byName (obj.name, classEntry.path)){
				// Если внезапно нашли имя другого класса, отмечаем, что, вероятно, обрабатываемый класс использует этот
				// другой класс и имело бы смысл по возможности поместить его ниже.
				classEntry.weight += 0.0001;
			}

			// Меняем объект, если что-то нашлось
			if (result)
				set (obj, result);
		}
	}

	function processAssignmentExpression (obj, parent){
		process (obj.right, obj);
		process (obj.left, obj);
	}

	function processMemberExpression (obj, parent, preparent){
		var member,
			propertyNameGetter,
			second,
			temp;

		if (!obj.computed){
			member = classEntry.members.hasOwnProperty (obj.property.name) ? classEntry.members [obj.property.name] : null;

			if (member){
				if (member.static){
					if (member.publicMode === 'private' && obj.object.type === Syntax.Identifier && obj.object.name === member.className.name){
						set (obj, identifier (member.id.name));
						return;
					}
				} else if (obj.object.type === Syntax.ThisExpression){
					obj.property.name = member.id.name;
				} else if (0 && member.publicMode !== 'public'){
					if (parent instanceof Array && preparent)
						parent = preparent;

					if (obj.object.type === Syntax.Identifier){
						obj.computed = true;
						obj.property = conditionalExpression (
							binaryExpression (obj.object, 'instanceof', member.className.name), 
							stringLiteralWithQuotes (member.id.name), 
							stringLiteralWithQuotes (obj.property.name));

						process (obj.object, obj);
					} else if (parent.type === Syntax.AssignmentExpression){
						second = $.extend (true, {}, parent);
						for (var key, value in parent)
							if (value === obj)
								second [key] = memberExpression ('__', conditionalExpression (
									binaryExpression ('__', 'instanceof', member.className.name), 
									stringLiteralWithQuotes (member.id.name), 
									stringLiteralWithQuotes (obj.property.name)), true);

						set (parent, sequenceExpression ([
							assignmentExpression ('__', obj.object), 
							second
						]));

						process (obj.object, obj);

						temp = true;
					} else {
						set (obj, sequenceExpression ([
							assignmentExpression ('__', obj.object), 
							memberExpression ('__', conditionalExpression (
						 			binaryExpression ('__', 'instanceof', member.className.name), 
						 			stringLiteralWithQuotes (member.id.name), 
						 			stringLiteralWithQuotes (obj.property.name)), true)
						]));

						process (obj);

						if (parent.type === Syntax.CallExpression && obj === parent.callee){
							parent.callee = memberExpression (parent.callee, 'call');
							parent.arguments.unshift (identifier ('__'));
						}

						temp = true;
					}

					if (temp && !currentFunction.hasTempVariable){
						currentFunction.body.body.unshift (oneVariableDeclaration ('__'));
						currentFunction.hasTempVariable = true;
					}

					return;
				}
			}
		}

		// Всё довольно просто — обрабатываем объект ...
		process (obj.object, obj);

		// ... и, если обращение выполняется через квадратные скобки, заодно и их содержимое
		if (obj.computed)
			process (obj.property, obj);
	}

	function processSuperExpression (obj, parent){
		// TODO: static

		// Либо «super» используется в корне одной из функций объекта, или у него есть
		// имя вызываемого супер-метода
		if (currentFunction !== methodEntry && obj.callee === null)
			throw new Error ('Not implemented'); // TODO

		// Ищем название нужного класса, идя по дереву классов
		var currentClass = classEntry;

		// В поле «super» хранится, на сколько нужно подняться
		for (var i = 0; i < obj ['super']; i ++){
			currentClass = currentClass.dependsOn.parent;

			// Если вдруг родителей не хватает, вываливаемся
			if (!currentClass)
				throw new TypeError ('Super method is not available', obj);
		}

		// Вызываемый метод
		var method = obj.callee ? currentClass.members [obj.callee.name] : findByReplacement (currentClass, methodEntry.id.name);

		if (!method)
			throw new TypeError ('Super method not found', obj);

		if (method.static)
			throw new TypeError ('This method is static', obj);

		// У кого вызывать метод
		var target;

		if (method.id.name [0] !== '@'){
			// Если имя где-то, но есть, и при этом это не конструктор или деструктор, вызываем метод из прототипа
			target = memberExpression (memberExpression (currentClass.id, 'prototype'), method.id.name);
		} else {
			// Иначе вызываем конструктор
			target = currentClass.id.name;
		}

		// Если вызов без скобок, подставляем все аргументы
		if (obj.arguments === null){
			obj.callee = memberExpression (target, 'apply');
			obj.arguments = [ identifier ('arguments') ];
		} else 
			obj.callee = memberExpression (target, 'call');

		// Не забываем добавить «this» в аргументы
		obj.arguments.unshift (getThis ());
	}

	function process (obj, parent, preparent){
		if (typeof obj === 'object' && obj !== null){
			// Как-нибудь обойдёмся и без строк, чисел, null'ов и прочей мути

			if (obj instanceof Array){
				// Массивы пробегаем в ускоренном темпе
				for (var child in-array obj)
					process (child, obj, parent);

			} else if ('type' in obj){
				// Тут всё и так вполне очевидно

				switch (obj.type){
					case Syntax.FunctionDeclaration:
					case Syntax.FunctionExpression:
						processFunction (obj, parent);
						break;

					case Syntax.Property:
						processProperty (obj, parent);
						break;

					case Syntax.Identifier:
						processIdentifier (obj, parent);
						break;

					case Syntax.AssignmentExpression:
						processAssignmentExpression (obj, parent);
						break;

					case Syntax.MemberExpression:
						processMemberExpression (obj, parent, preparent);
						break;

					case Syntax.CallExpression:
						if ('super' in obj)
							processSuperExpression (obj, parent);
						// Оператор «break» пропущен специально

					default:
						for (var key, value in obj){
							// TODO: Optimize by key filtering?
							process (value, obj);
						}
				}
			}
		}
	}

	process (methodEntry);
}

function processClassMethods (classEntry){
	var replace,
		childMember;

	// Проходим по всем методам именно этого класса
	for (var name, member in classEntry.members){
		if (member.method && !member.abstract && member.className === classEntry.id)
			processClassMethod (classEntry, member);
	}
}

function processClassesMethods (){
	for (var classEntry in-array classes)
		processClassMethods (classEntry);
}