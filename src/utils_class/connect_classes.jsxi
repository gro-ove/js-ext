function searchSuperExpression (obj)
	if (obj.type === Syntax.CallExpression && 'super' in obj && obj.callee === null){
		return true;
	} else if (obj && obj.body && obj.body.body){
		for (var child in-array obj.body.body){
			if (searchSuperExpression (child))
				return true;
		}
	} else {
		for (var key, child in obj)
			if (child && typeof child.type === 'string' && searchSuperExpression (child))
				return true;
	}

// Проверяем, ацикличен ли граф классов и всё такое
function connectClasses (){
	var active = {};

	function process (current, from){
		if (active [current.id.name] === true)
			throw new TypeError ('Circular dependency', current.id);

		if (from)
			current.childs.push (from);

		if (current.weight)
			return;

		active [current.id.name] = true;
		current.weight = 1;

		if (current.dependsOn.parent){
			var parent = byName (current.dependsOn.parent.name, current.path);

			if (!parent)
				throw new TypeError ('Parent class "' + current.dependsOn.parent.name + '" not found', current.dependsOn.parent);
			
			current.dependsOn.parent = parent;

			process (parent, current);
			current.weight += parent.weight;

			for (var id, member in parent.members)
				if (!current.members.hasOwnProperty (id))
					current.members [id] = $.extend (true, {}, member, { publicMode: member.publicMode === 'private' ? 'locked' : member.publicMode });

			var parentConstructor = parent.members ['@constructor'],
				constructor = current.members ['@constructor'];

			if (parentConstructor.body.body.length > 0 && !searchSuperExpression (constructor)){
				if (constructor.autocreated || parentConstructor.params.length === 0){
					for (var autocreated, statement in-array constructor.body.body){
						if (!statement.autocreated)
							break;
					}

					constructor.body.body.splice (autocreated, 0, expressionStatement (superExpression (null)));
				} else
					throw new TypeError ('Super constructor call is required', constructor);
			}
		}

		for (var index, usedName in-array current.dependsOn.uses){
			var used = byName (usedName.name, current.path);

			if (!used)
				throw new TypeError ('Used class "' + usedName.name + '" not found', usedName);

			current.dependsOn.uses [index] = used;

			process (used);
			current.weight += used.weight;
		}

		delete active [current.id.name];
	}

	for (var current in-array classes)
		process (current);
}