var classes, 
	probablyUseOtherMaxValue, 
	thatVariable,
	tempId = 0;

// Получить ближайший класс по имени и пути
function byName (name, path){
	console.assert (typeof name === 'string' && typeof path === 'string', 'Wrong args');

	var length, min = -1, result;

	for (var classEntry in-array classes){
		length = classEntry.path.length;

		if (classEntry.id.name === name && path.substr (0, length) === classEntry.path && min < length){
			min = length;
			result = classEntry;
		}
	}

	return result;
}

// function moveClasses (statements){
// 	var classes = [];

// 	function collectClasses (obj)
// 		if (obj instanceof Array){
// 			for (var index, child in-array obj)
// 				if (child.type === Syntax.ClassDeclaration){
// 					classes.push (child);
// 					obj [index] = null;
// 				} else
// 					collectClasses (child);

// 			set (obj, obj.filter (lambda arg));
// 		} else if (obj && typeof obj === 'object' && obj.type !== Syntax.FunctionDeclaration && obj.type !== Syntax.FunctionExpression){
// 			for (var key, child in obj)
// 				if (child && child.type === Syntax.ClassDeclaration){
// 					classes.push (child);
// 					obj [key] = { type: Syntax.EmptyStatement };
// 				} else
// 					collectClasses (child);
// 		}

// 	collectClasses (statements);
// 	set (statements, classes.sort (lambda (a, b) byName (a.name).weight - byName (b.name).weight).concat (statements));
// }

function collectRawClasses (obj, location = { root: obj, path: '' }, array = []){
	if (obj instanceof Array){
		set (obj, obj.filter (lambda (child){
			collectRawClasses (child, location, array);

			if (child.type === Syntax.RawClassDeclaration){
				array.push ($.extend (child, location));
				return false;
			} else
				return true;
		}));
	} else if (obj && typeof obj === 'object'){
		if (obj.type === Syntax.FunctionDeclaration || obj.type === Syntax.FunctionExpression){
			if (obj.body)
				collectRawClasses (obj.body.body, { root: obj.body.body, path: location.path + '/' + ++ tempId }, array);
		} else
			for (var key, child in obj){
				collectRawClasses (child, location, array);

				if (child && child.type === Syntax.RawClassDeclaration){
					array.push ($.extend (child, location));
					obj [key] = { type: Syntax.EmptyStatement };
				}
			}
	}

	return array;
}

function sortAndInsertClasses (){
	for (var current in-array classes.sort (lambda (a, b) b.weight - a.weight)){
		console.log (current.statements);
		current.root.unshift ({
			type: 			Syntax.ClassDeclaration,
			name: 			current.id.name,
			statements: 	current.statements
		});
	}
}

// Обрабатываем все классы
function doClasses (statements, callback){
	helpers 					= new HelpersManager ();
	classes 					= [];
	options 					= {};
	probablyUseOtherMaxValue 	= 100;
	thatVariable 				= '__that';

	for (var found in-array collectRawClasses (statements))
		addClass (found);

	if (classes.length > 0){
		connectClasses ();
		processClassesMembers ();
		processClassesMethods ();
		processClasses ();
		sortAndInsertClasses ();

		console.log (classes.map (lambda arg.id.name + ':' + arg.weight + (arg.childs.length ? ' (' + arg.childs.map (lambda arg.id.name).join (', ') + ')' : '')).join ('; '));

		// connectClasses ();
		// sortClasses ();
		// processClassesMembers ();
		// processClassesMethods ();
		// processClasses ();
		// sortClasses ();

		// moveClasses (statements);

		callback (helpers.helpers);
	} else
		callback ();

	options = null;
}