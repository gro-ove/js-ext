// Получаем заменённое имя в зависимости от видимости переменной
function rename (name, member){
	// Скрытым или приватным и статическим членам имя не меняем
	if (member.publicMode === 'locked' || member.static && member.publicMode === 'private')
		return name;

	switch (member.publicMode){
		case 'protected':
			return '__' + name;

		case 'private':
			return '__' + member.className.name + '_' + name;

		case 'public':
			return name;

		default:
			console.assert (false, 'Bad publicMode value');
	}
}

// Проверяем, может ли поле или метод childMember перекрыть поле или метод роди-
// тельского класса parentMember
function testBadOverride (parentMember, childMember)
	switch (childMember.publicMode){
		// Как и с градусом, нельзя понижать. Я имею в виду, конечно же, уровень
		// видимости.

		case 'public':
			return false;

		case 'protected':
			return parentMember.publicMode === 'public';

		case 'private':
			return parentMember.publicMode !== 'private';

		case 'locked':
			return false;

		default:
			console.assert (false, 'Bad publicMode value');
	}

function morePublicMode (firstMode, secondMode){
	var modes = [ 'locked', 'private', 'protected', 'public' ],
		firstId = modes.indexOf (firstMode),
		secondId = modes.indexOf (secondMode),
		maxId = Math.max (firstId, secondId);

	return modes [maxId];
}

function processClassMember (classEntry, name, parentMember){
	var newPublicMode = parentMember.publicMode,
		targetMembers = [ parentMember ],
		argument,
		updatedName;

	function testChilds (currentClass){
		var childMember;

		for (var childClass in-array currentClass.childs){
			if (childClass.members.hasOwnProperty (name)){
				childMember = childClass.members [name];

				if (testBadOverride (parentMember, childMember))
					throwError (childMember.id, 'Invalid public mode ("' + childMember.publicMode + '" instead of "' + parentMember.publicMode 
						+ '" for member "' + name + '" of class "' + childClass.id.name + '" which extends "' + currentClass.id.name + '")');

				if (parentMember.method !== childMember.method)
					throwError (childMember.id, 'Invalid override (' + (childMember.method ? 'method' : 'field') + ' instead of ' + (parentMember.method ? 'method' : 'field')
						+ ' for member "' + name + '" of class "' + childClass.id.name + '" which extends "' + currentClass.id.name + '")');

				newPublicMode = morePublicMode (newPublicMode, childMember.publicMode);
				targetMembers.push (childMember);
			}

			testChilds (childClass);
		}
	}

	testChilds (classEntry);

	if (newPublicMode !== parentMember.publicMode)
		argument = $.extend ({}, parentMember, { publicMode: newPublicMode });
	else
		argument = parentMember;

	updatedName = rename (name, argument);

	for (var targetMember in-array targetMembers){
		targetMember.id.name = updatedName;
		targetMember.processed = true;
	}
}

function processClassMembers (classEntry){
	var replace,
		childMember;

	// Проходим по всем полям и методам класса,  кроме конструктора, инициализа-
	// тора и уже обработанных полей или методов
	for (var name, member in classEntry.members)
		if (name [0] !== '@' && !member.processed)
			processClassMember (classEntry, name, member);
}

function processClassesMembers (){
	for (var classEntry in-array classes)
		processClassMembers (classEntry);
}