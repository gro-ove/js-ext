function processClassesMembers (){
	// Получаем заменённое имя в зависимости от видимости переменной
	function rename (name, member, publicMode){
		// Скрытым или приватным и статическим членам имя не меняем
		if (publicMode === 'locked' || member.static && publicMode === 'private')
			return name;

		switch (publicMode){
			case 'protected':
				return '__' + name;

			case 'private':
				return '__' + member.className.name + '_' + name;

			case 'public':
				return name;

			default:
				console.assert (false, 'Bad publicMode value');
		}
	}

	// Проверяем, ошибочно ли перекрытие поля или метода родительского класса (нельзя понижать видимость)
	function badOverride (parentMember, childMember)
		switch (childMember.publicMode){
			case 'public':
				return false;

			case 'protected':
				return parentMember.publicMode === 'public';

			case 'private':
				return true;

			default:
				console.assert (false, 'Bad publicMode value: ' + childMember.publicMode);
		}

	function morePublicMode (firstMode, secondMode){
		var modes = [ 'locked', 'private', 'protected', 'public' ],
			firstId = modes.indexOf (firstMode),
			secondId = modes.indexOf (secondMode),
			maxId = Math.max (firstId, secondId);

		return modes [maxId];
	}

	function processClassMember (current, name, member){
		var publicMode = member.publicMode,
			members = [ member ],
			updated;

		function testChilds (current)
			for (var child in-array current.childs){
				if (child.members.hasOwnProperty (name)){
					var childMember = child.members [name];

					if (badOverride (member, childMember))
						throw new TypeError ('Invalid public mode', childMember.id);

					if (member.method !== childMember.method)
						throw new TypeError ('Invalid override (' + (member.method ? 'method' : 'field') + ' required)', childMember.id);

					publicMode = morePublicMode (publicMode, childMember.publicMode);
					members.push (childMember);
				}

				testChilds (child);
			}

		if (publicMode === 'protected' || publicMode === 'public')
			testChilds (current);

		updated = rename (name, member, publicMode);

		for (var targetMember in-array members){
			targetMember.id.name = updated;
			targetMember.processed = true;
		}
	}

	function processClassMembers (current){
		if (current.dependsOn.parent)
			processClassMembers (current.dependsOn.parent);

		// Проходим по всем полям и методам класса, кроме конструктора, инициализатора и уже обработанных полей или методов
		for (var name, member in current.members)
			if (name [0] !== '@' && !member.processed)
				processClassMember (current, name, member);
	}

	for (var current in-array classes)
		processClassMembers (current);
}