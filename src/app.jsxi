console.fatal = function (code){
	console.error.apply (console, Array.prototype.slice.call (arguments, typeof code === 'number' ? 1 : 0));
	process.exit (typeof code === 'number' ? code : 0);
};

console.json = function (obj){
	console.log (JSON.stringify (obj, false, 2));
};

module App {
	import Parser, Generator;

	function parseArgs (data, args){
		var result = { 
			data: [],
			put: lambda (info, value){
				if (info.p == 2){
					if (!this [info.s])
						this [info.s] = [];
					this [info.s].push (value);
				} else
					this [info.s] = info.p ? value : true;
			} 
		};

		for (var i, s in-array data){
			function put (fn, info)
				if (info = args.filter (fn)[0]){
					result.put (info, data [i + 1]);
					if (info.p)
						++ i;
				} else 
					console.fatal (1, 'Invalid arguments. Use "--usage" for view help.');

			if (s [0] == '-'){
				if (s [1] == '-')
					put (lambda arg.l == s.slice (2));
				else 
					for (var k in-array s.slice (1))
						put (lambda arg.s == k);
			} else
				result.data.push (s);
		}

		if (result.h){
			console.log ('Available args:')
			args.forEach (lambda console.log (' -{0} (--{1})'.format (arg.s, arg.l)));
			process.exit (0);
		} else
			return result;
	}

	var macros = {};

	var Macro = function (){
		var defaultArgs = [
			{ name: 'args' },
			{ name: 'fs', value: require ('fs') }, 
			{ name: 'path', value: require ('path') }
		];

		return lambda (macroArgs, macroBody){
			if (!macroBody){
				macroBody = macroArgs;
				macroArgs = null;
			}

			var fn = macroArgs
				? new Function (macroArgs.map (lambda arg.name).join (','), convert (macroBody, 'macro'))
				: new Function (defaultArgs.map (lambda arg.name).join (), 'return ' + convert (macroBody, 'macros'));

			return lambda (args) fn.apply (null, macroArgs ? args : defaultArgs.map (lambda arg.value || args));
		}
	}();

	function loadFile (path){
		try var file = require ('fs').readFileSync (args.data [0]);
		if (!file)
			console.fatal (2, 'Reading error: ' + file);

		preparseFile (file.toString ());
	}

	function getParams (data){
		var all = data.match (/(?:^|[\r\n])[ \t]*\/\/[ \t]*==([a-z]+)==[\s\S]+?[\r\n][ \t]*\/\/[ \t]*==\/\1==/gi),
			result = {};

		all.forEach (lambda {
			var temp = {};

			arg.replace (/[\r\n][ \t]*\/\/[ \t]*@[ \t]*([^\s]+)(?:[ \t]+([^\n\r]+))?/g, lambda (s, k, v){
				k = k.trim ();
				if (!temp [k])
					temp [k] = [];
				temp [k].push (v ? v.trim () : true);
			});

			result [arg.match (/==([a-z]+)==/i)[1].toLowerCase ()] = temp;
		});

		return result;
	}

	function convert (jsxCode, fileName){
		return require ('escodegen').generate (typeof jsxCode === 'string' ? Parser.parse (jsxCode, { fileName: fileName }) : jsxCode);
	}

	function LiteParser (data, index = 0){
		this.data 		= data;
		this.index 		= index;
		this.binded 	= [];
	}

	LiteParser.prototype.update = function (data, delta = 0){
		this.data 		= data;
		this.index  	+= delta;
	}

	LiteParser.prototype.on = function (what, fn){
		this.binded.push ({ match: what, react: fn });
	}

	LiteParser.prototype.findNext = function (){
		function indexOf (str, what, pos, id)
			if (what instanceof RegExp){
				var temp = str.substring (pos).match (what);
				return {
					id: 	id,
					index: 	temp ? temp.index + pos : -1,
					value: 	temp ? temp [0] : null,
					raw: 	temp
				};
			} else 
				return {
					id: 	id,
					index: 	str.indexOf (what, pos),
					value: 	what
				};

		var min = Number.POSITIVE_INFINITY, 
			value,
			temp;

		for ()

		for (var i, arg in-array arguments){
			temp = indexOf (this.data, arg, this.index, i);
			if (temp.index !== -1 && temp.index < min){
				value = temp;
				this.index = temp.index + temp.value.length;
			}
		}

		return temp;
	}

	function preparseFile (data){
		var liteParser = new LiteParser (data).on ('//', lambda this.findNext ('\n', '\r')),
			found;

		var macros = [];

		function find (){
			var found;
			while (found = LiteParser.prototype.findNext.apply (liteParser, arguments)){
				switch (){

				}
			}
		}

		while (found = liteParser.findNext ('//', '/*', '\'', '"', '`', (/@macro\s+([_$a-z][_$a-z0-9]*)\s*(=)?/), '@', '{', '}')){
			switch (found.id){
				case 0: // //
					liteParser.findNext ('\n', '\r'/* TODO: , '\u2028', '\u2029'*/);
					break;
				case 1: // /*
					liteParser.findNext ('*/');
					break;
				case 2: // '
				case 3: // "
				case 4: // `
					while (temp = liteParser.findNext ('\\' + found.value, found.value))
						if (temp.value === found.value)
							break;
					break;
				case 5: // @macro
					var name = found.raw [1];
					if (found.raw [2]){
						// ...
						liteParser.
					} else {
						console.log (data [liteParser.index]);
						console.log (name, !!found.raw [2]);
					}
					break;
				case 6:	// @
					break;
				case 7: // {
					break;
				case 8: // }
					break;
			}
		}
	}

	function preparseFile2 (data){
		var params = getParams (data),
			cutted;

		/*if (params.jsx && params.jsx.macro)
			params.jsx.macro.forEach (lambda {
				console.assert (cutted = arg.match (/^([^\s]+)\s+([\s\S]+)$/), 'Macros parsing error');
				macros [cutted [1]] = new Macro (cutted [2]);
			});*/

		var liteParser = new LiteParser (data),
			found,
			temp;

		function commentsAndStringsSkip (found, liteParser){
			switch (found.value){
				case '//':
					liteParser.findNext ('\n', '\r'/* TODO: , '\u2028', '\u2029'*/);
					return true;
				case '/*':
					liteParser.findNext ('*/');
					return true;
				case '\'':
				case '"':
				case '`':
					while (temp = liteParser.findNext ('\\' + found.value, found.value))
						if (temp.value === found.value)
							return true;
			}
		}

		function bracketsSkip (liteParser, open, close){
			var temp = tempLiteParser.findNext (open, close);
			if (temp && temp.value === open)
				bracketsSkip (liteParser);
		}

		function cast (value){
			if (value.match (/^((\d+|\d*\.\d+)(e[+-]?\d+)?|0x[\da-f]+)$/i))
			 	return +value;

			var data = Parser.parse (value, { fileName: 'macro arg' }); // TODO

			if (data.body [0].type === Syntax.BlockStatement){
				return {
					ast: data.body,
					raw: value.slice (1, -1).trim ()
				};
			} else {
				try {
					eval ('data = ' + convert (data));
					return data;
				} catch {
					// TODO
					throw e;
				}
			}
		}

		while (found = liteParser.findNext ('//', '/*', '@', '\'', '"', '`')){
			if (commentsAndStringsSkip (found, liteParser))
				continue;

			if (found.value === '@'){
				var matched = data.substr (found.index + 1).match (/([_$a-z][_$a-z0-9]*)(\s*\()?/i);

				if (matched && macros [matched [1]]){
					var begin 		= found.index + 1 + matched [1].length,
						arguments 	= [];

					if (matched [2]){
						var last 			= begin + matched [2].length,
							tempLiteParser 	= new LiteParser (data, last),
							tempFound;

						tempLoop: while (tempFound = tempLiteParser.findNext ('//', '/*', '\'', '"', '`', '(', ')', ',', '{')){
							if (commentsAndStringsSkip (tempFound, tempLiteParser))
								continue;

							switch (tempFound.value){
								case ',':
									arguments.push (cast (data.substring (last, tempFound.index).trim ()));
									last = tempFound.index + 1;
									break;
								case ')':
									arguments.push (cast (data.substring (last, tempFound.index).trim ()));
									begin = tempFound.index + 1;
									break tempLoop;
								case '(':
									bracketsSkip (tempLiteParser, '(', ')');
									break;
								case '{':
									bracketsSkip (tempLiteParser, '{', '}');
									break;
								case '[':
									bracketsSkip (tempLiteParser, '[', ']');
									break;
							}
						}
					}

					var result = macros [matched [1]](arguments);
					if (result && result.type === Syntax.Program)
						result = convert (data);

					data = data.substr (0, found.index) + result + data.substr (begin);
					liteParser.update (data, -1);
				}
			}
		}

		/*data = data.replace (/@([a-z]+)/ig, function (s, n){
			console.log (n, macroses [n]);
			if (macroses [n])
				return macroses [n]();
			else
				return s;
		});*/

		console.log (data);
	}

	function simpleTransform (fileName){
		try var file = require ('fs').readFileSync (fileName);

		if (!file)
			console.fatal (2, 'Reading error');

		var parsed = Parser.parse (file, { information: true, fileName: require ('path').basename (args.data [0]) });

		var str = Generator.work (parsed, require ('path').basename (args.data [0]));
		try 
			console.log (require ('escodegen').generate (parsed));
		catch
			console.json (parsed);
	}

	function init (){
		// First and second args - "node" and script name
		args = parseArgs (process.argv.slice (2), [
				// s - short, l - long, p - parameter (1 - one, 2 - multiple)
				{ 	s: 'i', 	l: 'include', 	p: 2		},
				{ 	s: 'o', 	l: 'output',  	p: 1		},
				{   s: 'h',		l: 'usage'					}
			]);

		loadFile (args.data [0]);
		// simpleTransform (args.data [0]);
	}
}