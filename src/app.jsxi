console.fatal = function (code){
	console.error.apply (console, Array.prototype.slice.call (arguments, typeof code === 'number' ? 1 : 0));
	process.exit (typeof code === 'number' ? code : 0);
};

console.json = function (obj){
	console.log (JSON.stringify (obj, false, 2));
};

module App {
	import Parser, Generator;

	function parseArgs (data, args){
		var result = { 
			data: [],
			put: lambda (info, value){
				if (info.p == 2){
					if (!this [info.s])
						this [info.s] = [];
					this [info.s].push (value);
				} else
					this [info.s] = info.p ? value : true;
			} 
		};

		for (var i, s in-array data){
			function put (fn, info)
				if (info = args.filter (fn)[0]){
					result.put (info, data [i + 1]);
					if (info.p)
						++ i;
				} else 
					console.fatal (1, 'Invalid arguments. Use "--usage" for view help.');

			if (s [0] == '-'){
				if (s [1] == '-')
					put (lambda arg.l == s.slice (2));
				else 
					for (var k in-array s.slice (1))
						put (lambda arg.s == k);
			} else
				result.data.push (s);
		}

		if (result.h){
			console.log ('Available args:')
			args.forEach (lambda console.log (' -{0} (--{1})'.format (arg.s, arg.l)));
			process.exit (0);
		} else
			return result;
	}

	var macros = {};

	var Macro = function (){
		var defaultArgs = [
			{ name: 'args' },
			{ name: 'fs', value: require ('fs') }, 
			{ name: 'path', value: require ('path') }
		];

		return lambda (macroArgs, macroBody){
			if (!macroBody){
				macroBody = macroArgs;
				macroArgs = null;
			}

			var fn = macroArgs
				? new Function (macroArgs.map (lambda arg.name).join (','), convert (macroBody, 'macro'))
				: new Function (defaultArgs.map (lambda arg.name).join (), 'return ' + convert (macroBody, 'macros'));

			return lambda (args) fn.apply (null, macroArgs ? args : defaultArgs.map (lambda arg.value || args));
		}
	}();

	function loadFile (path){
		try var file = require ('fs').readFileSync (args.data [0]);
		if (!file)
			console.fatal (2, 'Reading error: ' + file);

		preparseFile (file.toString ());
	}

	function getParams (data){
		var all = data.match (/(?:^|[\r\n])[ \t]*\/\/[ \t]*==([a-z]+)==[\s\S]+?[\r\n][ \t]*\/\/[ \t]*==\/\1==/gi),
			result = {};

		all.forEach (lambda {
			var temp = {};

			arg.replace (/[\r\n][ \t]*\/\/[ \t]*@[ \t]*([^\s]+)(?:[ \t]+([^\n\r]+))?/g, lambda (s, k, v){
				k = k.trim ();
				if (!temp [k])
					temp [k] = [];
				temp [k].push (v ? v.trim () : true);
			});

			result [arg.match (/==([a-z]+)==/i)[1].toLowerCase ()] = temp;
		});

		return result;
	}

	function convert (jsxCode, fileName){
		return require ('escodegen').generate (typeof jsxCode === 'string' ? Parser.parse (jsxCode, { fileName: fileName }) : jsxCode);
	}

	function LiteParser (data, index = 0){
		this.data 		= data;
		this.index 		= index;
		this.binded 	= [];
	}

	LiteParser.prototype.update = function (data, delta){
		if (typeof data === 'string')
			this.data = data;

		if (typeof delta === 'number')
			this.index = delta;
		else if (typeof data === 'number')
			this.index = data;

		return this;
	}

	LiteParser.prototype.on = function (){
		for (var i = 0; i < arguments.length - 1; i ++)
			this.binded.push ({ match: arguments [i], react: arguments [arguments.length - 1] });
		
		return this;
	}

	LiteParser.prototype.findNext = function (){
		function indexOf (str, what, pos, id)
			if (what instanceof RegExp){
				var temp = str.substring (pos).match (what);
				return {
					id: 	id,
					index: 	temp ? temp.index + pos : -1,
					value: 	temp ? temp [0] : null,
					raw: 	temp
				};
			} else 
				return {
					id: 	id,
					index: 	str.indexOf (what, pos),
					value: 	what
				};

		var value = { index: Number.POSITIVE_INFINITY },
			react,
			temp;

		for (var i, arg in-array this.binded){
			temp = indexOf (this.data, arg.match, this.index, i);
			if (temp.index !== -1 && temp.index < value.index){
				value = temp;
				react = arg.react;
			}
		}

		for (var i, arg in-array arguments){
			temp = indexOf (this.data, arg, this.index, i);
			if (temp.index !== -1 && temp.index < value.index){
				value = temp;
				react = null;
			}
		}

		if (value.index === Number.POSITIVE_INFINITY)
			return null;

		this.index 	= value.index + value.value.length;

		if (react){
			react.call (this, value);
			return LiteParser.prototype.findNext.apply (this, arguments);
		} else
			return value;
	}

	LiteParser.prototype.findHere = function (){
		var args 		= [].slice.call (arguments),
			operators 	= [ '(', '{', '[' ],
			others 		= [ ')', '}', ']' ],
			found, 
			temp;

		while (found = LiteParser.prototype.findNext.apply (this, args.concat (operators))){
			temp = operators.indexOf (found.value);
			if (operators.indexOf (found.value) !== -1){
				this.findHere (others [temp]);
			} else if (args.indexOf (found.value) !== -1)
				return found;
		}

		return null;
	}

	function preparseFile (data){
		var liteParser = new LiteParser (data)
				.on ('//', lambda this.findNext ('\n', '\r'))
				.on ('/*', lambda this.findNext ('*/'))
				.on ('\'', '"', '`', lambda {
					while (temp = liteParser.findNext ('\\' + found.value, found.value))
						if (temp.value === found.value)
							break;
				}),
			macros 	= [],
			calls 	= [],
			level 	= '',
			found,
			temp,
			name;

		function partReplace (from, to, by = ''){
			console.assert (from <= to, 'Invalid args');

			if (liteParser.index >= to)
				liteParser.index -= (to - from) - by.length;
			else if (liteParser.index > from)
				liteParser.index = from;

			liteParser.update (data = data.substr (0, from) + by + data.substr (to));
		}

		while (found = liteParser.findNext (
				/@macro\s+([_$a-z][_$a-z0-9]*)\s*(\()?/, 
				/@([_$a-z][_$a-z0-9]*)\s*(\()?/, 
				'{', '}')){
			switch (found.id){
				case 0:
					name = found.raw [1];

					if (found.raw [2]){
						// ...
					} else {
						if ((temp = liteParser.findHere (';')) === null)
							temp = { index: data.length };

						macros.push ({ 
							name: 		name, 
							callee: 	new Macro (data.substring (found.index + found.value.length, temp.index).trim ()), 
							level: 		level 
						});
					}

					partReplace (found.index, liteParser.index);

					break;
				case 1:
					name = found.raw [1];

					if (found.raw [2]){
						// ...
					} else {
						temp = [];
					}

					var pos = calls.push ({ 
						name: 		name, 
						arguments: 	temp, 
						level: 		level 
					}) - 1;

					partReplace (found.index, liteParser.index, '@call.' + pos);
					break;
				case 2:
					level += '.' + found.index;
					break;
				case 3:
					level = level.replace (/\.\d+$/, '');
					break;
			}
		}

		liteParser.update (0);

		while (found = liteParser.findNext (/@call\.(\d+)/)){
			var call = calls [+found.raw [1]];
			console.assert (call, 'wrong call identifier');

			var macro = macros.filter (lambda arg.name === call.name && call.level.indexOf (arg.level) === 0).sort (lambda (a, b) b.level.length - a.level.length)[0];
			console.assert (macro, 'macro not found');

			var result = macro.callee ();
			partReplace (found.index, liteParser.index, result);
		}

		console.json (macros);
		console.json (calls);
		console.log (data);
	}

	function preparseFile2 (data){
		var params = getParams (data),
			cutted;

		/*if (params.jsx && params.jsx.macro)
			params.jsx.macro.forEach (lambda {
				console.assert (cutted = arg.match (/^([^\s]+)\s+([\s\S]+)$/), 'Macros parsing error');
				macros [cutted [1]] = new Macro (cutted [2]);
			});*/

		var liteParser = new LiteParser (data),
			found,
			temp;

		function commentsAndStringsSkip (found, liteParser){
			switch (found.value){
				case '//':
					liteParser.findNext ('\n', '\r'/* TODO: , '\u2028', '\u2029'*/);
					return true;
				case '/*':
					liteParser.findNext ('*/');
					return true;
				case '\'':
				case '"':
				case '`':
					while (temp = liteParser.findNext ('\\' + found.value, found.value))
						if (temp.value === found.value)
							return true;
			}
		}

		function bracketsSkip (liteParser, open, close){
			var temp = tempLiteParser.findNext (open, close);
			if (temp && temp.value === open)
				bracketsSkip (liteParser);
		}

		function cast (value){
			if (value.match (/^((\d+|\d*\.\d+)(e[+-]?\d+)?|0x[\da-f]+)$/i))
			 	return +value;

			var data = Parser.parse (value, { fileName: 'macro arg' }); // TODO

			if (data.body [0].type === Syntax.BlockStatement){
				return {
					ast: data.body,
					raw: value.slice (1, -1).trim ()
				};
			} else {
				try {
					eval ('data = ' + convert (data));
					return data;
				} catch {
					// TODO
					throw e;
				}
			}
		}

		while (found = liteParser.findNext ('//', '/*', '@', '\'', '"', '`')){
			if (commentsAndStringsSkip (found, liteParser))
				continue;

			if (found.value === '@'){
				var matched = data.substr (found.index + 1).match (/([_$a-z][_$a-z0-9]*)(\s*\()?/i);

				if (matched && macros [matched [1]]){
					var begin 		= found.index + 1 + matched [1].length,
						arguments 	= [];

					if (matched [2]){
						var last 			= begin + matched [2].length,
							tempLiteParser 	= new LiteParser (data, last),
							tempFound;

						tempLoop: while (tempFound = tempLiteParser.findNext ('//', '/*', '\'', '"', '`', '(', ')', ',', '{')){
							if (commentsAndStringsSkip (tempFound, tempLiteParser))
								continue;

							switch (tempFound.value){
								case ',':
									arguments.push (cast (data.substring (last, tempFound.index).trim ()));
									last = tempFound.index + 1;
									break;
								case ')':
									arguments.push (cast (data.substring (last, tempFound.index).trim ()));
									begin = tempFound.index + 1;
									break tempLoop;
								case '(':
									bracketsSkip (tempLiteParser, '(', ')');
									break;
								case '{':
									bracketsSkip (tempLiteParser, '{', '}');
									break;
								case '[':
									bracketsSkip (tempLiteParser, '[', ']');
									break;
							}
						}
					}

					var result = macros [matched [1]](arguments);
					if (result && result.type === Syntax.Program)
						result = convert (data);

					data = data.substr (0, found.index) + result + data.substr (begin);
					liteParser.update (data, -1);
				}
			}
		}

		/*data = data.replace (/@([a-z]+)/ig, function (s, n){
			console.log (n, macroses [n]);
			if (macroses [n])
				return macroses [n]();
			else
				return s;
		});*/

		console.log (data);
	}

	function simpleTransform (fileName){
		try var file = require ('fs').readFileSync (fileName);

		if (!file)
			console.fatal (2, 'Reading error');

		var parsed = Parser.parse (file, { information: true, fileName: require ('path').basename (args.data [0]) });

		var str = Generator.work (parsed, require ('path').basename (args.data [0]));
		try 
			console.log (require ('escodegen').generate (parsed));
		catch
			console.json (parsed);
	}

	function init (){
		// First and second args - "node" and script name
		args = parseArgs (process.argv.slice (2), [
				// s - short, l - long, p - parameter (1 - one, 2 - multiple)
				{ 	s: 'i', 	l: 'include', 	p: 2		},
				{ 	s: 'o', 	l: 'output',  	p: 1		},
				{   s: 'h',		l: 'usage'					}
			]);

		loadFile (args.data [0]);
		// simpleTransform (args.data [0]);
	}
}