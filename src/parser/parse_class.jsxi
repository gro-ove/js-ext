	function parseClassIdentifier ()
		return mark (parseVariableIdentifier ());

	function parseClassParams (){
		// Или класс, или интерфейс.
		// Возможно, реализованный.
		// Возможно, статический.
		// Возможно, публичный, приватный или защищённый.
		// Если класс, то, возможно, абстрактный.
		// Но в таком случае ни за что не статический.
		// Let's do it.

		var token, 
			result = { 
				publicMode: 		null, 
				abstract: 			false,
				implemented: 		false,
				static: 			false,
				interface: 			false
			};

		do {
			token = lookahead ();

			switch (token.value){
				case 'public':
				case 'private':
				case 'protected':
					if (result.publicMode !== null)
						throwUnexpected (token);

					lex ();
					result.publicMode = token.value;
					break;

				case 'abstract':
				case 'static':
					if (result.static || result.abstract)
						throwUnexpected (token);

				case 'implemented':
					if (result [token.value])
						throwUnexpected (token);

					lex ();
					result [token.value] = true;
					break;

				case 'interface':
					if (result.abstract)
						throwUnexpected (token);

					lex ();
					result.interface = token.value;
					return result;

				case 'class':
					lex ();
					return result;

				default:
					throwUnexpected (token);
			}
		} while (index < length);
	}

	function parseExtendsImplementsAndUses (mode){
		// Родительский класс  недоступен для интерфейсов и статических классов.
		// В интерфейсы, как и в «use», умеют все, даже статические классы.

		// Конечно, статический класс может имплементить лишь статические интер-
		// фейсы (в Java за такое ругают, но тут я главный и мне норм), а реали-
		// зованные могут использовать лишь другие реализованные,  но эти мелочи 
		// будут проверяться позже.

		function collect (list = []){
			do 
				list.push (parseClassIdentifier ());
			while (index < length && match (',') && lex ());
			return list;
		}

		// Интерфейс суть лишь особенный класс
		var token, result = { parent: null, implements: [], uses: [] };

		do {
			token = lookahead ();

			switch (token.value){
				case 'extends':
					if (result.parent || mode.interface || mode.static)
						throwUnexpected (token);

					lex ();
					result.parent = parseClassIdentifier ();
					break;

				case 'implements':
				case 'uses':
					lex ();
					collect (result [token.value]);
					break;

				default:
					return result;
			}
		} while (index < length);
	}

	function parseClassMembers (params, dependsOn){
		var oldInClass = state.inClass,
			token, 
			result = {}, 
			current;

		function refresh ()
			// Первый параметры можно переопределять, но остальные, если они уже
			// выставлены у всего класса, изменить уже не выйдет.
			current = { 
				publicMode: 		null, 
				abstract: 			params.abstract,
				static: 			params.static
			}

		function set (obj)
			if (result.hasOwnProperty (obj.id.name))
				throwError (token, 'Name "' + obj.id.name + '" is already used by an ' + (result [obj.id.name].type === Syntax.VariableDeclarator ? 'field' : 'method'));
			else
				result [obj.id.name] = $.extend (obj, current, { publicMode: current.publicMode || params.publicMode });

		function field (){
			if (matchKeyword ('var'))
				lex ();

			var token = lookahead (),
				data = parseVariableDeclarationList ();

			consumeSemicolon ();

			for (var entry in-array data){
				if (params.interface && !current.static)
					throwError (token, 'Interface couldn\'t have object fields.');

				if (params.implemented && entry.init)
					throwError (token, 'Implemented couldn\'t have initialized fields.');

				set (entry);
			}

			refresh ();
		}

		function method (){
			if (matchKeyword ('function'))
				lex ();

			state.superAvailable = !current.static;

			var token 		= lookahead (),
				id 			= parseVariableIdentifier (),
				defaults 	= [],
				args 		= match ('(') ? parseFunctionArguments (defaults) : [ identifier ('arg') ],
				body 		= null,
				fn;

			if (params.interface && !current.static || params.implemented){
				consumeSemicolon ();
			} else {
				body = parseFunctionSourceElements ();
				if (defaults.length)
					body.body = defaults.concat (body.body);
			}

			state.superAvailable = false;
			fn = functionDeclaration (id, args, body);
			set (fn);

			refresh ();
		}

		state.inClass = true;
		expect ('{');
		refresh ();

		do {
			token = lookahead ();

			if (token.value === '}')
				break;

			switch (token.value){
				case 'public':
				case 'private':
				case 'protected':
					if (current.publicMode !== null)
						throwUnexpected (token);

					lex ();
					current.publicMode = token.value;
					break;

				case 'abstract':
					if (params.interface)
						throwUnexpected (token);

				case 'static':
					if (current.abstract || current.static)
						throwUnexpected (token);

					lex ();
					current [token.value] = true;
					break;

				case 'var':
					field ();
					break;

				case 'function':
					method ();
					break;

				default:
					if (token.type === Token.Identifier){
						saved = saveAll ();

						try {
							field ();
						} catch {
							if (String (e).indexOf ('Unexpected token') !== -1){
								restoreAll (saved);
								method ();
							} else
								throw e;
						}

						break;
					}

					throwUnexpected (token);
					// throw new Error ('Token: "' + token.value + '", type: ' + token.type);
			}
		} while (index < length);

		expect ('}');

		state.inClass = oldInClass;
		return result;
	}

	function parseSuperExpression (){
		var level = 1, name, temp, arguments;

		expectKeyword ('super');

		if (!state.superAvailable)
			throwError ({}, 'Super can be used in class functions only');

		while (match ('.')){
			lex ();

			if (matchKeyword ('super')){
				level ++;
				lex ();
			} else {
				name = parseClassIdentifier ();
				break;
			}
		}

		arguments = parseArguments ();
		consumeSemicolon ();

		return superExpression (name, arguments, level);
	}

	function parseClassDeclaration (){
		// Получаем параметры класса, задаваемые ключевыми словами вроде «public», «abstract», «static» или «interface»
		var params = parseClassParams ();

		// А после — имя класса
		var id = parseClassIdentifier ();

		// Классы, от которых зависит текущий класс (родительские, интерфейсы и используемые)
		var dependsOn = parseExtendsImplementsAndUses (params);

		// Содержимое класса
		var members = parseClassMembers (params, dependsOn);

		// oldInClass 					= state.inClass;
		// state.inClass 				= true;

		// if (mode !== 'interface' && matchKeyword ('extends'))
		// 	parentClass 			= parseClassParent ();

		// if (matchKeyword ('implements'))
		// 	implementsInterfaces 	= parseInterfaces ();

		// expect ('{');

		// function reset ()
		// 	params = mode === 'static' ? { staticMode: true } : {};

		// reset ();

		// main: while (index < length){
		// 	if (match ('}'))
		// 		break;

		// 	token = lookahead ();

			

		// 	lex ();

		// 	var token = lookahead (),
		// 		temp = null;

		// 	if (token.type === Token.Keyword){
		// 		switch (token.value){
		// 			case 'use':
		// 				if (staticMode && !staticModeOnly || publicMode)
		// 					throwError ({}, Messages.WtfMan);
		// 				uses.push.apply (uses, parseUseStatement ());
		// 				continue;
		// 			case 'function':
		// 				if (!staticMode)
		// 					state.superAvailable = true;
		// 				temp = parseFunctionDeclaration ();
		// 				state.superAvailable = false;
		// 				break;
		// 			case 'var':
		// 				temp = parseVariableStatement ();
		// 				break;
		// 		}
		// 	} else if (token.type === Token.Punctuator && token.value === '(' || token.value === '{'){
		// 		var tempMark = mark ();
		// 		temp = token.value === '(' ? parseFunctionArguments () : [];

		// 		if (!staticMode)
		// 			state.superAvailable = true;

		// 		temp = setMark (functionExpression (null, temp, parseFunctionSourceElements ()), tempMark);
		// 		state.superAvailable = false;
		// 	}

		// 	if (!temp){
		// 		console.log (token, temp);
		// 		throwError (token, 'Class can contain variabled and functions only');
		// 	} else {
		// 		function add (temp)
		// 			members.push ($.extend (temp, { staticMode: !!staticMode, publicMode: publicMode || 'private' });

		// 		if (temp.type === Syntax.VariableDeclaration)
		// 			temp.declarations.forEach (add);
		// 		else 
		// 			add (temp);
		// 	}
		// }

		// expect ('}');

		var membersStrings = [], dependsOnStrings = [], beforeString = '';
		for (var key, member in members){
			var temp = [];

			for (var attribute, setted in member)
				if (setted === true)
					temp.push (attribute);

			if (member.publicMode)
				temp.push (member.publicMode);

			temp.push ({ FunctionDeclaration: 'method', VariableDeclarator: 'field' }[member.type] || member.type);
			membersStrings.push ('	* ' + member.id.name + ' (' + temp.join (' ') + ')');
		}

		if (dependsOn.parent)
			dependsOnStrings.push ('child of ' + dependsOn.parent.name);

		if (dependsOn.implements.length)
			dependsOnStrings.push ('implements ' + dependsOn.implements.map (lambda arg.name).join (', '));

		if (dependsOn.uses.length)
			dependsOnStrings.push ('using ' + dependsOn.uses.map (lambda arg.name).join (', '));

		if (dependsOnStrings.length)
			beforeString = ' (' + dependsOnStrings.join ('; ') + ')';

		console.log (id.name + beforeString + ':\n' + membersStrings.join ('\n'));

		// state.classes.push ({
		// 	classObject: 	true,
		// 	id: 			id,
		// 	parent: 		parent || null,
		// 	uses: 			uses,
		// 	members: 		members
		// });

		return null;
	}