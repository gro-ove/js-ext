function parseClassParams (){
	/*
		Класс или интерфейс. Возможно, статический; возможно, публичный, приватный или защищённый. Класс может быть абс-
		трактным, но в таком случае не может быть статическим.
	*/

	var token, 
		result = { 
			publicMode: 		null, 
			abstract: 			false,
			static: 			false,
			interface: 			false,
			partial: 			false
		};

	loop: do {
		token = lex ();

		switch (token.value){
			case 'public':
			case 'private':
			case 'protected':
				if (result.publicMode !== null)
					unexpected (token);
				result.publicMode = token.value;
				break;

			case 'partial':
				if (result.partial)
					unexpected (token);
				result.partial = true;
				break;

			case 'abstract':
			case 'static':
				if (result.static || result.abstract)
					unexpected (token);
				result [token.value] = true;
				break;

			case 'interface':
				if (result.abstract)
					unexpected (token);
				result.interface = token.value;

			case 'class':
				break loop;

			default:
				unexpected (token);
		}
	} while (index < length);

	if (result.publicMode === null)
		result.publicMode = 'private';

	return result;
}

function parseExtendsImplementsAndUses (mode){
	// Родительский класс не для интерфейсов и статических классов. Имплементить интерфейсы и использовать «uses», умеют
	// все, даже статические классы (но статические могут имплементить лишь статические).

	function collect (list = []){
		do 
			list.push (parseIdentifier ());
		while (index < length && matchLex (','));
		return list;
	}

	var result = { parent: null, implements: [], uses: [] };

	while (!match ('{')){
		if (!result.parent && !mode.interface && !mode.static && matchKeywordLex ('extends')){
			helpers.set ('prototypeExtend');
			result.parent = parseIdentifier ();
		} else if (matchKeywordLex ('implements')){
			collect (result.implements);
		} else if (matchKeywordLex ('uses')){
			collect (result.uses);
		} else
			unexpected ();
	}

	return result;
}

function parseClassMembers (params, dependsOn, result = {}){
	var oldInClass = state.inClass,
		token, 
		current;

	function refresh ()
		current = { publicMode: null, static: params.static };

	function set (obj){
		// TODO:
		console.assert (!((result.hasOwnProperty (obj.id.name) ? result [obj.id.name] : null) instanceof Array), 'ARRAY!');

		if (result.hasOwnProperty (obj.id.name))
			throw new SyntaxError ('Member "' + obj.id.name + '" already declared', token);

		obj.publicMode = current.publicMode || params.publicMode;
		obj.static = current.static;
		obj.abstract = current.abstract;

		result [obj.id.name] = obj;
	}

	function parseField (){
		if (params.interface && !current.static)
			throw new TypeError ('Interface cannot have object fields');

		if (current.abstract && (current.publicMode || params.publicMode) === 'private')
			throw new TypeError ('Abstract member cannot be private');

		for (var entry in-array parseVariableDeclarators ())
			set (entry);
		refresh ();
	}

	function parseMethod (){
		if (current.abstract && (current.publicMode || params.publicMode) === 'private')
			throw new TypeError ('Abstract member cannot be private');

		state.superAvailable = !current.static && dependsOn.parent;

		var empty = params.interface && !current.static || current.abstract,
			result = parseFunction ({ keyword: null, empty: empty });

		set (result);
		state.superAvailable = false;
		refresh ();
	}

	function parseInitializerOrConstructor (){
		if (current.publicMode)
			throw new TypeError ('Constructor or initializer cannot have overrided visibility');

		if (current.abstract)
			throw new TypeError ('Constructor or initializer cannot be abstract');

		state.superAvailable = !current.static && dependsOn.parent;
		state.noReturn = true;

		var result = parseFunction ({ keyword: null, id: false, optionalParams: true });
		result.id = identifier (current.static ? '@initializer' : '@constructor');

		state.superAvailable = false;
		state.noReturn = false;

		set (result);
		refresh ();
	}

	state.inClass = true;
	expect ('{');
	refresh ();

	while (!match ('}')){
		token = lookahead ();

		switch (token.value){
			case 'private':
			case 'public':
			case 'protected':
				if (current.publicMode !== null)
					unexpected (token);
				lex ();
				current.publicMode = token.value;
				break;

			case 'abstract':
				if (params.interface)
					unexpected (token);

			case 'static':
				if (current.abstract || current.static)
					unexpected (token);
				lex ();
				current [token.value] = true;
				break;

			case 'var':
				lex ();
				parseField ();
				break;

			case 'function':
				lex ();
				parseMethod ();
				break;

			case '(':
			case '{':
				parseInitializerOrConstructor ();
				break;

			default:
				if (token.type === Token.Identifier){
					var saved = saveAll (),
						method;

					lex ();
					method = match ('(');
					restoreAll (saved);

					if (method)
						parseMethod ();
					else 
						parseField ();
				} else
					unexpected (token);
		}
	}

	expect ('}');

	state.inClass = oldInClass;
	return result;
}

function verbose (id, params, dependsOn, members){
	var membersStrings = [], dependsOnStrings = [], beforeString = '';
	for (var key, member in members){
		var temp = [];

		if (member instanceof Array){
			member = member [0];
			if (!member)
				continue;
		}

		for (var attribute, setted in member)
			if (setted === true)
				temp.push (attribute);

		if (member.publicMode)
			temp.push (member.publicMode);

		temp.push ({ FunctionExpression: 'method', VariableDeclarator: 'field' }[member.type] || '<something wrong: ' + member.type + '>');

		if (members [key] instanceof Array)
			temp.push (', total count: ' + members [key].length);

		membersStrings.push ('	* ' + member.id.name + ' (' + temp.join (' ').replace (/ ,/g, ',') + ')');
	}

	var paramsString = [];
	for (var attribute, setted in params)
		if (setted === true)
			paramsString.push (attribute);

	if (params.publicMode)
		paramsString.push (params.publicMode);

	if (paramsString.length)
		dependsOnStrings.push (paramsString.join (' '));

	if (dependsOn.parent)
		dependsOnStrings.push ('child of ' + dependsOn.parent.name);

	if (dependsOn.implements.length)
		dependsOnStrings.push ('implements ' + dependsOn.implements.map (lambda arg.name).join (', '));

	if (dependsOn.uses.length)
		dependsOnStrings.push ('using ' + dependsOn.uses.map (lambda arg.name).join (', '));

	if (dependsOnStrings.length)
		beforeString = ' (' + dependsOnStrings.join ('; ') + ')';

	console.info (id.name + beforeString + ':\n' + membersStrings.join ('\n'));
}

function parseClassDeclaration (){
	// Получаем параметры класса, задаваемые ключевыми словами вроде «public», «abstract», «static» или «interface»
	var params = parseClassParams ();

	// А после — имя класса
	var id = parseIdentifier ();

	// Классы, от которых зависит текущий класс (родительские, интерфейсы и используемые)
	var dependsOn = parseExtendsImplementsAndUses (params);

	// Кусок класса
	var previous = state.classes.filter (lambda arg.id.name === id.name)[0];

	if (previous){
		if (!params.partial)
			throw new TypeError ('Class "' + id.name + '" already declared', id);
		else if (JSON.stringify (params) !== JSON.stringify (previous.params))
			throw new TypeError ('Different class params', id);
		else if (JSON.stringify (dependsOn.parent) !== JSON.stringify (previous.dependsOn.parent))
			throw new TypeError ('Different "extends" param', id);
		else if (JSON.stringify (dependsOn.implements) !== JSON.stringify (previous.dependsOn.implements))
			throw new TypeError ('Different "implements" param', id);

		for (var temp in-array dependsOn.uses)
			if (previous.dependsOn.uses.indexOf (temp) === -1)
				previous.dependsOn.uses.push (temp);
	}

	// Содержимое класса
	var members = parseClassMembers (params, dependsOn, previous ? previous.members : {});

	// Выводим распарсенное в консоль
	// verbose (id, params, dependsOn, members);

	// Записываем новый класс
	if (!previous){
		var placeholder = expressionStatement (stringLiteralWithQuotes ('class "' + id.name + '"'));

		state.classes.push ({
			id: 			id,
			params: 		params,
			dependsOn: 		dependsOn,
			members: 		members,
			placeholder: 	placeholder
		});

		return placeholder;
	} else
		return expressionStatement (stringLiteralWithQuotes ('not implemented'));
}