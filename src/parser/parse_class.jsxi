function parseClassParams (){
	/*
		Класс или интерфейс. Возможно, статический; возможно, публичный, приватный или защищённый. Класс может быть абс-
		трактным, но в таком случае не может быть статическим.
	*/

	var token, 
		result = { 
			publicMode: 		null, 
			abstract: 			false,
			static: 			false,
			interface: 			false,
			partial: 			false
		};

	do {
		token = lex ();

		switch (token.value){
			case 'public':
			case 'private':
			case 'protected':
				if (result.publicMode !== null)
					unexpected (token);
				result.publicMode = token.value;
				break;

			case 'partial':
				if (result.partial)
					unexpected (token);
				result.partial = true;
				break;

			case 'abstract':
			case 'static':
				if (result.static || result.abstract)
					unexpected (token);
				result [token.value] = true;
				break;

			case 'interface':
				if (result.abstract)
					unexpected (token);
				result.interface = token.value;
				return result;

			case 'class':
				return result;

			default:
				unexpected (token);
		}
	} while (index < length);
}

function parseExtendsImplementsAndUses (mode){
	// Родительский класс не для интерфейсов и статических классов. Имплементить интерфейсы и использовать «uses», умеют
	// все, даже статические классы (но статические могут имплементить лишь статические).

	function collect (list = []){
		do 
			list.push (parseIdentifier ());
		while (index < length && matchLex (','));
		return list;
	}

	// Интерфейс суть лишь особенный класс
	var token, result = { parent: null, implements: [], uses: [] };

	do {
		token = lookahead ();

		switch (token.value){
			case 'extends':
				if (result.parent || mode.interface || mode.static)
					unexpected (token);

				lex ();
				result.parent = parseIdentifier ();
				helpers.set ('prototypeExtend', token);
				break;

			case 'implements':
			case 'uses':
				lex ();
				collect (result [token.value]);
				break;

			default:
				return result;
		}
	} while (index < length);
}

function parseClassMembers (params, dependsOn, result = {}){
	var oldInClass = state.inClass,
		token, 
		current;

	function refresh ()
		// Параметр «publicMode» можно переопределить
		current = { 
			publicMode: 		null,
			static: 			params.static
		}

	function set (obj){
		var name = obj.id.name,
			has = result.hasOwnProperty (name),
			temp = has ? result [name] : null;

		$.extend (obj, current, { publicMode: current.publicMode || params.publicMode });

		if (temp instanceof Array){
			temp.push (obj);
		} else if (has){
			throw new SyntaxError ('Member "' + name + '" already declared', token);
		} else
			result [name] = obj;
	}

	function parseField (){
		if (params.interface && !current.static)
			throw new TypeError ('Interface couldn\'t have object fields.');

		if (current.abstract)
			throw new TypeError ('Field could\'t be abstract.');

		for (var entry in-array parseVariableDeclarators ())
			set (entry);
		refresh ();
	}

	function parseMethod (){
		if (current.publicMode === 'private' && current.abstract)
			throw new TypeError ('Private method couldn\'t be abstract.');

		state.superAvailable = !current.static && dependsOn.parent;

		var empty = params.interface && !current.static || current.abstract,
			result = parseFunction ({ keyword: null, empty: empty });

		set (result);
		state.superAvailable = false;
		refresh ();
	}

	function parseInitializerOrConstructor (){
		if (current.publicMode)
			throw new TypeError ('Constructor or initializer couldn\'t be ' + current.publicMode);

		if (current.abstract)
			throw new TypeError ('Constructor or initializer couldn\'t be abstract');

		state.superAvailable = !current.static && dependsOn.parent;
		state.noReturn = true;

		var result = parseFunction ({ keyword: null, id: false, optionalParams: true });

		result.id = identifier (current.static ? '@initializer' : '@constructor');
		set (result);
		refresh ();

		state.superAvailable = false;
		state.noReturn = false;
	}

	state.inClass = true;
	expect ('{');
	refresh ();

	loop: do {
		token = lookahead ();

		switch (token.value){
			case 'private':
				if (current.abstract)
					unexpected (token);

			case 'public':
			case 'protected':
				if (current.publicMode !== null)
					unexpected (token);

				lex ();
				current.publicMode = token.value;
				break;

			case 'abstract':
				if (params.interface || current.publicMode === 'private')
					unexpected (token);

			case 'static':
				if (current.abstract || current.static)
					unexpected (token);

				lex ();
				current [token.value] = true;
				break;

			case 'var':
				lex ();
				parseField ();
				break;

			case 'function':
				lex ();
				parseMethod ();
				break;

			case '(':
			case '{':
				parseInitializerOrConstructor ();
				break;

			case '}':
				break loop;

			default:
				if (token.type === Token.Identifier){
					var saved = saveAll (),
						method;

					lex ();
					method = match ('(');
					restoreAll (saved);

					if (method)
						parseMethod ();
					else 
						parseField ();
				} else
					unexpected (token);
		}
	} while (index < length);

	expect ('}');

	state.inClass = oldInClass;
	return result;
}

function verbose (id, params, dependsOn, members){
	var membersStrings = [], dependsOnStrings = [], beforeString = '';
	for (var key, member in members){
		var temp = [];

		if (member instanceof Array){
			member = member [0];
			if (!member)
				continue;
		}

		for (var attribute, setted in member)
			if (setted === true)
				temp.push (attribute);

		if (member.publicMode)
			temp.push (member.publicMode);

		temp.push ({ FunctionExpression: 'method', VariableDeclarator: 'field' }[member.type] || '<something wrong: ' + member.type + '>');

		if (members [key] instanceof Array)
			temp.push (', total count: ' + members [key].length);

		membersStrings.push ('	* ' + member.id.name + ' (' + temp.join (' ').replace (/ ,/g, ',') + ')');
	}

	var paramsString = [];
	for (var attribute, setted in params)
		if (setted === true)
			paramsString.push (attribute);

	if (params.publicMode)
		paramsString.push (params.publicMode);

	if (paramsString.length)
		dependsOnStrings.push (paramsString.join (' '));

	if (dependsOn.parent)
		dependsOnStrings.push ('child of ' + dependsOn.parent.name);

	if (dependsOn.implements.length)
		dependsOnStrings.push ('implements ' + dependsOn.implements.map (lambda arg.name).join (', '));

	if (dependsOn.uses.length)
		dependsOnStrings.push ('using ' + dependsOn.uses.map (lambda arg.name).join (', '));

	if (dependsOnStrings.length)
		beforeString = ' (' + dependsOnStrings.join ('; ') + ')';

	console.info (id.name + beforeString + ':\n' + membersStrings.join ('\n'));
}

function parseClassDeclaration (){
	// Получаем параметры класса, задаваемые ключевыми словами вроде «public», «abstract», «static» или «interface»
	var params = parseClassParams ();

	// А после — имя класса
	var id = parseIdentifier ();

	// Классы, от которых зависит текущий класс (родительские, интерфейсы и используемые)
	var dependsOn = parseExtendsImplementsAndUses (params);

	// Кусок класса
	var previous = state.classes.filter (lambda arg.id.name === id.name)[0];

	if (previous){
		if (!params.partial)
			throw new TypeError ('Class "' + id.name + '" already declared', id);
		else if (JSON.stringify (params) !== JSON.stringify (previous.params))
			throw new TypeError ('Different class params', id);
		else if (JSON.stringify (dependsOn.parent) !== JSON.stringify (previous.dependsOn.parent))
			throw new TypeError ('Different "extends" param', id);
		else if (JSON.stringify (dependsOn.implements) !== JSON.stringify (previous.dependsOn.implements))
			throw new TypeError ('Different "implements" param', id);

		for (var temp in-array dependsOn.uses)
			if (previous.dependsOn.uses.indexOf (temp) === -1)
				previous.dependsOn.uses.push (temp);
	}

	// Содержимое класса
	var members = parseClassMembers (params, dependsOn, previous ? previous.members : {});

	// Выводим распарсенное в консоль
	verbose (id, params, dependsOn, members);

	// Записываем новый класс
	if (!previous)
		state.classes.push ({
			id: 			id,
			params: 		params,
			dependsOn: 		dependsOn,
			members: 		members
		});

	return null;
}