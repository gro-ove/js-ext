	function parseModuleSourceElements (){
		var sourceElement,
			usedClasses = [],
			variableDeclarations = [],
			functionDeclarations = [];

		expect ('{');

		while (index < length){
			if (match ('}'))
				break;

			var token = lookahead ();

			if (token.type === Token.Keyword)
				switch (token.value){
					case 'function':
						functionDeclarations.push (parseFunctionDeclaration ());
						continue;
					case 'var':
						variableDeclarations.push (parseStatement ());
						continue;
				}

			throwError ({}, 'Module can contain variabled and functions only');
		}

		expect ('}');

		return {
			type: 	Syntax.BlockStatement,
			body: 	variableDeclarations.concat (functionDeclarations)
		};
	}

	function parseUseStatement (){
		var list = [];

		expectKeyword ('use');

		do {
			list.push (parseVariableIdentifier ());
			if (!match (','))
				break;
			lex ();
		} while (index < length);

		consumeSemicolon ();

		return list;
	}

	function parseClassDeclaration (){
		var id, 
			parent,
			token,
			temp,
			staticMode,
			publicMode,
			usedClasses = [],
			variableDeclarations = [],
			functionDeclarations = [];

		expectKeyword ('class');

		id = parseVariableIdentifier ();

		if (matchKeyword ('extends')){
			lex ();
			parent = parseVariableIdentifier ();
		}

		expect ('{');

		while (index < length){
			if (match ('}'))
				break;

			publicMode = undefined;
			staticMode = false;

			if (matchKeyword ('static')){
				staticMode = true;
				lex ();
			}

			if (matchKeyword ('public'))
				publicMode = 'public';
			else if (matchKeyword ('protected'))
				publicMode = 'protected';
			else if (matchKeyword ('private'))
				publicMode = 'private';

			if (publicMode)
				lex ();

			if (!staticMode && matchKeyword ('static')){
				staticMode = true;
				lex ();
			}

			if (staticMode && publicMode === 'protected')
				throwError ({}, Messages.WtfMan);

			token = lookahead ();
			temp = null;

			if (token.type === Token.Keyword){
				switch (token.value){
					case 'use':
						if (staticMode || publicMode)
							throwError ({}, Messages.WtfMan);
						temp = true;
						usedClasses = usedClasses.concat (parseUseStatement ());
						continue;
					case 'function':
						if (!staticMode)
							state.superAvailable = true;
						temp = parseFunctionDeclaration ();
						state.superAvailable = false;

						functionDeclarations.push (temp);
						break;
					case 'var':
						temp = parseVariableStatement ();
						variableDeclarations.push (temp);
						break;
				}
			} else if (token.type === Token.Punctuator && token.value === '(' || token.value === '{'){
				temp = token.value === '(' ? parseFunctionArguments () : [];

				if (!staticMode)
					state.superAvailable = true;

				temp = functionExpression ('@', temp, parseFunctionSourceElements ());

				state.superAvailable = false;
				functionDeclarations.push (temp);
			}

			if (temp){
				temp.staticMode = !!staticMode;
				temp.publicMode = publicMode || 'private';
			} else {
				console.log (token, temp);
				throwError ({}, 'Class can contain variabled and functions only');
			}
		}

		expect ('}');

		var result = variableDeclaration ([
			variableDeclarator (id.name, undefined)
		]);

		addClass (
			id.name, 
			parent ? parent.name : null,
			usedClasses.map (lambda arg.name), 
			variableDeclarations,
			functionDeclarations,
			result.declarations [0]);

		return result;
	}

	function parseSuperStatement (){
		var level = 1, name, arguments;

		expectKeyword ('super');

		if (!state.superAvailable)
			throwError ({}, 'Super can be used in class functions only');

		while (match ('.')){
			lex ();

			if (matchKeyword ('super')){
				level ++;
				lex ();
			} else {
				name = parseVariableIdentifier ();
				break;
			}
		}

		arguments = parseArguments ();
		consumeSemicolon ();

		return {
			type: 'ExpressionStatement',
			expression: {
				type: 'CallExpression',
				callee: name || null,
				arguments: arguments,
				'super': level
			}
		}
	}