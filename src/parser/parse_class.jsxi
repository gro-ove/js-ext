	function parseModuleSourceElements (){
		var sourceElement,
			usedClasses = [],
			variableDeclarations = [],
			functionDeclarations = [];

		expect ('{');

		while (index < length){
			if (match ('}'))
				break;

			var token = lookahead ();

			if (token.type === Token.Keyword)
				switch (token.value){
					case 'function':
						functionDeclarations.push (parseFunctionDeclaration ());
						continue;
					case 'var':
						variableDeclarations.push (parseStatement ());
						continue;
				}

			throwError ({}, 'Module can contain variabled and functions only');
		}

		expect ('}');

		return {
			type: 	Syntax.BlockStatement,
			body: 	variableDeclarations.concat (functionDeclarations)
		};
	}

	function parseUseStatement (){
		var list = [];

		expectKeyword ('use');

		do {
			list.push (parseVariableIdentifier ());
			if (!match (','))
				break;
			lex ();
		} while (index < length);

		consumeSemicolon ();

		return list;
	}

	function parseClassDeclaration (){
		var id, 
			parent,
			token,
			temp,
			tempMark,
			staticMode,
			staticModeOnly,
			publicMode,
			uses = [],
			members = [],
			oldInClass;

		if (matchKeyword ('static')){
			lex ();
			staticModeOnly = true;
		}

		expectKeyword ('class');

		id = mark (parseVariableIdentifier ());

		if (matchKeyword ('extends')){
			lex ();
			parent = mark (parseVariableIdentifier ());
		}

		expect ('{');

		oldInClass = state.inClass;
		state.inClass = true;

		while (index < length){
			if (match ('}'))
				break;

			publicMode = undefined;
			staticMode = staticModeOnly || false;

			if (matchKeyword ('static')){
				staticMode = true;
				lex ();
			}

			if (matchKeyword ('public'))
				publicMode = 'public';
			else if (matchKeyword ('protected'))
				publicMode = 'protected';
			else if (matchKeyword ('private'))
				publicMode = 'private';

			if (publicMode)
				lex ();

			if (!staticMode && matchKeyword ('static')){
				staticMode = true;
				lex ();
			}

			token = lookahead ();
			temp = null;

			if (token.type === Token.Keyword){
				switch (token.value){
					case 'use':
						if (staticMode && !staticModeOnly || publicMode)
							throwError ({}, Messages.WtfMan);
						uses.push.apply (uses, parseUseStatement ());
						continue;
					case 'function':
						if (!staticMode)
							state.superAvailable = true;
						temp = parseFunctionDeclaration ();
						state.superAvailable = false;
						break;
					case 'var':
						temp = parseVariableStatement ();
						break;
				}
			} else if (token.type === Token.Punctuator && token.value === '(' || token.value === '{'){
				tempMark = mark ();
				temp = token.value === '(' ? parseFunctionArguments () : [];

				if (!staticMode)
					state.superAvailable = true;

				temp = setMark (functionExpression (null, temp, parseFunctionSourceElements ()), tempMark);
				state.superAvailable = false;
			}

			if (!temp){
				console.log (token, temp);
				throwError ({}, 'Class can contain variabled and functions only');
			} else {
				function add (member){
					member.staticMode = !!staticMode;
					member.publicMode = publicMode || 'private';
					members.push (member);
				}

				if (temp.type === Syntax.VariableDeclaration)
					temp.declarations.forEach (add);
				else 
					add (temp);
			}
		}

		expect ('}');

		state.classes.push ({
			classObject: 	true,
			id: 			id,
			parent: 		parent || null,
			uses: 			uses,
			members: 		members
		});
		
		state.inClass = oldInClass;

		return null;
	}

	function parseSuperStatement (){
		var level = 1, name, temp, arguments;

		expectKeyword ('super');

		if (!state.superAvailable)
			throwError ({}, 'Super can be used in class functions only');

		while (match ('.')){
			lex ();

			if (matchKeyword ('super')){
				level ++;
				lex ();
			} else {
				name = parseVariableIdentifier ();
				break;
			}
		}

		arguments = parseArguments ();
		consumeSemicolon ();

		return expressionStatement (superExpression (name, arguments, level));
	}