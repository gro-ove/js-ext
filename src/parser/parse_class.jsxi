	function parseModuleSourceElements (){
		var sourceElement,
			usedClasses = [],
			variableDeclarations = [],
			functionDeclarations = [];

		expect ('{');

		while (index < length){
			if (match ('}'))
				break;

			var token = lookahead ();

			if (token.type === Token.Keyword)
				switch (token.value){
					case 'function':
						functionDeclarations.push (parseFunctionDeclaration ());
						continue;
					case 'var':
						variableDeclarations.push (parseStatement ());
						continue;
				}

			throwError ({}, 'Module can contain variabled and functions only');
		}

		expect ('}');

		return {
			type: 	Syntax.BlockStatement,
			body: 	variableDeclarations.concat (functionDeclarations)
		};
	}

	function parseUseStatement (){
		var list = [];

		expectKeyword ('use');

		do {
			list.push (parseVariableIdentifier ());
			if (!match (','))
				break;
			lex ();
		} while (index < length);

		consumeSemicolon ();

		return list;
	}

	function parseClassDeclaration (){
		var id, 
			parent,
			token,
			temp,
			staticMode,
			staticModeOnly,
			publicMode,
			usedClasses = [],
			variableDeclarations = [],
			functionDeclarations = [],
			oldInClass;

		if (matchKeyword ('static')){
			lex ();
			staticModeOnly = true;
		}

		expectKeyword ('class');

		id = mark (parseVariableIdentifier ());

		if (matchKeyword ('extends')){
			lex ();
			parent = mark (parseVariableIdentifier ());
		}

		expect ('{');

		oldInClass = state.inClass;
		state.inClass = true;

		while (index < length){
			if (match ('}'))
				break;

			publicMode = undefined;
			staticMode = staticModeOnly || false;

			if (matchKeyword ('static')){
				staticMode = true;
				lex ();
			}

			if (matchKeyword ('public'))
				publicMode = 'public';
			else if (matchKeyword ('protected'))
				publicMode = 'protected';
			else if (matchKeyword ('private'))
				publicMode = 'private';

			if (publicMode)
				lex ();

			if (!staticMode && matchKeyword ('static')){
				staticMode = true;
				lex ();
			}

			token = lookahead ();
			temp = null;

			if (token.type === Token.Keyword){
				switch (token.value){
					case 'use':
						if (staticMode && !staticModeOnly || publicMode)
							throwError ({}, Messages.WtfMan);
						temp = true;
						usedClasses = usedClasses.concat (parseUseStatement ());
						continue;
					case 'function':
						if (!staticMode)
							state.superAvailable = true;
						temp = parseFunctionDeclaration ();
						state.superAvailable = false;

						functionDeclarations.push (temp);
						break;
					case 'var':
						temp = parseVariableStatement ();
						variableDeclarations.push (temp);
						break;
				}
			} else if (token.type === Token.Punctuator && token.value === '(' || token.value === '{'){
				temp = token.value === '(' ? parseFunctionArguments () : [];

				if (!staticMode)
					state.superAvailable = true;

				temp = functionExpression ('@', temp, parseFunctionSourceElements ());

				state.superAvailable = false;
				functionDeclarations.push (temp);
			}

			if (temp){
				temp.staticMode = !!staticMode;
				temp.publicMode = publicMode || 'private';
			} else {
				console.log (token, temp);
				throwError ({}, 'Class can contain variabled and functions only');
			}
		}

		expect ('}');

		addClass (
			id, 
			parent || null,
			usedClasses, 
			variableDeclarations,
			functionDeclarations);
		
		state.inClass = oldInClass;

		return null;
	}

	function parseSuperStatement (){
		var level = 1, name, temp, arguments;

		expectKeyword ('super');

		if (!state.superAvailable)
			throwError ({}, 'Super can be used in class functions only');

		while (match ('.')){
			lex ();

			if (matchKeyword ('super')){
				level ++;
				lex ();
			} else {
				name = parseVariableIdentifier ();
				break;
			}
		}

		arguments = parseArguments ();
		consumeSemicolon ();

		temp = callExpression (name || null, arguments);
		temp ['super'] = level;

		return expressionStatement (temp);
	}