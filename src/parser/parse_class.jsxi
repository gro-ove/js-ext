	function createClass (name, usedClasses, variableDeclarations, functionDeclarations){
		var moduleFnName = '__m';

		var independVariableDeclarations = {
			type: 'VariableDeclaration',
			declarations: [],
			kind: 'var'
		};

		variableDeclarations.forEach (
			lambda arg.declarations.forEach (
				lambda independVariableDeclarations.declarations.push (
					!arg.init || arg.init.type === 'Literal'
						? arg
						: {
							type: 	'VariableDeclarator',
							id: 	arg.id
						}
				)
			)
		);

		return {
            type: 'ExpressionStatement',
            expression: {
                type: 'CallExpression',
                callee: {
                    type: 'Identifier',
                    name: moduleFnName
                },
                arguments: [
                    {
                        type: 'Literal',
                        value: name
                    },
                    {
                        type: 'FunctionExpression',
                        id: null,
                        params: [],
                        defaults: [],
                        body: {
                            type: 'BlockStatement',
                            body: [
                            	independVariableDeclarations
                            ].concat (functionDeclarations)

                               /* {
                                    type: VariableDeclaration,
                                    declarations: [
                                        {
                                            type: VariableDeclarator,
                                            id: {
                                                type: Identifier,
                                                name: a
                                            },
                                            init: {
                                                type: Literal,
                                                value: 18
                                            }
                                        },
                                        {
                                            type: VariableDeclarator,
                                            id: {
                                                type: Identifier,
                                                name: b
                                            },
                                            init: null
                                        }
                                    ],
                                    kind: var
                                },
                                {
                                    type: FunctionDeclaration,
                                    id: {
                                        type: Identifier,
                                        name: init
                                    },
                                    params: [],
                                    defaults: [],
                                    body: {
                                        type: BlockStatement,
                                        body: []
                                    },
                                    rest: null,
                                    generator: false,
                                    expression: false
                                },
                                {
                                    type: ReturnStatement,
                                    argument: {
                                        type: ObjectExpression,
                                        properties: [
                                            {
                                                type: Property,
                                                key: {
                                                    type: Identifier,
                                                    name: __s
                                                },
                                                value: {
                                                    type: FunctionExpression,
                                                    id: null,
                                                    params: [],
                                                    defaults: [],
                                                    body: {
                                                        type: BlockStatement,
                                                        body: [
                                                            {
                                                                type: ExpressionStatement,
                                                                expression: {
                                                                    type: AssignmentExpression,
                                                                    operator:=,
                                                                    left: {
                                                                        type:Identifier,
                                                                        name:b
                                                                    },
                                                                    right: {
                                                                        type: MemberExpression,
                                                                        computed: false,
                                                                        object: {
                                                                            type: Identifier,
                                                                            name: B
                                                                        },
                                                                        property: {
                                                                            type: Identifier,
                                                                            name: variable
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        ]
                                                    },
                                                    rest: null,
                                                    generator: false,
                                                    expression: false
                                                },
                                                kind: init
                                            },
                                            {
                                                type: Property,
                                                key: {
                                                    type: Identifier,
                                                    name: __i
                                                },
                                                value: {
                                                    type: Identifier,
                                                    name: init
                                                },
                                                kind: init
                                            }
                                        ]
                                    }
                                }*/
                        },
                        rest: null,
                        generator: false,
                        expression: false
                    }
                ]
            }
        };
	}

	function parseModuleSourceElements (){
		var sourceElement,
			usedModules = [],
			variableDeclarations = [],
			functionDeclarations = [];

		expect ('{');

		while (index < length){
			if (match ('}'))
				break;

			var token = lookahead ();

			if (token.type === Token.Keyword)
				switch (token.value){
					case 'function':
						functionDeclarations.push (parseFunctionDeclaration ());
						continue;
					case 'var':
						variableDeclarations.push (parseStatement ());
						continue;
				}

			throwError ({}, 'Module can contain variabled and functions only');
		}

		expect ('}');

		return {
			type: 	Syntax.BlockStatement,
			body: 	variableDeclarations.concat (functionDeclarations)
		};
	}

	function parseUseStatement (){
		var list = [];

		expectKeyword ('use');

		do {
			list.push (parseVariableIdentifier ());
			if (!match (','))
				break;
			lex ();
		} while (index < length);

		consumeSemicolon ();

		return list;
	}

	function parseClassDeclaration (){
		var id, 
			token,
			temp,
			staticMode,
			publicMode,
			usedClasses = [],
			variableDeclarations = [],
			functionDeclarations = [];

		expectKeyword ('class');

		id = parseVariableIdentifier ();

		expect ('{');

		while (index < length){
			if (match ('}'))
				break;

			publicMode = undefined;
			staticMode = false;

			if (matchKeyword ('static')){
				staticMode = true;
				lex ();
			}

			if (matchKeyword ('public')){
				publicMode = 'public';
				lex ();
			}

			if (matchKeyword ('protected')){
				if (publicMode)
					throwError ({}, 'WTF MAN?');
				publicMode = 'protected';
				lex ();
			}

			if (matchKeyword ('private')){
				if (publicMode)
					throwError ({}, 'WTF MAN?');
				publicMode = 'private';
				lex ();
			}

			if (matchKeyword ('static')){
				if (staticMode)
					throwError ({}, 'WTF MAN?');
				staticMode = true;
				lex ();
			}

			token = lookahead ();
			temp = null;

			if (token.type === Token.Keyword){
				switch (token.value){
					case 'use':
						if (staticMode || publicMode)
							throwError ({}, 'WTF MAN?');
						temp = true;
						usedClasses = usedClasses.concat (parseUseStatement ());
						continue;
					case 'function':
						temp = parseFunctionDeclaration ();
						functionDeclarations.push (temp);

						// TODO
						// if (temp.id === 'constructor')
						break;
					case 'var':
						temp = parseVariableStatement ();
						variableDeclarations.push (temp);

						// TODO
						// if (temp.id === 'constructor')
						break;
				}
			} else if (token.type === Token.Punctuator){
				if (token.value === '{'){
					temp = {
						type: 			Syntax.FunctionExpression,
						id: 			'constructor',
						params: 		[],
						defaults: 		[],
						body: 			parseFunctionSourceElements (),
						rest: 			null,
						generator: 		false,
						expression: 	false
					};

					functionDeclarations.push (temp);
				} else if (token.value === '('){
					temp = parseFunctionArguments ();

					temp = {
						type: 			Syntax.FunctionExpression,
						id: 			'constructor',
						params: 		temp,
						defaults: 		[],
						body: 			parseFunctionSourceElements (),
						rest: 			null,
						generator: 		false,
						expression: 	false
					};
					
					functionDeclarations.push (temp);
				}
			}

			if (temp){
				temp.staticMode = staticMode;
				temp.publicMode = publicMode;
			} else {
				console.log (token, temp);
				throwError ({}, 'Class can contain variabled and functions only');
			}
		}

		expect ('}');

		return createClass (id.name, usedClasses, variableDeclarations, functionDeclarations);
	}