	function parseClassIdentifier ()
		return mark (parseVariableIdentifier ());

	function parseClassParams (){
		// Или класс, или интерфейс.
		// Возможно, реализованный.
		// Возможно, статический.
		// Возможно, публичный, приватный или защищённый.
		// Если класс, то, возможно, абстрактный.
		// Но в таком случае ни за что не статический.
		// Let's do it.

		var token, 
			result = { 
				publicMode: 		null, 
				abstract: 			false,
				implemented: 		false,
				static: 			false,
				interface: 			false
			};

		do {
			token = lookahead ();

			switch (token.value){
				case 'public':
				case 'private':
				case 'protected':
					if (result.publicMode !== null)
						throwUnexpected (token);

					lex ();
					result.publicMode = token.value;
					break;

				case 'abstract':
				case 'static':
					if (result.static || result.abstract)
						throwUnexpected (token);

				case 'implemented':
					if (result [token.value])
						throwUnexpected (token);

					lex ();
					result [token.value] = true;
					break;

				case 'interface':
					if (result.abstract)
						throwUnexpected (token);

					lex ();
					result.interface = token.value;
					return result;

				case 'class':
					lex ();
					return result;

				default:
					throwUnexpected (token);
			}
		} while (index < length);
	}

	function parseExtendsImplementsAndUses (mode){
		// Родительский класс  недоступен для интерфейсов и статических классов.
		// В интерфейсы, как и в «use», умеют все, даже статические классы.

		// Конечно, статический класс может имплементить лишь статические интер-
		// фейсы (в Java за такое ругают, но тут я главный и мне норм), а реали-
		// зованные могут использовать лишь другие реализованные,  но эти мелочи 
		// будут проверяться позже.

		function collect (list = []){
			do 
				list.push (parseClassIdentifier ());
			while (index < length && match (',') && lex ());
			return list;
		}

		// Интерфейс суть лишь особенный класс
		var token, result = { parent: null, implements: [], uses: [] };

		do {
			token = lookahead ();

			switch (token.value){
				case 'extends':
					if (result.parent || mode.interface || mode.static)
						throwUnexpected (token);

					lex ();
					result.parent = parseClassIdentifier ();
					break;

				case 'implements':
				case 'uses':
					lex ();
					collect (result [token.value]);
					break;

				default:
					return result;
			}
		} while (index < length);
	}

	function parseClassMembers (params, dependsOn){
		var oldInClass = state.inClass,
			token, 
			result = {}, 
			current;

		function refresh ()
			// Первый параметры можно переопределять, но остальные, если они уже
			// выставлены у всего класса, изменить уже не выйдет.
			current = { 
				publicMode: 		null, 
				abstract: 			params.abstract,
				static: 			params.static
			}

		function set (obj){
			var name = obj.id.name,
				has = result.hasOwnProperty (name),
				temp = has ? result [name] : null;

			$.extend (obj, current, { publicMode: current.publicMode || params.publicMode })

			if (temp instanceof Array){
				temp.push (obj);
			} else if (has){
				throwError (token, 'Name "' + name + '" is already used by an another ' + (result [name].type === Syntax.VariableDeclarator ? 'field' : 'method'));
			} else
				result [name] = obj;
		}

		function parseField (){
			if (matchKeyword ('var'))
				lex ();

			var token = lookahead (),
				data = parseVariableDeclarationList ();

			consumeSemicolon ();

			for (var entry in-array data){
				if (params.interface && !current.static)
					throwError (token, 'Interface couldn\'t have object fields.');

				if (params.implemented && entry.init)
					throwError (token, 'Implemented couldn\'t have initialized fields.');

				set (entry);
			}

			refresh ();
		}

		function parseMethod (){
			if (matchKeyword ('function'))
				lex ();

			state.superAvailable = !current.static;

			var token 		= lookahead (),
				id 			= token.type === Token.Identifier 
								? parseVariableIdentifier () 
								: current.static 
									? '@initializer' 
									: '@constructor',
				defaults 	= [],
				args 		= parseFunctionArgumentsIfExist (defaults),
				body 		= null;

			if (!current.static && params.interface || params.implemented)
				consumeSemicolon ();
			else 
				body = parseFunctionSourceElements (defaults);

			state.superAvailable = false;
			set (functionDeclaration (id, args, body));

			refresh ();
		}

		state.inClass = true;
		expect ('{');
		refresh ();

		do {
			token = lookahead ();

			if (token.value === '}')
				break;

			switch (token.value){
				case 'public':
				case 'private':
				case 'protected':
					if (current.publicMode !== null)
						throwUnexpected (token);

					lex ();
					current.publicMode = token.value;
					break;

				case 'abstract':
					if (params.interface)
						throwUnexpected (token);

				case 'static':
					if (current.abstract || current.static)
						throwUnexpected (token);

					lex ();
					current [token.value] = true;
					break;

				case 'var':
					parseField ();
					break;

				case 'function':
					parseMethod ();
					break;

				default:
					if (token.type === Token.Identifier || token.value === '(' || token.value === '{'){
						saved = saveAll ();

						try {
							parseField ();
						} catch {
							if (String (e).indexOf ('Unexpected token') !== -1){
								restoreAll (saved);
								parseMethod ();
							} else
								throw e;
						}

						break;
					}

					throwUnexpected (token);
					// throw new Error ('Token: "' + token.value + '", type: ' + token.type);
			}
		} while (index < length);

		expect ('}');

		state.inClass = oldInClass;
		return result;
	}

	function parseSuperExpression (){
		var level = 1, name, temp, arguments;

		expectKeyword ('super');

		if (!state.superAvailable)
			throwError ({}, 'Super can be used in class functions only');

		while (match ('.')){
			lex ();

			if (matchKeyword ('super')){
				level ++;
				lex ();
			} else {
				name = parseClassIdentifier ();
				break;
			}
		}

		arguments = parseArguments ();
		consumeSemicolon ();

		return superExpression (name, arguments, level);
	}

	function verbose (id, params, dependsOn, members){
		var membersStrings = [], dependsOnStrings = [], beforeString = '';
		for (var key, member in members){
			var temp = [];

			if (member instanceof Array){
				member = member [0];
				if (!member)
					continue;
			}

			for (var attribute, setted in member)
				if (setted === true)
					temp.push (attribute);

			if (member.publicMode)
				temp.push (member.publicMode);

			temp.push ({ FunctionDeclaration: 'method', VariableDeclarator: 'field' }[member.type] || member.type);

			if (members [key] instanceof Array)
				temp.push (', total count: ' + members [key].length);

			membersStrings.push ('	* ' + member.id.name + ' (' + temp.join (' ').replace (/ ,/g, ',') + ')');
		}

		var paramsString = [];
		for (var attribute, setted in params)
			if (setted === true)
				paramsString.push (attribute);

		if (params.publicMode)
			paramsString.push (params.publicMode);

		if (paramsString.length)
			dependsOnStrings.push (paramsString.join (' '));

		if (dependsOn.parent)
			dependsOnStrings.push ('child of ' + dependsOn.parent.name);

		if (dependsOn.implements.length)
			dependsOnStrings.push ('implements ' + dependsOn.implements.map (lambda arg.name).join (', '));

		if (dependsOn.uses.length)
			dependsOnStrings.push ('using ' + dependsOn.uses.map (lambda arg.name).join (', '));

		if (dependsOnStrings.length)
			beforeString = ' (' + dependsOnStrings.join ('; ') + ')';

		console.log (id.name + beforeString + ':\n' + membersStrings.join ('\n'));
	}

	function parseClassDeclaration (){
		// Получаем параметры класса, задаваемые ключевыми словами вроде «public», «abstract», «static» или «interface»
		var params = parseClassParams ();

		// А после — имя класса
		var id = parseClassIdentifier ();

		// Классы, от которых зависит текущий класс (родительские, интерфейсы и используемые)
		var dependsOn = parseExtendsImplementsAndUses (params);

		// Содержимое класса
		var members = parseClassMembers (params, dependsOn);

		// Выводим распарсенное в консоль
		verbose (id, params, dependsOn, members);

		// Записываем новый класс
		state.classes.push ({
			id: 			id,
			params: 		params,
			dependsOn: 		dependsOn,
			members: 		members
		});

		return null;
	}