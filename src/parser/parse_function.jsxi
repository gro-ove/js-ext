	// 13 Function Definition

	function parseFunctionArguments (defaults){
		var token, temp, params = [];

		expect ('(');

		if (!match (')'))
			while (index < length){
				token = lookahead ();

				temp = parseVariableIdentifier ();

				if (defaults && match ('=')){
					lex ();
					defaults.push ({ name: temp.name, value: parseAssignmentExpression () });
				}

				params.push (temp);

				if (match (')'))
					break;

				expect (',');
			}

		expect (')');

		return params;
	}

	function getDefaultsSetter (defaults){
		return defaults.map (lambda {
			type: 'IfStatement',
            test: {
                type: 'BinaryExpression',
                operator: '===',
                left: {
                    type: 'Identifier',
                    name: arg.name
                },
                right: {
                    type: 'Identifier',
                    name: 'undefined'
                }
            },
            consequent: {
                type: 'ExpressionStatement',
                expression: {
                    type: 'AssignmentExpression',
                    operator: '=',
                    left: {
                        type: 'Identifier',
                        name: arg.name
                    },
                    right: arg.value
                }
            },
            alternate: null
		});
	}

	function parseFunctionSourceElements (){
		var sourceElement, 
			oldPreventSequence,
			sourceElements = [];

		oldPreventSequence = state.preventSequence;
		state.preventSequence = false;

		if (match ('{')){
			expect ('{');

			while (index < length){
				if (match ('}'))
					break;
				sourceElement = parseSourceElement ();
				if (typeof sourceElement === 'undefined') 
					break;
				sourceElements.push (sourceElement);
			}

			expect ('}');
		} else 
			sourceElements.push (parseSourceElement ());

		state.preventSequence = oldPreventSequence;

		return {
			type: 	Syntax.BlockStatement,
			body: 	sourceElements
		};
	}

	function parseFunctionDeclaration (){
		var id, param, params = [], defaults = [], body, token;

		expectKeyword ('function');

		token 	= lookahead ();
		id 		= parseVariableIdentifier ();
		params 	= parseFunctionArguments (defaults);
		body 	= parseFunctionSourceElements ();

		if (defaults.length)
			body.body = getDefaultsSetter (defaults).concat (body.body);

		return {
			type: 			Syntax.FunctionDeclaration,
			id: 			id,
			params: 		params,
			defaults: 		defaults,
			body: 			body,
			rest: 			null,
			generator: 		false,
			expression: 	false
		};
	}

	function parseFunctionExpression (){
		var token, id = null, param, params, defaults = [], body;

		expectKeyword ('function');

		if (!match ('(')){
			token 	= lookahead ();
			id 		= parseVariableIdentifier ();
		}

		params 	= parseFunctionArguments (defaults);
		body 	= parseFunctionSourceElements (defaults);

		if (defaults.length)
			body.body = getDefaultsSetter (defaults).concat (body.body);

		return {
			type: 			Syntax.FunctionExpression,
			id: 			id,
			params: 		params,
			defaults: 		[],
			body: 			body,
			rest: 			null,
			generator: 		false,
			expression: 	false
		};
	}

	function setReturnStatement (data){
		if (data){
			if (data.type === 'ExpressionStatement'){
				data.type = 'ReturnStatement';
				data.argument = data.expression;
				delete data.expression;
			} else if (data.type === 'IfStatement'){
				setReturnStatement (data.consequent);
				setReturnStatement (data.alternate);
			} else if (data.type === 'BlockStatement' && data.single){
				setReturnStatement (data.body [0]); 
			} else if (data.type === 'TryStatement'){
				setReturnStatement (data.block);

				if (data.handlers && data.handlers [0])
					setReturnStatement (data.handlers [0].body);
				if (data.finalizer)
					setReturnStatement (data.finalizer);
			}
		}

		return data;
	}

	function parseLambdaSourceElements (){
		var sourceElements,
			oldPreventSequence,
			saved;

		oldPreventSequence = state.preventSequence;
		state.preventSequence = true;

		if (match ('{')){
			saved = saveAll ();

			try {
				expr = parseObjectInitialiser ();
				consumeSemicolon ();

				sourceElements = [
					setReturnStatement ({
						type: Syntax.ExpressionStatement,
						expression: expr
					})
				];
			} catch {
				restoreAll (saved);
				sourceElements = parseFunctionSourceElements ();
			}
		} else 
			sourceElements = [
				setReturnStatement (
					parseSourceElement ()
				)
			];

		state.preventSequence = oldPreventSequence;

		return {
			type: 	Syntax.BlockStatement,
			body: 	sourceElements
		};
	}

	function parseLambdaExpression (){
		var token, param, defaults = [], params = [], body;

		expectKeyword ('lambda');

		params = match ('(') ? parseFunctionArguments (defaults) : [];
		body = parseLambdaSourceElements ();

		if (defaults.length)
			body.body = getDefaultsSetter (defaults).concat (body.body);

		return {
			type: 			Syntax.FunctionExpression,
			id: 			null,
			params: 		params,
			defaults: 		[],
			body: 			body,
			rest: 			null,
			generator: 		false,
			expression: 	false
		};
	}