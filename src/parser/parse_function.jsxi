	// 13 Function Definition

	function parseFunctionArguments (defaults){
		var token, temp, params = [];

		expect ('(');

		if (!match (')'))
			while (index < length){
				token = lookahead ();

				temp = parseVariableIdentifier ();

				if (defaults && match ('=')){
					lex ();
					defaults.push (ifStatement (
							binaryExpression (temp.name, '===', 'undefined'),
							expressionStatement (assignmentExpression (temp.name, parseAssignmentExpression ()))));
				}

				params.push (temp);

				if (match (')'))
					break;

				expect (',');
			}

		expect (')');

		return params;
	}

	function parseFunctionArgumentsIfExist (defaults){
		var saved = saveAll ();

		try {
			return parseFunctionArguments (defaults);
		} catch {
			restoreAll (saved);
			return [ identifier ('arg') ];
		}
	}

	function parseSourceElement (){
		var token = lookahead ();

		if (token.type === Token.Keyword)
			switch (token.value){
				case 'function':
					return parseFunctionDeclaration ();
				default:
					return parseStatement ();
			}

		if (token.type !== Token.EOF) 
			return parseStatement ();
	}

	function parseFunctionSourceElements (defaults){
		var sourceElement, 
			oldPreventSequence,
			sourceElements = defaults || [];

		if (match ('{')){
			saved = saveAll ();
			oldPreventSequence = state.preventSequence;
			state.preventSequence = false;

			try {
				expect ('{');

				while (index < length){
					if (match ('}'))
						break;
					sourceElement = parseSourceElement ();
					if (sourceElement === undefined) 
						break;
					sourceElements.push (sourceElement);
				}

				expect ('}');
				state.preventSequence = oldPreventSequence;
			} catch {
				restoreAll (saved);

				temp = parseObjectInitialiser ();
				consumeSemicolon ();
				sourceElements.push (setReturnStatement (expressionStatement (temp)));
			}
		} else 
			sourceElements.push (setReturnStatement (parseSourceElement ()));

		return blockStatement (sourceElements);
	}

	function parseFunctionDeclarationOrExpression (){
		var result = parseFunctionExpression ();

		if (match ('(')){
			result = callExpression (result, parseArguments ());
		} else if (result.id !== null)
			result.type = Syntax.FunctionDeclaration;

		if (result.type !== Syntax.FunctionDeclaration)
			result = expressionStatement (result);

		return result;
	}

	function parseFunctionDeclaration (){
		var token, id, params, defaults = [], body;

		expectKeyword ('function');

		token 	= lookahead ();
		id 		= parseVariableIdentifier ();
		params 	= parseFunctionArgumentsIfExist (defaults);
		body 	= parseFunctionSourceElements (defaults);

		return functionDeclaration (id, params, body);
	}

	function parseFunctionExpression (){
		var token, id = null, params, defaults = [], body;

		expectKeyword ('function');

		if (!match ('(')){
			token 	= lookahead ();
			id 		= parseVariableIdentifier ();
		}

		params 	= parseFunctionArgumentsIfExist (defaults);
		body 	= parseFunctionSourceElements (defaults);

		return functionExpression (id, params, body);
	}

	function setReturnStatement (data){
		if (data){
			if (data.type === Syntax.ExpressionStatement){
				data.type = Syntax.ReturnStatement;
				data.argument = data.expression;
				delete data.expression;
			} else if (data.type === Syntax.IfStatement){
				setReturnStatement (data.consequent);
				setReturnStatement (data.alternate);
			} else if (data.type === Syntax.LabelledStatement){
				setReturnStatement (data.body);
			} else if (data.type === Syntax.BlockStatement && data.single){
				setReturnStatement (data.body [0]); 
			} else if (data.type === Syntax.TryStatement){
				setReturnStatement (data.block);

				if (data.handlers && data.handlers [0])
					setReturnStatement (data.handlers [0].body);
				if (data.finalizer)
					setReturnStatement (data.finalizer);
			}
		}

		return data;
	}

	function parseLambdaSourceElements (defaults){
		var sourceElements = defaults || [],
			oldPreventSequence,
			temp,
			saved;

		oldPreventSequence = state.preventSequence;
		state.preventSequence = true;

		if (match ('{')){
			saved = saveAll ();

			try {
				temp = parseObjectInitialiser ();
				consumeSemicolon ();
				sourceElements.push (setReturnStatement (expressionStatement (temp)));
			} catch {
				restoreAll (saved);
				sourceElements = parseFunctionSourceElements (defaults);
			}
		} else 
			sourceElements.push (setReturnStatement (parseSourceElement ()));

		state.preventSequence = oldPreventSequence;

		return blockStatement (sourceElements);
	}

	function parseLambdaExpression (){
		var token, param, defaults = [], params = [], body;

		expectKeyword ('lambda');

		params = parseFunctionArgumentsIfExist (defaults);
		body = parseLambdaSourceElements (defaults);

		return functionExpression (null, params, body);
	}