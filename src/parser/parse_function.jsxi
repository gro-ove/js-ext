/* 	
	options:
		- keyword: 			ключевое слово (по умолчанию «function»), null - без ключевого слова
		- declaration: 		true - возвращается FunctionDeclaration, false - FunctionExpression
		- id: 				true - поиск имени обязателен, false - без имени
		- emptyBody: 		true - функция без содержимого, после может быть «;», false - стандартный режим
		- optionalParams:   true - аргументы функции опциональны, [ ... ] - аргументы по умолчанию
*/
function parseFunction (options = {}){
	var id, params, body, token = lookahead ();

	if (options.keyword !== null)
		expectKeyword (options.keyword || 'function');

	if (options.id === true || options.id !== false && lookahead ().type === Token.Identifier)
		id = parseIdentifier ();
	else
		id = null;

	if (options.optionalParams)
		params = parseOptionalFunctionArguments () || (options.optionalParams === true ? [] : options.optionalParams);
	else
		params = parseFunctionArguments ();

	if (!options.empty){
		body = parseFunctionElements ();
	} else {
		body = null;
		consumeSemicolon ();
	}

	return (options.declaration ? functionDeclarationFromToken : functionExpressionFromToken)(token, id, params, body);
}

function parseFunctionExpression (){
	var oldNoReturn = state.noReturn, result;
	state.noReturn = false;
	result = parseFunction ();
	state.noReturn = oldNoReturn;
	return result;
}

function parseFunctionDeclaration (){
	var oldNoReturn = state.noReturn, result;
	state.noReturn = false;
	result = parseFunction ({ id: true, declaration: true });
	state.noReturn = oldNoReturn;
	return result;
}

function parseLambdaExpression (){
	var oldNoReturn = state.noReturn, result;
	state.noReturn = false;
	result = parseFunction ({ id: false, keyword: 'lambda', optionalParams: [ identifier ('arg') ] });
	state.noReturn = oldNoReturn;
	return result;
}

function parseFunctionArguments (){
	var name, params = [], comma = {};

	expect ('(');

	while (!match (')')){
		if (params.length)
			parseOptionalComma (comma);

		name = parseIdentifier ();
		if (matchLex ('='))
			name.defaultValue = parseAssignmentExpression ();

		params.push (name);
	}

	expect (')');
	return params;
}

function parseOptionalFunctionArguments ()
	return attemptTo (parseFunctionArguments, null, !match ('('));

function parseFunctionElements (){
	var oldPreventSequence = state.preventSequence, result;

	if (match ('{')){
		expect ('{');

		attemptTo (
			lambda {
				result = [ returnStatement (objectExpression (parseObjectContent ())) ];
				consumeSemicolon ();
			},
			lambda {
				state.preventSequence = false;
				result = [];

				while (!match ('}'))
					result.push (parseStatement ());
			},
			lookahead ().type !== Token.Literal && lookahead ().type !== Token.Identifier);

		expect ('}');
	} else if (match (';')){
		lex ();
		result = [];
	} else if (!match (']') && !match (')') && !match ('}') && !match (',')){
		state.preventSequence = true;
		result = [ setReturnStatement (parseStatement ()) ];
	}

	state.preventSequence = oldPreventSequence;
	return blockStatement (result);
}

function setReturnStatement (data){
	if (data)
		if (data.type === Syntax.ExpressionStatement){
			data.type = Syntax.ReturnStatement;
			data.argument = data.expression;
			delete data.expression;
		} else if (data.type === Syntax.IfStatement){
			setReturnStatement (data.consequent);
			setReturnStatement (data.alternate);
		} else if (data.type === Syntax.LabelledStatement){
			setReturnStatement (data.body);
		} else if (data.type === Syntax.BlockStatement && data.single){
			setReturnStatement (data.body [0]); 
		} else if (data.type === Syntax.TryStatement){
			setReturnStatement (data.block);
			if (data.handlers && data.handlers [0])
				setReturnStatement (data.handlers [0].body);
			if (data.finalizer)
				setReturnStatement (data.finalizer);
		}

	return data;
}