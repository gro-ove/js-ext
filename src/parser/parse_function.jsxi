	// 13 Function Definition

	function parseFunctionArguments (defaults, noargs)
		return attemptTo (
			lambda {
				var name, 
					params = [],
					comma = {};

				expect ('(');

				while (!match (')')){
					if (params.length)
						parseOptionalComma (comma);

					name = parseVariableIdentifier ();

					if (defaults && match ('=')){
						lex ();
						defaults.push (ifStatement (
								binaryExpression (name.name, '===', 'undefined'),
								expressionStatement (assignmentExpression (name.name, parseAssignmentExpression ()))));
					}

					params.push (name);
				}

				expect (')');
				return params;
			},
			lambda {
				return noargs ? [] : [ identifier ('arg') ];
			},
			!match ('(')
		)

	function parseFunctionSourceElements (defaults){
		var oldPreventSequence = state.preventSequence,
			sourceElements = defaults || [],
			token;

		if (match ('{')){
			expect ('{');

			token = lookahead ();

			attemptTo (
				lambda {
					var object = objectExpression (parseObjectContent ()),
						statement = returnStatement (object);

					sourceElements.push (statement);
					consumeSemicolon ();
				},
				lambda {
					state.preventSequence = false;

					while (!match ('}'))
						sourceElements.push (parseStatement ());
				},
				token.type !== Token.Literal && token.type !== Token.Identifier
			);

			expect ('}');
		} else if (!match (']') && !match (')') && !match ('}') && !match (',') && !match (';')){
			state.preventSequence = true;
			sourceElements.push (setReturnStatement (parseStatement ()));
		}

		state.preventSequence = oldPreventSequence;
		return blockStatement (sourceElements);
	}

	// 	options:
	// 		- keyword: 		искомое ключевое слово (по умолчанию «function»)
	// 		- declaration: 	true - режим FunctionDeclaration, false - режим FunctionExpression
	// 		- name: 		true - поиск имени обязателен, false - поиска имени не будет
	// 		- empty: 		true - функция без содержимого, false - и с содержимым
	function parseFunction (options = {}){
		var id = null, 
			params, 
			defaults = [], 
			body = null;

		if (options.keyword !== null)
			expectKeyword (options.keyword || 'function');

		if (options.name === true || options.name !== false && lookahead ().type === Token.Identifier)
			id = parseVariableIdentifier ();

		params = parseFunctionArguments (defaults);

		if (options.empty)
			consumeSemicolon ();
		else
			body = parseFunctionSourceElements (defaults);

		return (options.declaration ? functionDeclaration : functionExpression)(id, params, body);
	}

	function parseFunctionExpression ()
		return parseFunction ();

	function parseFunctionDeclaration ()
		return parseFunction ({ name: true, declaration: true });

	function parseLambdaExpression ()
		return parseFunction ({ name: false, keyword: 'lambda' });

	function setReturnStatement (data){
		if (data)
			if (data.type === Syntax.ExpressionStatement){
				data.type = Syntax.ReturnStatement;
				data.argument = data.expression;
				delete data.expression;
			} else if (data.type === Syntax.IfStatement){
				setReturnStatement (data.consequent);
				setReturnStatement (data.alternate);
			} else if (data.type === Syntax.LabelledStatement){
				setReturnStatement (data.body);
			} else if (data.type === Syntax.BlockStatement && data.single){
				setReturnStatement (data.body [0]); 
			} else if (data.type === Syntax.TryStatement){
				setReturnStatement (data.block);
				if (data.handlers && data.handlers [0])
					setReturnStatement (data.handlers [0].body);
				if (data.finalizer)
					setReturnStatement (data.finalizer);
			}

		return data;
	}