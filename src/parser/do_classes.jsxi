function doClasses (statements, callback){
	var classes = [], 
		helpers = new HelpersManager (),
		thatVariable = '__that';

	var OutputMode = {
		Default: 				'Default',
		Static: 				'Static',
		InitializerOnly: 		'InitializerOnly',
		Empty: 					'Empty'
	};

	function filter (classEntry, filter){
		var result = [];
		for (var key, value in classEntry.members)
			if (filter (value, key))
				result.push (value);
		return result;
	}

	function byName (name, path){
		console.assert (typeof name === 'string' && typeof path === 'string', 'Wrong args');

		var length, min = -1, result;

		for (var classEntry in-array classes){
			length = classEntry.path.length;

			if (classEntry.id.name === name && path.substr (0, length) === classEntry.path && min < length){
				min = length;
				result = classEntry;
			}
		}

		return result;
	}

	function collectRawClasses (statements){
		var array = [], rootId = 0;

		(function fromObj (obj, location){
			if (obj instanceof Array){
				set (obj, obj.filter (lambda (child){
					fromObj (child, location);

					if (child.type === Syntax.RawClassDeclaration){
						array.push ($.extend (child, location));
						return false;
					} else
						return true;
				}));
			} else if (obj && typeof obj === 'object'){
				if (obj.type === Syntax.FunctionDeclaration || obj.type === Syntax.FunctionExpression){
					if (obj.body)
						fromObj (obj.body.body, { root: obj.body.body, path: location.path + '/' + ++ rootId });
				} else
					for (var key, child in obj){
						fromObj (child, location);

						if (child && child.type === Syntax.RawClassDeclaration){
							array.push ($.extend (child, location));
							obj [key] = { type: Syntax.EmptyStatement };
						}
					}
			}
		})(statements, { root: statements, path: '' });

		return array;
	}

	function addClass (current){
		var previous = byName (current.id.name, current.path);

		function equals (a, b){
			for (var n in a)
				if (a [n] !== b [n])
					return false;
			for (var n in b)
				if (a [n] !== b [n])
					return false;
			return true;
		}

		if (previous){
			if (!current.params.partial)
				throw new TypeError ('Class "' + current.id.name + '" already declared', current.id);
			
			if (!equals (current.params, previous.params))
				throw new TypeError ('Params of classes are different', id);

			if ((current.dependsOn.parent && current.dependsOn.parent.name) !== (previous.dependsOn.parent && previous.dependsOn.parent.name))
				throw new TypeError ('Params "extends" of classes are different', id);

			if (current.dependsOn.implements.map (lambda arg.name).join () !== previous.dependsOn.implements.map (lambda arg.name).join ())
				throw new TypeError ('Params "implements" of classes are different', id);

			for (var entry in-array current.dependsOn.uses)
				if (previous.dependsOn.uses.filter (lambda arg.name === entry.name).length === 0)
					previous.dependsOn.uses.push (entry);

			$.extend (previous.members, current.members);
		} else
			classes.push (current);
	}

	function preprocessClasses (){
		function preprocessClass (classEntry){
			// Обновляем метод или поле
			function updateMember (member){
				// Если вдруг такого метода или поля в классе нет, добавим
				if (!classEntry.members.hasOwnProperty (member.id.name))
					classEntry.members [member.id.name] = member;

				// И добавляем пару вспомогательных атрибутов
				member.className 	= classEntry.id;
				member.method 		= member.type === Syntax.FunctionExpression;
				member.processed 	= false;

				return member;
			}

			// Вспомогательный атрибут на будущее
			classEntry.classObject = true;

			// Проставляем каждому члену имя родительского класса (позже пригодится)
			for (var name, value in classEntry.members)
				value.className = classEntry.id;

			// Находим, а если понадобится, то создаём конструктор
			var constructor = classEntry.members ['@constructor'];
			if (constructor === undefined){
				constructor = updateMember (functionExpression ('@constructor', [], blockStatement ([])));
				constructor.autocreated = true;
			}

			// Аналогично со статическим инициализатором
			var initializer = classEntry.members ['@initializer'];
			if (initializer === undefined){
				initializer = updateMember (functionExpression ('@initializer', [], blockStatement ([])));
				initializer.static = true;
				initializer.autocreated = true;
			}

			// Обновляем поля и методы
			for (var name, member in classEntry.members)
				updateMember (member);

			// Находим список полей объекта, требующих инициализации
			var fields = filter (classEntry, lambda !arg.method && !arg.static && arg.init);

			// Собираем присваивания для инициализации
			var initialization = fields.map (lambda 
				$.extend (expressionStatement (assignmentExpression (memberExpression (thisExpression (), arg.id.name), arg.init)), { autocreated: true }));

			// Запихиваем присваивания в начало конструктора
			[].unshift.apply (constructor.body.body, initialization);

			// Всякие мелочи
			classEntry.childs = [];
			classEntry.probablyUseOther = 0;
		}
		
		for (var classEntry in-array classes)
			preprocessClass (classEntry);
	}

	function connectClasses (){
		var active = {};

		function searchSuperExpression (obj){
			if (obj.type === Syntax.CallExpression && 'super' in obj && obj.callee === null){
				return true;
			} else if (obj && obj.body && obj.body.body){
				for (var child in-array obj.body.body){
					if (searchSuperExpression (child))
						return true;
				}
			} else {
				for (var key, child in obj)
					if (child && typeof child.type === 'string' && searchSuperExpression (child))
						return true;
			}
		}

		function connectClass (current, from){
			if (active [current.id.name] === true)
				throw new TypeError ('Circular dependency', current.id);

			if (from)
				current.childs.push (from);

			if (current.weight)
				return;

			active [current.id.name] = true;
			current.weight = 1;

			if (current.dependsOn.parent){
				var parent = byName (current.dependsOn.parent.name, current.path);

				if (!parent)
					throw new TypeError ('Parent class "' + current.dependsOn.parent.name + '" not found', current.dependsOn.parent);
				
				current.dependsOn.parent = parent;

				connectClass (parent, current);
				current.weight += parent.weight;

				for (var id, member in parent.members)
					if (!current.members.hasOwnProperty (id))
						current.members [id] = $.extend (true, {}, member, { publicMode: member.publicMode === 'private' ? 'locked' : member.publicMode });

				var parentConstructor = parent.members ['@constructor'],
					constructor = current.members ['@constructor'];

				if (parentConstructor.body.body.length > 0 && !searchSuperExpression (constructor)){
					if (constructor.autocreated || parentConstructor.params.length === 0){
						for (var autocreated, statement in-array constructor.body.body){
							if (!statement.autocreated)
								break;
						}

						constructor.body.body.splice (autocreated, 0, expressionStatement (superExpression (null)));
					} else
						throw new TypeError ('Super constructor call is required', constructor);
				}
			}

			for (var index, usedName in-array current.dependsOn.uses){
				var used = byName (usedName.name, current.path);

				if (!used)
					throw new TypeError ('Used class "' + usedName.name + '" not found', usedName);

				current.dependsOn.uses [index] = used;

				connectClass (used);
				current.weight += used.weight;
			}

			delete active [current.id.name];
		}

		for (var current in-array classes)
			connectClass (current);
	}

	function processClassesMembers (){
		// Получаем заменённое имя в зависимости от видимости переменной
		function rename (name, member, publicMode){
			// Скрытым или приватным и статическим членам имя не меняем
			if (publicMode === 'locked' || member.static && publicMode === 'private')
				return name;

			switch (publicMode){
				case 'protected':
					return '__' + name;

				case 'private':
					return '__' + member.className.name + '_' + name;

				case 'public':
					return name;

				default:
					console.assert (false, 'Bad publicMode value');
			}
		}

		// Проверяем, ошибочно ли перекрытие поля или метода родительского класса (нельзя понижать видимость)
		function badOverride (parentMember, childMember)
			switch (childMember.publicMode){
				case 'public':
					return false;

				case 'protected':
					return parentMember.publicMode === 'public';

				case 'private':
					return true;

				default:
					console.assert (false, 'Bad publicMode value: ' + childMember.publicMode);
			}

		function morePublicMode (firstMode, secondMode){
			var modes = [ 'locked', 'private', 'protected', 'public' ],
				firstId = modes.indexOf (firstMode),
				secondId = modes.indexOf (secondMode),
				maxId = Math.max (firstId, secondId);

			return modes [maxId];
		}

		function processClassMember (current, name, member){
			var publicMode = member.publicMode,
				members = [ member ],
				updated;

			function testChilds (current)
				for (var child in-array current.childs){
					if (child.members.hasOwnProperty (name)){
						var childMember = child.members [name];

						if (badOverride (member, childMember))
							throw new TypeError ('Invalid public mode', childMember.id);

						if (member.method !== childMember.method)
							throw new TypeError ('Invalid override (' + (member.method ? 'method' : 'field') + ' required)', childMember.id);

						publicMode = morePublicMode (publicMode, childMember.publicMode);
						members.push (childMember);
					}

					testChilds (child);
				}

			if (publicMode === 'protected' || publicMode === 'public')
				testChilds (current);

			updated = rename (name, member, publicMode);

			for (var targetMember in-array members){
				targetMember.id.name = updated;
				targetMember.processed = true;
			}
		}

		function processClassMembers (current){
			if (current.dependsOn.parent)
				processClassMembers (current.dependsOn.parent);

			// Проходим по всем полям и методам класса, кроме конструктора, инициализатора и уже обработанных полей или методов
			for (var name, member in current.members)
				if (name [0] !== '@' && !member.processed)
					processClassMember (current, name, member);
		}

		for (var current in-array classes)
			processClassMembers (current);
	}

	function processClassesMethods (){
		function processClassMethod (classEntry, methodEntry){
			console.assert (classEntry && methodEntry, 'Wrong arguments');

			// Тут будут лежать имена локальных переменных
			var exclusions = {};

			// Ссылка на ноду AST текущей обрабатываемой функции
			var currentFunction;

			// Если какому-то из кусков AST понадобится ссылка на this,  он поменяет эту
			// переменную
			var usingThat = false;

			// Возвращает «this» или «that» в зависимости от того,  какая функция сейчас
			// обрабатывается
			function getThis (){
				// Определяем, дочерняя ли эта функция по отношению к основной обрабатываемой
				var childFunction = currentFunction !== methodEntry;

				// Если дочерняя, просим обеспечить ссылку на «this».
				if (childFunction)
					usingThat = true;

				return childFunction ? identifier (thatVariable) : thisExpression ();
			}

			// Ищет в переданном куске AST имена переменных, функций и прочей мути
			function lookForExclusions (obj, target)
				if (typeof obj === 'object' && obj !== null){
					if (obj instanceof Array){
						// Массивы пробегаем в ускоренном темпе
						for (var child in-array obj)
							lookForExclusions (child, target);

					} else if ('type' in obj){
						if (obj.type === Syntax.VariableDeclarator || obj.type === Syntax.FunctionDeclaration){
							// Переменные и функции записываем
							target [obj.id.name] = true;

						} else if (obj.type !== Syntax.FunctionExpression){
							// А по содержимое функций не трогаем
							for (var key, value in obj)
								lookForExclusions (value, target);
						}
					}
				}

			// Обработка функции
			function processFunction (obj, parent){
				console.assert (typeof obj === 'object' 
					&& (obj.type === Syntax.FunctionDeclaration || obj.type === Syntax.FunctionExpression), 'Wrong argument');

				// Сохраняем текущие значения, а после переустанавливаем на свои
				var oldExclusions = $.extend (true, {}, exclusions),
					oldCurrentFunction = currentFunction;

				currentFunction = obj;

				// Заносим в исключения аргументы функции
				obj.params.forEach (lambda exclusions [arg.name] = true);

				// И ищем внутри переменные
				lookForExclusions (obj.body.body, exclusions);

				// Обновляем содержимое
				process (obj.body.body, obj);

				// Если кто-то попросил ссылку на «this», а мы — главная функция, добавим её.
				if (usingThat && methodEntry === obj){
					var temp = variableDeclarator (thatVariable, thisExpression ());

					if (obj.body.body [0] && obj.body.body [0].type === Syntax.VariableDeclaration)
						// Если первым идёт список переменных, кидаем в начало списка
						obj.body.body [0].declarations.unshift (temp);
					else
						// Иначе — в начало функции
						obj.body.body.unshift (variableDeclaration ([ temp ]));
				}

				// Возвращаем старые значения
				exclusions = oldExclusions;
				currentFunction = oldCurrentFunction;
			}

			function processProperty (obj, parent){
				process (obj.value, parent);
			}

			function processIdentifier (obj, parent){
				// Несколько адовая функция

				function replaceObject (member){
					// Из статичных свойств обращаться к свойствам объекта как-то непра-
					// вильно (methodEntry  -  нода AST основной обрабатываемой функции,
					// на неё и смотрим)
					if (methodEntry.static)
						throw new TypeError ('Member "' + obj.name + '" is static', obj);

					// Получаем ссылку на «this» (или «that»)
					var that = getThis ();

					// Результат
					var result;

					// Если обращались к функции и при этом она не вызывается, имеет смысл привязать её к объекту
					if (member.method && parent.type !== Syntax.CallExpression){
						helpers.set ('bindOnce', obj);
						result = callExpression ('__bindOnce', [ that, stringLiteralWithQuotes (member.id.name) ]);
					} else {
						result = memberExpression (that, member.id.name);
					}

					return result;
				}

				function replaceStatic (member){
					// Да, тут всё куда проще

					// Имя класса, в котором определено то нечто, к чему мы обращаемся
					var className = member.className;

					// Используем «className.name», потому что иначе две ноды AST будут представлены одним и тем же
					// объектом, что может выйти боком (а при передаче именно строки будет создана новая нода)
					return memberExpression (className.name, member.id.name);
				}

				// Проверяем, нет ли в исключениях такого же идентификатора
				if (!(obj.name in exclusions)){
					var result = null,
						member;

					if (obj.name in classEntry.members){
						// Обрабатываем метод или поле (приватные статические методы или
						// поля ставятся иначе, и замена для них не нужна)

						member = classEntry.members [obj.name];

						// Не даём обращаться и к скрытым полям
						if (member.publicMode === 'locked')
							throw new TypeError ('Member "' + obj.name + '" has private access', obj);

						if (!member.static)
							result = replaceObject (member);
						else if (member.publicMode !== 'private')
							result = replaceStatic (member);

					} else if (byName (obj.name, classEntry.path)){
						// Если внезапно нашли имя другого класса, отмечаем, что, вероятно, обрабатываемый класс использует этот
						// другой класс и имело бы смысл по возможности поместить его ниже.
						classEntry.weight += 0.0001;
					}

					// Меняем объект, если что-то нашлось
					if (result)
						set (obj, result);
				}
			}

			function processAssignmentExpression (obj, parent){
				process (obj.right, obj);
				process (obj.left, obj);
			}

			function processMemberExpression (obj, parent, preparent){
				var member,
					propertyNameGetter,
					second,
					temp;

				if (!obj.computed){
					member = classEntry.members.hasOwnProperty (obj.property.name) ? classEntry.members [obj.property.name] : null;

					if (member){
						if (member.static){
							if (member.publicMode === 'private' && obj.object.type === Syntax.Identifier && obj.object.name === member.className.name){
								set (obj, identifier (member.id.name));
								return;
							}
						} else if (obj.object.type === Syntax.ThisExpression){
							obj.property.name = member.id.name;
						} else if (0 && member.publicMode !== 'public'){
							if (parent instanceof Array && preparent)
								parent = preparent;

							if (obj.object.type === Syntax.Identifier){
								obj.computed = true;
								obj.property = conditionalExpression (
									binaryExpression (obj.object, 'instanceof', member.className.name), 
									stringLiteralWithQuotes (member.id.name), 
									stringLiteralWithQuotes (obj.property.name));

								process (obj.object, obj);
							} else if (parent.type === Syntax.AssignmentExpression){
								second = $.extend (true, {}, parent);
								for (var key, value in parent)
									if (value === obj)
										second [key] = memberExpression ('__', conditionalExpression (
											binaryExpression ('__', 'instanceof', member.className.name), 
											stringLiteralWithQuotes (member.id.name), 
											stringLiteralWithQuotes (obj.property.name)), true);

								set (parent, sequenceExpression ([
									assignmentExpression ('__', obj.object), 
									second
								]));

								process (obj.object, obj);

								temp = true;
							} else {
								set (obj, sequenceExpression ([
									assignmentExpression ('__', obj.object), 
									memberExpression ('__', conditionalExpression (
								 			binaryExpression ('__', 'instanceof', member.className.name), 
								 			stringLiteralWithQuotes (member.id.name), 
								 			stringLiteralWithQuotes (obj.property.name)), true)
								]));

								process (obj);

								if (parent.type === Syntax.CallExpression && obj === parent.callee){
									parent.callee = memberExpression (parent.callee, 'call');
									parent.arguments.unshift (identifier ('__'));
								}

								temp = true;
							}

							if (temp && !currentFunction.hasTempVariable){
								currentFunction.body.body.unshift (oneVariableDeclaration ('__'));
								currentFunction.hasTempVariable = true;
							}

							return;
						}
					}
				}

				// Всё довольно просто — обрабатываем объект ...
				process (obj.object, obj);

				// ... и, если обращение выполняется через квадратные скобки, заодно и их содержимое
				if (obj.computed)
					process (obj.property, obj);
			}

			function processSuperExpression (obj, parent){
				// TODO: static

				// Либо «super» используется в корне одной из функций объекта, или у него есть
				// имя вызываемого супер-метода
				if (currentFunction !== methodEntry && obj.callee === null)
					throw new Error ('Not implemented'); // TODO

				// Ищем название нужного класса, идя по дереву классов
				var currentClass = classEntry;

				// В поле «super» хранится, на сколько нужно подняться
				for (var i = 0; i < obj ['super']; i ++){
					currentClass = currentClass.dependsOn.parent;

					// Если вдруг родителей не хватает, вываливаемся
					if (!currentClass)
						throw new TypeError ('Super method is not available', obj);
				}

				// Вызываемый метод
				var method = obj.callee ? currentClass.members [obj.callee.name] : methodEntry; // TODO: "findByReplacement (currentClass, methodEntry.id.name)" - wut?

				if (!method)
					throw new TypeError ('Super method not found', obj);

				if (method.static)
					throw new TypeError ('This method is static', obj);

				// У кого вызывать метод
				var target;

				if (method.id.name [0] !== '@'){
					// Если имя где-то, но есть, и при этом это не конструктор или деструктор, вызываем метод из прототипа
					target = memberExpression (memberExpression (currentClass.id, 'prototype'), method.id.name);
				} else {
					// Иначе вызываем конструктор
					target = currentClass.id.name;
				}

				// Если вызов без скобок, подставляем все аргументы
				if (obj.arguments === null){
					obj.callee = memberExpression (target, 'apply');
					obj.arguments = [ identifier ('arguments') ];
				} else 
					obj.callee = memberExpression (target, 'call');

				// Не забываем добавить «this» в аргументы
				obj.arguments.unshift (getThis ());
			}

			function process (obj, parent, preparent){
				if (typeof obj === 'object' && obj !== null){
					// Как-нибудь обойдёмся и без строк, чисел, null'ов и прочей мути

					if (obj instanceof Array){
						// Массивы пробегаем в ускоренном темпе
						for (var child in-array obj)
							process (child, obj, parent);

					} else if ('type' in obj){
						// Тут всё и так вполне очевидно

						switch (obj.type){
							case Syntax.FunctionDeclaration:
							case Syntax.FunctionExpression:
								processFunction (obj, parent);
								break;

							case Syntax.Property:
								processProperty (obj, parent);
								break;

							case Syntax.Identifier:
								processIdentifier (obj, parent);
								break;

							case Syntax.AssignmentExpression:
								processAssignmentExpression (obj, parent);
								break;

							case Syntax.MemberExpression:
								processMemberExpression (obj, parent, preparent);
								break;

							case Syntax.CallExpression:
								if ('super' in obj)
									processSuperExpression (obj, parent);
								// Оператор «break» пропущен специально

							default:
								for (var key, value in obj){
									// TODO: Optimize by key filtering?
									process (value, obj);
								}
						}
					}
				}
			}

			process (methodEntry);
		}

		function processClassMethods (classEntry){
			var replace,
				childMember;

			// Проходим по всем методам именно этого класса
			for (var name, member in classEntry.members){
				if (member.method && !member.abstract && member.className === classEntry.id)
					processClassMethod (classEntry, member);
			}
		}

		for (var classEntry in-array classes)
			processClassMethods (classEntry);
	}

	function processClasses (){
		// Ключевая функция для обработки класса (конвертирует его в стандартное AST-дерево)
		function processClass (classEntry){
			// Функция для определения режима конвертации
			function classMode (){
				// Если нет дочерних или родительских классов, нет объектных членов, а конструктор пустой
				if (classEntry.childs.length === 0 && !classEntry.dependsOn.parent 
					&& objectMembers.length === 0 && constructor.body.body.length === 0){

					// Есть статическое поле или метод
					if (staticFields.length > 0 || staticMethods.length > 0)
						return OutputMode.Static;

					// В инициализаторе что-то есть
					if (initializer.body.body.length > 0)
						return OutputMode.InitializerOnly;

					return OutputMode.Empty;
				}

				return OutputMode.Default;
			}

			// Небольшая проверка на всякий случай
			console.assert (!classEntry.elements, 'Already processed');

			// Находим конструктор и инициализатор
			var constructor 	= classEntry.members ['@constructor'],
				initializer 	= classEntry.members ['@initializer'];

			// Объектные и статические поля и методы данного класса
			var filtered 		= filter (classEntry, lambda arg.className === classEntry.id && arg.id.name [0] !== '@'),
				objectMembers 	= filtered.filter (lambda !arg.static),
				staticMembers 	= filtered.filter (lambda  arg.static);

			// Отделяем статические от объектных поля от методов
			var objectMethods 	= objectMembers.filter (lambda  arg.method),
				objectFields 	= objectMembers.filter (lambda !arg.method),
				staticMethods 	= staticMembers.filter (lambda  arg.method),
				staticFields 	= staticMembers.filter (lambda !arg.method);

			// Слегка меняем конструктор и инициализатор
			constructor.id = null;
			initializer.id = null;

			// Если хоть одно из полей абстрактно, то и класс абстрактен
			if (!classEntry.params.abstract && filter (classEntry, lambda arg.abstract).length > 0)
				classEntry.params.abstract = true;

			// Исключение в конструктор для абстрактных классов
			if (classEntry.params.abstract)
				constructor.body.body.unshift (
					ifStatement (
						binaryExpression (memberExpression (thisExpression (), identifier ('constructor')), '===', classEntry.id.name),
						throwStatement (newExpression ('Error', [ 
							stringLiteralWithQuotes ('Trying to instantiate abstract class ' + classEntry.id.name) 
						]))));

			// Режим сборки
			var mode = classMode ();

			// Пустой объект
			if (mode === OutputMode.Empty)
				return [ oneVariableDeclaration (classEntry.id.name, objectExpression ([])) ];

			// Одна лишь анонимная функция
			if (mode === OutputMode.InitializerOnly)
				return [ oneVariableDeclaration (classEntry.id.name, callExpression (initializer)) ];

			// А тут всё несколько посерьёзнее
			var anonymousFunction = staticMembers.filter (lambda arg.publicMode === 'private').length > 0,
				result,
				mainObj;

			if (mode === OutputMode.Default){
				// Конструктор
				result = [ anonymousFunction 
					? oneVariableDeclaration (classEntry.id, constructor)
					: functionDeclaration (classEntry.id, constructor.params, constructor.body) ];

				// Вызов «prototypeExtend» для наследования
				if (classEntry.dependsOn.parent)
					result.push (expressionStatement (callExpression ('__prototypeExtend', [ classEntry.id.name, classEntry.dependsOn.parent.id.name ])));

				// Поля объекта (уже добавлены в конструктор)
				for (var field in-array objectFields){}

				// Методы объекта
				for (var method in-array objectMethods){
					if (!method.abstract)
						result.push (assignmentStatement (
							memberExpression (memberExpression (classEntry.id.name, 'prototype'), method.id), 
							functionExpression (null, method.params, method.body)));
				}

				// Статические поля
				for (var field in-array staticFields){
					if (field.publicMode === 'private')
						result [0].declarations.push (field);
					else 
						result.push (assignmentStatement (memberExpression (classEntry.id.name, field.id), field.init || 'undefined'));
				}

				// Статические методы
				for (var method in-array staticMethods){
					if (method.publicMode === 'private')
						result.push (method);
					else
						result.push (expressionStatement (assignmentExpression (
							memberExpression (classEntry.id.name, method.id),
							functionExpression (null, method.params, method.body))));
				}
			} else {
				var properties = [];
				result = [ oneVariableDeclaration (classEntry.id, objectExpression (properties)) ];

				// Статические поля
				for (var field in-array staticFields){
					if (field.publicMode === 'private')
						result [0].declarations.push (field);
					else 
						properties.push (property (field.id, field.init || 'undefined'));
				}

				// Статические методы
				for (var method in-array staticMethods){
					if (method.publicMode === 'private')
						result.push (method);
					else
						properties.push (property (method.id, functionExpression (null, method.params, method.body)));
				}
			}

			// Инициализатор
			if (initializer.body.body.length > 0)
				result.push (expressionStatement (callExpression (initializer)));

			// Если есть приватные статические члены, результатом будет анонимная функция
			if (anonymousFunction){
				result.push (returnStatement (classEntry.id.name));
				return [ oneVariableDeclaration (classEntry.id, callFunctionExpression (result)) ];
			}

			return result;
		}
		
		for (var classEntry in-array classes)
			classEntry.statements = processClass (classEntry);
	}

	function sortAndInsertClasses (){
		for (var current in-array classes.sort (lambda (a, b) b.weight - a.weight))
			current.root.unshift ({
				type: 			Syntax.ClassDeclaration,
				name: 			current.id.name,
				statements: 	current.statements
			});
	}

	for (var found in-array collectRawClasses (statements))
		addClass (found);

	if (classes.length > 0){
		preprocessClasses ();
		connectClasses ();
		processClassesMembers ();
		processClassesMethods ();
		processClasses ();
		sortAndInsertClasses ();

		callback (helpers.helpers);
	} else
		callback ();
}