// Обрабатываем все классы
function doClasses (rawClasses, callback){
	// Получить класс по имени
	function byName (name)
		return classesByNames [name];

	// Записать класс в список
	function addClass (name, parent, uses, variables, functions){
		var objectVariables = [], 
			staticVariables = [], 
			objectFunctions = [], 
			staticFunctions = [], 
			objectFields = {},
			staticFields = {},
			objectConstructor, 
			staticInitialization, 
			objectVariablesInitialization = [],
			staticVariablesInitialization = [],
			temp;

		if (byName (name.name))
			throwError (name, Messages.ClassAlreadyDefined, name.name);

		function getName (publicMode, id){
			if (id.name === '@')
				return null;

			switch (publicMode){
				case 'public':
					return id.name;
				case 'protected':
					return '_' + id.name;
				case 'private':
					return '_' + name.name + '_' + id.name;
				default:
					console.assert (false, 'Unsupported publicMode (' + publicMode + ')');
			}
		}

		for (var entry in-array variables)
			if (entry.staticMode){
				entry.declarations.forEach (lambda {
					arg.publicMode = entry.publicMode;
					staticVariables.push (arg);

					staticFields [arg.id.name] = { 
						name: 			getName (entry.publicMode, arg.id),
						publicMode: 	entry.publicMode, 
						className: 		name,
						type: 			'variable'
					};
				});
			} else 
				entry.declarations.forEach (lambda {
					arg.publicMode = entry.publicMode;
					objectVariables.push (arg);

					objectFields [arg.id.name] = { 
						name: 			getName (entry.publicMode, arg.id),
						publicMode: 	entry.publicMode, 
						className: 		null,
						type: 			'variable'
					};

					temp = expressionStatement (assignmentExpression (
						memberExpression (thisExpression (), objectFields [arg.id.name].name), arg.init || 'undefined'));

					temp.comment 		= arg.id.name;
					temp.autocreated 	= true;

					objectVariablesInitialization.push (temp);
				});

		for (var entry in-array functions)
			if (entry.staticMode){
				if (entry.id.name === '@'){
					staticInitialization = entry;
				} else {
					staticFunctions.push (entry);
					staticFields [entry.id.name] = { 
						name: 			getName (entry.publicMode, entry.id),
						publicMode: 	entry.publicMode, 
						className: 		name,
						type: 			'function'
					};

					entry.id.name = staticFields [entry.id.name].name;
				}
			} else {
				if (entry.id.name === '@'){
					objectConstructor = entry;
				} else {
					objectFunctions.push (entry);
					objectFields [entry.id.name] = { 
						name: 			getName (entry.publicMode, entry.id),
						publicMode: 	entry.publicMode, 
						className: 		null,
						type: 			'function'
					};

					entry.id.name = objectFields [entry.id.name].name;
				}
			}

		if (objectVariablesInitialization.length){
			if (!objectConstructor){
				objectConstructor = functionDeclaration ('@');
				objectConstructor.autocreated = true;
			}

			objectConstructor.body.body = objectVariablesInitialization.concat (objectConstructor.body.body);
		}

		if (staticVariablesInitialization.length){
			if (!staticInitialization)
				staticInitialization = functionDeclaration ('@');
			staticInitialization.body.body = staticVariablesInitialization.concat (staticInitialization.body.body);
		}

		if (objectConstructor && objectConstructor.id)
			objectConstructor.id = null;

		if (staticInitialization && staticInitialization.id)
			staticInitialization.id = null;

		classes.push (classesByNames [name.name] = {
			name: 							name,
			parent: 						parent,
			childs: 						[],
			uses: 							uses,
			objectVariables: 				objectVariables,
			staticVariables: 				staticVariables,
			objectFunctions: 				objectFunctions,
			staticFunctions: 				staticFunctions,
			objectConstructor: 				objectConstructor,
			staticInitialization: 			staticInitialization,
			objectFields: 					objectFields,
			staticFields: 					staticFields,
			probablyUseOther: 				0
		})
	}

	function processClassFunction (classEntry, functionEntry){
		console.log ('=================== BEGIN ===================');

		// Тут будут лежать имена локальных переменных — им не нужно будет подставлять «this»
		var exclusions = {};

		// Ссылка на ноду AST текущей обрабатываемой функции
		var currentFunction;

		// Если какому-то из кусков AST понадобится ссылка на this, он поменяет эту переменную
		var usingThat = false;

		// Заменяем содержимое одного объекта содержимым другого
		function set (to, from){
			for (var n in to)
				delete to [n];
			for (var n in from)
				to [n] = from [n];
		}

		// Получаем «this» или «that» в зависимости от того, какая функция сейчас обрабатывается
		function getThis (){
			// Определяем, дочерняя ли эта функция по отношению к основной обрабатываемой
			var childFunction = currentFunction !== functionEntry;

			// Если дочерняя, просим обеспечить ссылку на «this».
			if (childFunction)
				usingThat = true;

			return childFunction ? identifier (thatVariable) : thisExpression ();
		}

		// Ищет в переданном куске AST имена переменных, функций и прочей мути
		function lookForExclusions (obj, target)
			if (typeof obj === 'object' && obj !== null){
				if (obj instanceof Array){
					// Массивы пробегаем в ускоренном темпе
					for (var child in-array obj)
						lookForExclusions (child, target);

				} else if ('type' in obj){
					if (obj.type === Syntax.VariableDeclarator || obj.type === Syntax.FunctionDeclaration){
						// Переменные и функции записываем
						target [obj.id.name] = true;

					} else if (obj.type !== Syntax.FunctionExpression){
						// А по содержимое функций не трогаем
						for (var key, value in obj)
							lookForExclusions (value, target);
					}
				}
			}

		// Обработка функции
		function processFunction (obj, parent){
			console.assert (typeof obj === 'object' && (obj.type === Syntax.FunctionExpression || obj.type === Syntax.FunctionDeclaration), 'Wrong argument');

			// Сохраняем текущие значения, а после переустанавливаем на свои
			var oldExclusions = clone (exclusions),
				oldCurrentFunction = currentFunction;

			exclusions = {};
			currentFunction = obj;

			// Заносим в исключения аргументы функции
			obj.params.forEach (lambda exclusions [arg.name] = true);

			// И ищем внутри переменные
			lookForExclusions (obj.body.body, exclusions);

			// Обновляем содержимое
			process (obj.body.body);

			// Если кто-то попросил ссылку на «this», а мы — главная функция, обеспечим ссылку.
			if (usingThat && functionEntry === obj){
				var temp = [ 
					variableDeclarator (thatVariable, thisExpression ()) 
				];

				if (0 in obj.body && obj.body.body [0].type === Syntax.VariableDeclaration)
					// Если первым идёт список переменных, кидаем в начало списка
					obj.body.body [0].declarations = temp.concat (obj.body.body [0].declarations);
				else
					// Иначе — в начало функции
					obj.body.body = [ variableDeclaration (temp) ].concat (obj.body.body);
			}

			// Возвращаем старые значения
			exclusions = oldExclusions;
			currentFunction = oldCurrentFunction;
		}

		function processProperty (obj, parent){
			process (obj.value, parent);
		}

		function processIdentifier (obj, parent){
			// Несколько адовая функция

			function replaceObject (){
				// Из статичных свойств обращаться к свойствам объекта как-то неправильно (functionEntry -
				// нода AST основной обрабатываемой функции, на неё и смотрим)
				if (functionEntry.staticMode)
					throwError (obj, Messages.ObjectAccessError, obj.name);

				// Не даём обращаться и к скрытым полям
				if (classEntry.objectFields [obj.name].publicMode === 'locked')
					throwError (obj, Messages.PrivateAccessError, obj.name);

				// Получаем ссылку на «this» (или «that»)
				var that = getThis ();

				// Собираем результат
				var temp = classEntry.objectFields [obj.name],
					result = memberExpression (that, temp.name);

				// Если обращались к функции и при этом она не вызывается, имеет смысл привязать её к объекту
				if (temp.type === 'function' && parent.type !== Syntax.CallExpression)
					result = callExpression (memberExpression (result, 'bind'), [ that ]);

				return result;
			}

			function replaceStatic (){
				// Да, тут всё куда проще

				// Бьём по рукам за попытку обратиться к скрытому
				if (classEntry.staticFields [obj.name].publicMode === 'locked')
					throwError (obj, Messages.PrivateAccessError, obj.name);

				// Имя класса, в котором определено то нечто, к чему мы обращаемся
				var className = classEntry.staticFields [obj.name].className;

				// Используем «className.name», потому что иначе две ноды AST будут представлены одним и тем же
				// объектом, что может выйти боком (а при передаче именно строки будет создана новая нода)
				return memberExpression (className.name, classEntry.staticFields [obj.name].name);
			}

			// Проверяем, нет ли в исключениях такого же идентификатора
			if (!(obj.name in exclusions)){
				var result = null;

				if (obj.name in classEntry.objectFields){
					// Обрабатываем метод или поле объекта
					result = replaceObject ();

				} else if (obj.name in classEntry.staticFields && classEntry.staticFields [obj.name].publicMode !== 'private'){
					// Обрабатываем статический метод или поле (приватные статические методы или поля ставятся 
					// иначе, и замена для них не нужна)
					result = replaceStatic ();

				} else if (classesByNames [obj.name])
					// Если внезапно нашли имя другого класса, отмечаем, что, вероятно, обрабатываемый класс 
					// использует этот другой класс и имело бы смысл по возможности поместить обрабатываемый 
					// класс ниже
					classEntry.probablyUseOther ++;

				// Меняем объект, если что-то нашлось
				if (result)
					set (obj, result);
			}
		}

		function processMemberExpression (obj, parent){
			if (obj.object.type === Syntax.ThisExpression && obj.computed === false && obj.property.type === Syntax.Identifier && obj.property.name in classEntry.objectFields){
				// TODO
				obj.property.name = classEntry.objectFields [obj.property.name].name;
			} 

			// Всё довольно просто — обрабатываем объект ...
			process (obj.object, obj);

			// ... и, если обращение выполняется через квадратные скобки, заодно и их содержимое
			if (obj.computed)
				process (obj.property, obj);
		}

		function processThisExpression (obj, parent){
			// Как обычно, получаем ссылку и лепим её на место
			set (obj, getThis ());
		}

		function processSuperExpression (obj, parent){
			// TODO: static

			// Либо «super» используется в корне одной из функций объекта, или у него есть
			// имя вызываемого супер-метода
			if (currentFunction !== functionEntry && obj.callee === null)
				throwError (obj, Messages.WtfMan);

			// Ищем название нужного класса, идя по дереву классов
			var current = classEntry;

			// В поле «super» хранится, на сколько нужно подняться
			for (var i = 0; i < obj ['super']; i ++){
				current = byName (current.parent.name);

				// Если вдруг родителей не хватает, вываливаемся
				if (!current)
					throwError (obj, Messages.SuperMethodsAreNotAvailable);
			}

			// Имя вызываемого метода
			var callee = obj.callee ? obj.callee.name : functionEntry.name;

			// У кого вызывать метод
			var target;

			if (callee){
				// Если имя где-то, но есть, вызываем метод из прототипа
				target = memberExpression (memberExpression (current.name, 'prototype'), callee);
			} else {
				// Иначе вызываем конструктор
				target = current.name;
			}

			// Вызываемая функция
			obj.callee = memberExpression (target, 'call');

			// Получаем ссылку на «this»
			var that = getThis ();

			// Не забываем добавить «this» в аргументы
			obj.arguments = [ that ].concat (obj.arguments);
		}

		function process (obj, parent)
			if (typeof obj === 'object' && obj !== null){
				// Как-нибудь обойдёмся и без строк, чисел, null'ов и прочей мути

				if (obj instanceof Array){
					// Массивы пробегаем в ускоренном темпе
					for (var child in-array obj)
						process (child, obj);

				} else if ('type' in obj){
					// Ну, тут всё вполне очевидно

					switch (obj.type){
						case Syntax.FunctionDeclaration:
						case Syntax.FunctionExpression:
							processFunction (obj, parent);
							break;

						case Syntax.Property:
							processProperty (obj, parent);
							break;

						case Syntax.Identifier:
							processIdentifier (obj, parent);
							break;

						case Syntax.MemberExpression:
							processMemberExpression (obj, parent);
							break;

						case Syntax.ThisExpression:
							processThisExpression (obj, parent);
							break;

						case Syntax.CallExpression:
							if ('super' in obj)
								processSuperExpression (obj, parent);
							// Не стоит переживать на счёт break'а — он пропущен специально (после нужно 
							// будет проверить аргументы и всё такое)

						default:
							for (var key, value in obj){
								// console.log (key, value);
								process (value, obj);
							}
					}
				}
			}

		process (functionEntry);
	}

	function processClass (entry){
		if (typeof entry === 'string'){
			entry = byName (entry);
			assert (entry, 'Class ' + entry + ' not found');
		}

		var variable = entry.name.name, 
			mode,
			body, 
			functions, 
			variables, 
			temp, 
			extendsStatements, 
			publicStaticFunctions,
			resultFunction;

		console.assert (!entry.element, 'Already processed');

		if (entry.objectConstructor){
			processClassFunction (entry, entry.objectConstructor);
			entry.objectConstructor.body.body = entry.objectConstructor.body.body.filter (lambda (arg, i, array){
				if (arg.autocreated && arg.type === Syntax.ExpressionStatement && arg.expression.right.name === 'undefined')
					for (var e in-array array){
						if (e !== arg && e.type === Syntax.ExpressionStatement && e.expression.type === Syntax.AssignmentExpression && e.expression.left.type === Syntax.MemberExpression 
							&& e.expression.left.object.type === Syntax.ThisExpression && e.expression.left.property.name === arg.expression.left.property.name)
							return false;
					}

				return true;
			});
		}

		entry.objectFunctions.forEach (processClassFunction.bind (null, entry));
		if (entry.staticInitialization)
			processClassFunction (entry, entry.staticInitialization);
		entry.staticFunctions.forEach (processClassFunction.bind (null, entry));

		entry.mode = 'default';
		if (!entry.childs.length &&
			!entry.objectConstructor && 
			!entry.parent && 
			!entry.objectFunctions.length && 
			!entry.objectVariables.length){

			entry.mode = 'static';

			if (!entry.staticVariables.length && !entry.staticFunctions.length)
				entry.mode = !entry.staticInitialization ? 'empty' : 'static-initialize-only';
		}

		if (entry.mode === 'empty'){
			entry.element = variableDeclarator (entry.name.name, objectExpression ());
			entry.uses = [];
		} else if (entry.mode === 'static-initialize-only'){
			entry.element = variableDeclarator (entry.name.name, sequenceExpression ([ 
				callExpression (entry.staticInitialization),
				objectExpression ()
			]));
		} else {
			var resultFunction = [ variableDeclaration (variables = []) ];

			if (entry.mode === 'default'){
				variables.push (variableDeclarator (variable, entry.objectConstructor || functionExpression ()));

				if (entry.parent){
					temp = newIdentifier ();
					variables.push (variableDeclarator (temp, functionExpression ()));

					resultFunction.push (
						expressionStatement (assignmentExpression (
								memberExpression (temp, 'prototype'), memberExpression (entry.parent.name, 'prototype'))),
						expressionStatement (assignmentExpression (
								memberExpression (variable, 'prototype'), newExpression (temp))),
						expressionStatement (assignmentExpression (
								memberExpression (memberExpression (variable, 'prototype'), 'constructor'), variable)),
						expressionStatement (assignmentExpression (temp, 'undefined'))
					);
				}

				for (var f in-array entry.objectFunctions)
					resultFunction.push (expressionStatement (assignmentExpression (
							memberExpression (memberExpression (variable, 'prototype'), f.id.name), 
							functionExpression (null, f.params, f.body))));
			} else if (entry.mode === 'static'){
				variables.push (variableDeclarator (variable, objectExpression ()));
			}

			for (var v in-array entry.staticVariables){
				if (v.publicMode !== 'private'){
					var temp = expressionStatement (assignmentExpression (
						memberExpression (variable, entry.staticFields [v.id.name].name), v.init || 'undefined'));
					if (entry.staticFields [v.id.name].publicMode === 'protected')
						temp.comment = v.id.name;
					resultFunction.push (temp);
				} else {
					variables.push (v);
				}
			}

			for (var f in-array entry.staticFunctions){
				if (f.publicMode !== 'private')
					resultFunction.push (expressionStatement (assignmentExpression (
							memberExpression (variable, f.id.name),
							functionExpression (null, f.params, f.body))));
				else
					resultFunction.push (f);
			}

			if (entry.staticInitialization)
				resultFunction.push (expressionStatement (callExpression (entry.staticInitialization)));

			resultFunction.push (returnStatement (variable));

			entry.element = variableDeclarator (entry.name.name, callExpression (functionExpression (null, [], resultFunction)));
		}
	}

	function checkForCircular (){
		var current;

		function check (identifier){
			var entry = byName (identifier.name);
			console.assert (entry, 'Class not found: ' + identifier.name);

			if (current [identifier.name])
				throwError (identifier, Messages.CyclicDependencyDetected, identifier.name);

			current [identifier.name] = true;

			if (entry.parent)
				check (entry.parent, entry.name);

			for (var use in-array entry.uses)
				if (!entry.parent || use.name !== entry.parent.name)
					check (use, entry.name);

			delete current [identifier.name];
		}

		for (var entry in-array classes){
			current = {};
			check (entry.name);
		}
	}

	function connectClass (entry, from){
		var parent;

		if (typeof entry === 'string'){
			entry = byName (entry);
			console.assert (entry, 'Class ' + entry + ' not found');
		}

		if (from !== undefined)
			entry.childs.push (from);

		if (entry.connected)
			return;

		if (entry.parent !== null){
			parent = byName (entry.parent.name);

			if (!parent){
				throwError (entry.parent, Messages.ParentClassNotFound, entry.parent.name);
			} else {
				connectClass (entry.parent.name, entry.name);

				for (var n, v in parent.objectFields)
					if (!entry.objectFields [n])
						entry.objectFields [n] = {
							publicMode: 	v.publicMode === 'private' ? 'locked' : v.publicMode,
							name: 			v.name 
						};

				for (var n, v in parent.staticFields)
					if (!entry.staticFields [n])
						entry.staticFields [n] = {
							publicMode: 	v.publicMode === 'private' ? 'locked' : v.publicMode,
							name: 			v.name,
							className: 		v.className
						};

				if (parent.objectConstructor){
					if (!entry.objectConstructor){
						entry.objectConstructor = functionExpression (null, parent.objectConstructor.params, [
							expressionStatement (superExpression (null, parent.objectConstructor.params))
						]);
					} else if (!entry.objectConstructor.body.body.filter (lambda arg.type === Syntax.ExpressionStatement && arg.expression ['super']).length){
						if (entry.objectConstructor.autocreated || parent.objectConstructor.params.length === 0){
							if (entry.objectConstructor.autocreated)
								entry.objectConstructor.params = parent.objectConstructor.params;
							entry.objectConstructor.body.body = [ expressionStatement (superExpression (null, parent.objectConstructor.params)) ].concat (entry.objectConstructor.body.body);
						} else {
							throwError (entry.objectConstructor, Messages.SuperConstructorCallNeeded);
						}
					}
				}
			}
		}

		for (var use in-array entry.uses){
			if (!byName (use.name))
				throwError (use, Messages.UsingClassNotFound, use.name);
		}

		entry.connected = true;
	}

	function connectClasses (){
		for (var entry in-array classes)
			connectClass (entry);
	}

	function processClasses (){
		for (var entry in-array classes)
			processClass (entry);
	}

	function sortClasses (){
		function getWeight (entry){
			if (typeof entry === 'string'){
				entry = byName (entry);
				console.assert (entry, 'Class not found: ' + entry);
			}

			if (entry.weight)
				return entry.weight;

			entry.weight = entry.probablyUseOther ? 1 + 
				Math.min (entry.probablyUseOther, probablyUseOtherMaxValue) / (probablyUseOtherMaxValue + 1) : 1;

			if (entry.parent)
				entry.weight += getWeight (entry.parent.name);
			for (var use in-array entry.uses)
				entry.weight += getWeight (use.name);
			return entry.weight;
		}

		for (var entry in-array classes)
			getWeight (entry);

		classes.sort (lambda (a, b) a.weight - b.weight);
	}

	var classes 					= [], 
		classesByNames 				= {}, 
		probablyUseOtherMaxValue 	= 100, 
		thatVariable 				= newIdentifier ('_that'); // TODO: Identifier fix

	for (var entry in-array rawClasses)
		addClass (entry.id, entry.parent, entry.uses, entry.variables, entry.functions);

	if (classes.length !== 0){
		checkForCircular ();
		connectClasses ();
		sortClasses ();
		processClasses ();

		callback ([ variableDeclaration (classes.map (lambda arg.element)) ]);
	} else
		callback ([]);
}