var classes, classesByNames, probablyUseOtherMaxValue = 100;

function getPosByName (name)
	return classes.indexOf (classesByNames [name]);

function getByName (name)
	return classesByNames [name];

function addClass (name, parent, uses, variables, functions, at){
	var objectVariables = [], 
		staticVariables = [], 
		objectFunctions = [], 
		staticFunctions = [], 
		objectFields = {},
		objectConstructor, 
		staticInitialization, 
		objectVariablesInitialization = [],
		staticVariablesInitialization = [];

	if (getByName (name.name))
		throwError (name, Messages.ClassAlreadyDefined, name.name);

	for (var entry in-array variables)
		if (entry.staticMode){
			entry.declarations.forEach (lambda {
				arg.publicMode = entry.publicMode;
				staticVariables.push (arg);
			});
		} else 
			entry.declarations.forEach (lambda {
				arg.publicMode = entry.publicMode;
				objectVariables.push (arg);
				objectFields [arg.id.name] = entry.publicMode;

				objectVariablesInitialization.push (
					expressionStatement (
						assignmentExpression (
							memberExpression (
								thisExpression (),
								arg.id.name
							),
							arg.init || 'undefined'
						)
					)
				);
			});

	for (var entry in-array functions)
		if (entry.staticMode){
			if (entry.id.name === '@'){
				staticInitialization = entry;
			} else {
				staticFunctions.push (entry);
			}
		} else {
			if (entry.id.name === '@'){
				objectConstructor = entry;
			} else {
				objectFunctions.push (entry);
				objectFields [entry.id.name] = entry.publicMode;
			}
		}

	if (objectVariablesInitialization.length){
		if (!objectConstructor)
			objectConstructor = functionExpression ();
		objectConstructor.body.body = objectVariablesInitialization.concat (objectConstructor.body.body);
	} else if (objectConstructor)
		objectConstructor.id = null;

	if (staticVariablesInitialization.length){
		if (!staticInitialization)
			staticInitialization = functionExpression ();
		staticInitialization.body.body = staticVariablesInitialization.concat (staticInitialization.body.body);
	} else if (staticInitialization && staticInitialization.body.body.length > 0){
		staticInitialization.id = null;
	} else if (staticInitialization)
		staticInitialization = null;

	classes.push (classesByNames [name.name] = {
		name: 							name,
		parent: 						parent,
		uses: 							uses,
		objectVariables: 				objectVariables,
		staticVariables: 				staticVariables,
		objectFunctions: 				objectFunctions,
		staticFunctions: 				staticFunctions,
		objectConstructor: 				objectConstructor,
		staticInitialization: 			staticInitialization,
		objectFields: 					objectFields,
		at: 							at
	})
}

function initClasses (){
	classes = [];
	classesByNames = {};
}

function processClass (entry){
	if (typeof entry === 'string')
		assert (entry = getByName (entry), 'Class ' + entry + ' not found');

	var variable, 
		exclusions = null, 
		staticMode, 
		mode,
		body, 
		functions, 
		variables, 
		temp, 
		extendsStatements, 
		publicStaticFunctions,
		resultFunction;

	if (entry.element)
		return;

	function updateExclusions (obj, second)
		if (obj instanceof Array){
			for (var i = 0; i < obj.length; i ++)
				updateExclusions (obj [i], true);
		} else if (obj && obj.type){
			if (obj.type === 'FunctionDeclaration' || obj.type === 'FunctionExpression'){
				if (!second){
					exclusions = {};
					updateExclusions (obj.body, true);
					obj.params.forEach (lambda exclusions [arg.name] = true);
				}
			} else if (obj.type === 'VariableDeclarator'){
				exclusions [obj.id.name] = true;
			} else {
				for (var n in obj)
					updateExclusions (obj [n], true);
			}
		}

	function update (obj, name, second)
		if (obj instanceof Array){
			for (var i = 0; i < obj.length; i ++)
				obj [i] = update (obj [i], name, true) || obj [i];
		} else if (obj && obj.type){
			var oldExclusions = undefined, oldStaticMode, temp;

			if (obj.type === Syntax.FunctionDeclaration || obj.type === Syntax.FunctionExpression){
				oldExclusions 	= exclusions;
				oldStaticMode 	= staticMode;

				updateExclusions (obj);
				staticMode 		= obj.staticMode;

				update (obj.body.body, second ? null : name, true);

				exclusions 		= oldExclusions;
				staticMode 		= oldStaticMode;
			} else if (obj.type === Syntax.Property){
				obj.value = update (obj.value, name, true) || obj.value;
			} else if (obj.type === Syntax.Identifier){
				if (!exclusions [obj.name]){
					if (entry.objectFields [obj.name]){
						if (staticMode)
							throwError (obj, Messages.ObjectAccessError, obj.name);

						if (entry.objectFields [obj.name] === 'locked')
							throwError (obj, Messages.PrivateAccessError, obj.name);

						return memberExpression (thisExpression (), obj.name);
					} else if (classesByNames [obj.name])
						entry.probablyUseOther = (entry.probablyUseOther || 0) + 1;
				}
			} else if (obj.type === Syntax.MemberExpression){
				obj.object = update (obj.object, name, true) || obj.object;
				if (obj.computed)
					obj.property = update (obj.property, name, true) || obj.property;
			} else {
				if (obj.type === Syntax.CallExpression && obj ['super']){
					if (name === null && obj.callee === null)
						throwError (obj, Messages.WtfMan);

					var parent = entry,
						callee = obj.callee ? obj.callee.name : name;

					for (var i = 0; i < obj ['super']; i ++){
						parent = getByName (parent.parent.name);
						if (!parent)
							throwError (obj, Messages.SuperMethodsAreNotAvailable);
					}

					obj.callee = memberExpression (
						callee === '@' 
							? parent.name
							: memberExpression (
								memberExpression (parent.name, 'prototype'),
								callee),
						'call');

					obj.arguments = [ thisExpression () ].concat (obj.arguments);
				}

				for (var n in obj)
					if (n !== 'type')
						obj [n] = update (obj [n], name, true) || obj [n];
			}
		}

	if (entry.parent !== null)
		if (!getByName (entry.parent.name)){
			throwError (entry.parent, Messages.ParentClassNotFound, entry.parent.name);
		} else {
			processClass (entry.parent.name);

			if (getByName (entry.parent.name).mode !== 'default')
				throwError (entry.parent, Messages.ParentClassIsStatic, entry.parent.name);

			for (var n, v in getByName (entry.parent.name).objectFields)
				if (!entry.objectFields [n])
					entry.objectFields [n] = v === 'private' ? 'locked' : v;
		}

	for (var use in-array entry.uses){
		if (!getByName (use.name))
			throwError (use, Messages.UsingClassNotFound, use.name);
	}

	if (entry.objectConstructor)
		update (entry.objectConstructor, '@');
	entry.objectFunctions.forEach (lambda update (arg, arg.id.name));
	if (entry.staticInitialization)
		update (entry.staticInitialization, '@');
	entry.staticFunctions.forEach (lambda update (arg, arg.id.name));

	entry.mode = 'default';
	if (!entry.objectConstructor && 
		!entry.parent && 
		!entry.objectFunctions.length && 
		!entry.objectVariables.length){

		entry.mode = 'static';

		if (!entry.staticInitialization && 
			!entry.staticVariables.length){

			if (!entry.staticFunctions.length)
				entry.mode = 'empty';
		}
	}

	if (entry.mode === 'empty'){
		entry.element = variableDeclarator (entry.name.name, objectExpression ());
		entry.uses = [];
	} else {
		var resultFunction = [ variableDeclaration (variables = []) ];

		variable = newIdentifier ();

		if (entry.mode === 'default'){
			variables.push (variableDeclarator (variable, entry.objectConstructor));

			if (entry.parent){
				temp = newIdentifier ();
				variables.push (variableDeclarator (temp, functionExpression ()));

				resultFunction.push (
					expressionStatement (assignmentExpression (
							memberExpression (temp, 'prototype'), memberExpression (entry.parent.name, 'prototype'))),
					expressionStatement (assignmentExpression (
							memberExpression (variable, 'prototype'), newExpression (temp))),
					expressionStatement (assignmentExpression (
							memberExpression (memberExpression (variable, 'prototype'), 'constructor'), variable)),
					expressionStatement (assignmentExpression (temp, 'undefined'))
				);
			}

			for (var f in-array entry.objectFunctions)
				resultFunction.push (expressionStatement (
					assignmentExpression (
						memberExpression (memberExpression (variable, 'prototype'), f.id.name), 
						functionExpression (null, f.params, f.body))));
		} else if (entry.mode === 'static'){
			variables.push (variableDeclarator (variable, objectExpression ()));
		}

		for (var v in-array entry.staticVariables)
			variables.push (v);

		for (var f in-array entry.staticFunctions){
			resultFunction.push (f);

			if (f.publicMode === 'public')
				resultFunction.push (expressionStatement (
					assignmentExpression (memberExpression (variable, f.id.name), f.id.name)));
		}

		if (entry.staticInitialization)
			resultFunction.push (expressionStatement (callExpression (entry.staticInitialization)));

		resultFunction.push (returnStatement (variable));

		entry.element = variableDeclarator (entry.name, callExpression (functionExpression (null, [], resultFunction)));
	}
}

function checkForCircular (){
	var current;

	function check (identifier){
		var entry = getByName (identifier.name);
		assert (entry, 'Class not found: ' + identifier.name);

		if (current [identifier.name])
			throwError (identifier, Messages.CyclicDependencyDetected, identifier.name);

		current [identifier.name] = true;

		if (entry.parent)
			check (entry.parent, entry.name);
		for (var use in-array entry.uses)
			check (use, entry.name);
	}

	for (var entry in-array classes){
		current = {};
		check (entry.name);
	}
}

function sortClasses (){
	function getWeight (entry){
		if (typeof entry === 'string')
			assert (entry = getByName (entry), 'Class not found: ' + entry);

		if (entry.weight)
			return entry.weight;

		entry.weight = entry.probablyUseOther ? 1 + 
			Math.min (entry.probablyUseOther, probablyUseOtherMaxValue) / (probablyUseOtherMaxValue + 1) : 1;

		if (entry.parent)
			entry.weight += getWeight (entry.parent.name);
		for (var use in-array entry.uses)
			entry.weight += getWeight (use.name);
		return entry.weight;
	}

	for (var entry in-array classes)
		getWeight (entry);

	classes.sort (lambda (a, b) a.weight > b.weight);
}

function processClasses (program){
	var temp, other;

	if (classes.length === 0)
		return;

	for (var entry in-array classes)
		processClass (entry);

	checkForCircular ();
	sortClasses ();

	return variableDeclaration (classes.map (lambda arg.element));
}
