var classes;

function addClass (name, parent, uses, variables, functions, element){
	var objectVariables = [], 
		staticVariables = [], 
		objectFunctions = [], 
		staticFunctions = [], 
		objectFields = {},
		objectConstructor, 
		staticInitialization, 
		staticVariablesInitialization = [];

	if (classes [name])
		throwError ({}, Messages.WtfMan);

	for (var entry in-array variables)
		if (entry.staticMode){
			entry.declarations.forEach (lambda {
				arg.publicMode = entry.publicMode;
				staticVariables.push (arg);
			});
		} else 
			entry.declarations.forEach (lambda {
				arg.publicMode = entry.publicMode;
				objectVariables.push (arg);
				objectFields [arg.id.name] = entry.publicMode;
			});

	for (var entry in-array functions)
		if (entry.staticMode){
			if (entry.id.name === '@'){
				staticInitialization = entry;
			} else {
				staticFunctions.push (entry);
			}
		} else {
			if (entry.id.name === '@'){
				objectConstructor = entry;
			} else {
				objectFunctions.push (entry);
				objectFields [entry.id.name] = entry.publicMode;
			}
		}

	if (!objectConstructor)
		objectConstructor = functionExpression ();
	else
		objectConstructor.id = null;

	if (!staticInitialization)
		staticInitialization = functionExpression ();
	else
		staticInitialization.id = null;

	staticInitialization.body.body = staticVariablesInitialization.concat (staticInitialization.body.body);

	classes [name] = {
		name: 							name,
		parent: 						parent,
		uses: 							uses,
		objectVariables: 				objectVariables,
		staticVariables: 				staticVariables,
		objectFunctions: 				objectFunctions,
		staticFunctions: 				staticFunctions,
		objectConstructor: 				objectConstructor,
		staticInitialization: 			staticInitialization,
		objectFields: 					objectFields,
		element: 						element
	}
}

function initClasses (){
	classes = {};
}

function setupClass (name){
	var entry = classes [name], variable, exclusions = null, body, functions, variables, temp, extendsStatements;

	assert (entry, 'Class not found: ' + name);

	if (entry.done)
		return;

	function updateExclusions (obj, second)
		if (obj instanceof Array){
			for (var i = 0; i < obj.length; i ++)
				updateExclusions (obj [i], true);
		} else if (obj && obj.type){
			if (obj.type === 'FunctionDeclaration' || obj.type === 'FunctionExpression'){
				if (!second){
					exclusions = {};
					updateExclusions (obj.body, true);
					obj.params.forEach (lambda exclusions [arg.name] = true);
				}
			} else if (obj.type === 'VariableDeclarator'){
				exclusions [obj.id.name] = true;
			} else {
				for (var n in obj)
					updateExclusions (obj [n], true);
			}
		}

	function update (obj, name, second)
		if (obj instanceof Array){
			for (var i = 0; i < obj.length; i ++)
				obj [i] = update (obj [i], name, true) || obj [i];
		} else if (obj && obj.type){
			var oldExclusions = undefined, temp;

			if (obj.type === 'FunctionDeclaration' || obj.type === 'FunctionExpression'){
				oldExclusions = exclusions;
				updateExclusions (obj);
				update (obj.body.body, second ? null : name, true);
				exclusions = oldExclusions;
			} else if (obj.type === 'Property'){
				obj.value = update (obj.value, name, true) || obj.value;

			} else if (obj.type === 'Identifier' && entry.objectFields [obj.name] && !exclusions [obj.name]){
				if (entry.objectFields [obj.name] === 'locked')
					throwError ({}, 'Attempt to access to private field: ' + obj.name);

				return {
					type: 		'MemberExpression',
					computed: 	false,
					object: 	{ type: 'ThisExpression' },
					property: 	{ type: 'Identifier', name: obj.name }
				};

			} else {
				if (obj.type === 'CallExpression' && obj ['super']){
					if (name === null && obj.callee === null)
						throwError ({}, Messages.WtfMan);

					var parent = entry,
						callee = obj.callee ? obj.callee.name : name;

					for (var i = 0; i < obj ['super']; i ++){
						parent = classes [parent.parent];
						if (!parent)
							throwError ({}, Messages.WtfMan);
					}

					obj.callee = memberExpression (
						callee === '@' 
							? parent.name
							: memberExpression (
								memberExpression (
									parent.name, 
									'prototype'),
								callee),
						'call');

					obj.arguments = [ { type: 'ThisExpression' } ].concat (obj.arguments);
				}

				if (obj.type !== 'MemberExpression')
					for (var n in obj)
						obj [n] = update (obj [n], name, true) || obj [n];
			}
		}

	if (entry.parent !== null)
		if (!classes [entry.parent]){
			throwError ({}, 'Parent class not found: ' + use);
		} else {
			setupClass (entry.parent);
			for (var n, v in classes [entry.parent].objectFields)
				if (!entry.objectFields [n])
					entry.objectFields [n] = v === 'private' ? 'locked' : v;
		}

	for (var use in-array entry.uses){
		if (!classes [use])
			throwError ({}, 'Using class not found: ' + use);
	}

	update (entry.objectConstructor, '@');
	entry.objectFunctions.forEach (lambda update (arg, arg.id.name));

	variable = newIdentifier ();

	variables = [
		variableDeclarator (variable, entry.objectConstructor)
	];

	if (entry.parent){
		temp = newIdentifier ();
		variables.push (variableDeclarator (temp, functionExpression ()));
		extendsStatements = [
			expressionStatement (
				assignmentExpression (
					memberExpression (
						temp,
						'prototype'
					),
					memberExpression (
						entry.parent,
						'prototype'
					)
				)
			),
			expressionStatement (
				assignmentExpression (
					memberExpression (
						variable,
						'prototype'
					),
					newExpression (
						temp
					)
				)
			),
			expressionStatement (
				assignmentExpression (
					memberExpression (
						memberExpression (
							variable,
							'prototype'
						),
						'constructor'
					),
					variable
				)
			),
			expressionStatement (
				assignmentExpression (
					temp,
					'undefined'
				)
			)
		];
	} else
		extendsStatements = [];

	if (entry.staticVariables.length)
		variables = variables.concat (entry.staticVariables);

	entry.element.init = callExpression (
		functionExpression (
			null, 
			[], 
			[ 
				variableDeclaration (variables)
			].concat (
				extendsStatements
			).concat (
				entry.objectFunctions.map (lambda 
					expressionStatement (
						assignmentExpression (
							memberExpression (
								memberExpression (
									variable,
									'prototype'
								),
								arg.id.name
							),
							functionExpression (
								null,
								arg.params,
								arg.body
							)
						)
					)
				)
			).concat (
				entry.staticFunctions
			).concat (
				entry.staticFunctions
					.filter (lambda arg.publicMode === 'public')
					.map (lambda 
						expressionStatement (
							assignmentExpression (
								memberExpression (
									variable,
									arg.id.name
								),
								arg.id.name
							)
						)
					)
			).concat (
				[ returnStatement (variable) ]
			)
		)
	);

	entry.done = true;
}

function setupClasses (){
	for (var name in classes)
		setupClass (name);

	return {
		before: [],
		after: []
	};
}

function resetClasses (){
	classes = undefined;
}
