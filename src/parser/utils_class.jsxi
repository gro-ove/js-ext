var classes, classesByNames, probablyUseOtherMaxValue = 100;

function getPosByName (name)
	return classes.indexOf (classesByNames [name]);

function getByName (name)
	return classesByNames [name];

function addClass (name, parent, uses, variables, functions){
	var objectVariables = [], 
		staticVariables = [], 
		objectFunctions = [], 
		staticFunctions = [], 
		objectFields = {},
		objectConstructor, 
		staticInitialization, 
		objectVariablesInitialization = [],
		staticVariablesInitialization = [];

	if (getByName (name))
		throwError ({}, Messages.WtfMan);

	for (var entry in-array variables)
		if (entry.staticMode){
			entry.declarations.forEach (lambda {
				arg.publicMode = entry.publicMode;
				staticVariables.push (arg);
			});
		} else 
			entry.declarations.forEach (lambda {
				arg.publicMode = entry.publicMode;
				objectVariables.push (arg);
				objectFields [arg.id.name] = entry.publicMode;

				objectVariablesInitialization.push (
					expressionStatement (
						assignmentExpression (
							memberExpression (
								thisExpression (),
								arg.id.name
							),
							arg.init || 'undefined'
						)
					)
				);
			});

	for (var entry in-array functions)
		if (entry.staticMode){
			if (entry.id.name === '@'){
				staticInitialization = entry;
			} else {
				staticFunctions.push (entry);
			}
		} else {
			if (entry.id.name === '@'){
				objectConstructor = entry;
			} else {
				objectFunctions.push (entry);
				objectFields [entry.id.name] = entry.publicMode;
			}
		}

	if (!objectConstructor)
		objectConstructor = functionExpression ();
	else
		objectConstructor.id = null;

	if (!staticInitialization)
		staticInitialization = functionExpression ();
	else
		staticInitialization.id = null;

	objectConstructor.body.body = objectVariablesInitialization.concat (objectConstructor.body.body);
	staticInitialization.body.body = staticVariablesInitialization.concat (staticInitialization.body.body);

	classes.push (classesByNames [name] = {
		name: 							name,
		parent: 						parent,
		uses: 							uses,
		objectVariables: 				objectVariables,
		staticVariables: 				staticVariables,
		objectFunctions: 				objectFunctions,
		staticFunctions: 				staticFunctions,
		objectConstructor: 				objectConstructor,
		staticInitialization: 			staticInitialization,
		objectFields: 					objectFields
	})
}

function initClasses (){
	classes = [];
	classesByNames = {};
}

function processClass (entry){
	if (typeof entry === 'string')
		assert (entry = getByName (entry), 'Class not found');

	var variable, exclusions = null, staticMode, body, functions, variables, temp, extendsStatements;

	if (entry.element)
		return;

	function updateExclusions (obj, second)
		if (obj instanceof Array){
			for (var i = 0; i < obj.length; i ++)
				updateExclusions (obj [i], true);
		} else if (obj && obj.type){
			if (obj.type === 'FunctionDeclaration' || obj.type === 'FunctionExpression'){
				if (!second){
					exclusions = {};
					updateExclusions (obj.body, true);
					obj.params.forEach (lambda exclusions [arg.name] = true);
				}
			} else if (obj.type === 'VariableDeclarator'){
				exclusions [obj.id.name] = true;
			} else {
				for (var n in obj)
					updateExclusions (obj [n], true);
			}
		}

	function update (obj, name, second)
		if (obj instanceof Array){
			for (var i = 0; i < obj.length; i ++)
				obj [i] = update (obj [i], name, true) || obj [i];
		} else if (obj && obj.type){
			var oldExclusions = undefined, oldStaticMode, temp;

			if (obj.type === Syntax.FunctionDeclaration || obj.type === Syntax.FunctionExpression){
				oldExclusions 	= exclusions;
				oldStaticMode 	= staticMode;

				updateExclusions (obj);
				staticMode 		= obj.staticMode;

				update (obj.body.body, second ? null : name, true);

				exclusions 		= oldExclusions;
				staticMode 		= oldStaticMode;
			} else if (obj.type === Syntax.Property){
				obj.value = update (obj.value, name, true) || obj.value;
			} else if (obj.type === Syntax.Identifier){
				if (!exclusions [obj.name]){
					if (entry.objectFields [obj.name]){
						console.log (obj);
						
						if (staticMode)
							throwError (obj, Messages.ObjectAccessError, obj.name);

						if (entry.objectFields [obj.name] === 'locked')
							throwError (obj, Messages.PrivateAccessError, obj.name);

						return memberExpression (thisExpression (), obj.name);
					} else if (classesByNames [obj.name])
						entry.probablyUseOther = (entry.probablyUseOther || 0) + 1;
				}
			} else if (obj.type === Syntax.MemberExpression){
				obj.object = update (obj.object, name, true) || obj.object;
				if (obj.computed)
					obj.property = update (obj.property, name, true) || obj.property;
			} else {
				if (obj.type === Syntax.CallExpression && obj ['super']){
					if (name === null && obj.callee === null)
						throwError ({}, Messages.WtfMan);

					var parent = entry,
						callee = obj.callee ? obj.callee.name : name;

					for (var i = 0; i < obj ['super']; i ++){
						parent = getByName (parent.parent);
						if (!parent)
							throwError ({}, Messages.WtfMan);
					}

					obj.callee = memberExpression (
						callee === '@' 
							? parent.name
							: memberExpression (
								memberExpression (parent.name, 'prototype'),
								callee),
						'call');

					obj.arguments = [ thisExpression () ].concat (obj.arguments);
				}

				for (var n in obj)
					if (n !== 'type')
						obj [n] = update (obj [n], name, true) || obj [n];
			}
		}

	if (entry.parent !== null)
		if (!getByName (entry.parent)){
			throwError ({}, 'Parent class not found: ' + entry.parent);
		} else {
			processClass (entry.parent);
			for (var n, v in getByName (entry.parent).objectFields)
				if (!entry.objectFields [n])
					entry.objectFields [n] = v === 'private' ? 'locked' : v;
		}

	for (var use in-array entry.uses){
		if (!getByName (use))
			throwError ({}, 'Using class not found: ' + use);
	}

	update (entry.objectConstructor, '@');
	entry.objectFunctions.forEach (lambda update (arg, arg.id.name));
	update (entry.staticInitialization, '@');
	entry.staticFunctions.forEach (lambda update (arg, arg.id.name));

	variable = newIdentifier ();

	variables = [
		variableDeclarator (variable, entry.objectConstructor)
	];

	if (entry.parent){
		temp = newIdentifier ();
		variables.push (variableDeclarator (temp, functionExpression ()));
		extendsStatements = [
			expressionStatement (
				assignmentExpression (
					memberExpression (temp, 'prototype'),
					memberExpression (entry.parent, 'prototype')
				)
			),
			expressionStatement (
				assignmentExpression (
					memberExpression (variable, 'prototype'),
					newExpression (temp)
				)
			),
			expressionStatement (
				assignmentExpression (
					memberExpression (
						memberExpression (variable, 'prototype'),
						'constructor'
					),
					variable
				)
			),
			expressionStatement (
				assignmentExpression (temp, 'undefined')
			)
		];
	} else
		extendsStatements = [];

	if (entry.staticVariables.length)
		variables = variables.concat (entry.staticVariables);

	entry.element = variableDeclarator (
		entry.name,
		callExpression (
			functionExpression (
				null, 
				[], 
				[ 
					variableDeclaration (variables)
				].concat (
					extendsStatements
				).concat (
					entry.objectFunctions.map (lambda 
						expressionStatement (
							assignmentExpression (
								memberExpression (
									memberExpression (variable, 'prototype'),
									arg.id.name
								),
								functionExpression (null, arg.params, arg.body)
							)
						)
					)
				).concat (
					entry.staticInitialization.body.body.length 
						? [ expressionStatement (callExpression (entry.staticInitialization)) ]
						: []
				).concat (
					entry.staticFunctions
				).concat (
					entry.staticFunctions
						.filter (lambda arg.publicMode === 'public')
						.map (lambda 
							expressionStatement (
								assignmentExpression (
									memberExpression (variable, arg.id.name),
									arg.id.name
								)
							)
						)
				).concat (
					[ returnStatement (variable) ]
				)
			)
		)
	);
}

function checkForCircular (){
	var current;

	function check (entry, parent){
		if (parent === undefined)
			current = {};

		if (typeof entry === 'string')
			assert (entry = getByName (entry), 'Class not found: ' + entry);

		if (current [entry.name])
			throwError ({}, Messages.CyclicDependencyDetected, entry.name, parent);

		current [entry.name] = true;

		if (entry.parent)
			check (entry.parent, entry.name);
		for (var use in-array entry.uses)
			check (use, entry.name);
	}

	for (var entry in-array classes)
		check (entry);
}

function sortClasses (){
	function getWeight (entry){
		if (typeof entry === 'string')
			assert (entry = getByName (entry), 'Class not found: ' + entry);

		if (entry.weight)
			return entry.weight;

		entry.weight = entry.probablyUseOther ? 1 + Math.min (entry.probablyUseOther, probablyUseOtherMaxValue) / (probablyUseOtherMaxValue + 1) : 1;

		if (entry.parent)
			entry.weight += getWeight (entry.parent);
		for (var use in-array entry.uses)
			entry.weight += getWeight (use);
		return entry.weight;
	}

	for (var entry in-array classes)
		getWeight (entry);

	classes.sort (lambda (a, b) a.weight > b.weight);

	console.json (classes.map (lambda {
		name: arg.name,
		probablyUseOther: arg.probablyUseOther,
		weight: arg.weight
	}));
}

function processClasses (program){
	var temp, other;

	if (classes.length === 0)
		return;

	for (var entry in-array classes)
		processClass (entry);

	checkForCircular ();
	sortClasses ();

	return variableDeclaration (classes.map (lambda arg.element));
}
