var classes;

function addClass (name, parent, uses, variables, data){
	if (classes [name])
		throwError ({}, 'WTF MAN?');

	var variablesObject = {};
	for (var v in-array variables)
		variablesObject [v.name] = v.publicMode;

	classes [name] = {
		name: 		name,
		parent: 	parent,
		uses: 		uses,
		variables: 	variablesObject,
		data: 		data
	}
}

function initClasses (){
	classes = {};
}

function setupClass (name){
	var entry = classes [name], exclusions = null, body, functions;

	assert (entry, 'Class not found: ' + name);

	if (entry.done)
		return;

	function updateExclusions (obj, second)
		if (obj instanceof Array){
			for (var i = 0; i < obj.length; i ++)
				updateExclusions (obj [i], true);
		} else if (obj && obj.type){
			if (obj.type === 'FunctionDeclaration' || obj.type === 'FunctionExpression'){
				if (!second){
					exclusions = {};
					updateExclusions (obj.body, true);
				}
			} else if (obj.type === 'VariableDeclarator'){
				exclusions [obj.id.name] = true;
			} else {
				for (var n in obj)
					updateExclusions (obj [n], true);
			}
		}

	function memberExpression (obj, property)
		return {
			type: 'MemberExpression',
			computed: false,
			object: typeof obj === 'string' ? {
				type: 'Identifier',
				name: obj
			} : obj,
			property: {
				type: 'Identifier',
				name: property
			}
		};

	function update (obj, name, second)
		if (obj instanceof Array){
			for (var i = 0; i < obj.length; i ++)
				obj [i] = update (obj [i], name, true) || obj [i];
		} else if (obj && obj.type){
			var oldExclusions = undefined, temp;

			if (obj.type === 'FunctionDeclaration' || obj.type === 'FunctionExpression'){
				oldExclusions = exclusions;
				updateExclusions (obj);
				update (obj.body.body, second ? null : name, true);
				exclusions = oldExclusions;
			} else if (obj.type === 'Property'){
				obj.value = update (obj.value, name, true) || obj.value;

			} else if (obj.type === 'Identifier' && entry.variables [obj.name] && !exclusions [obj.name]){
				if (entry.variables [obj.name] === 'locked')
					throwError ({}, 'Attempt to access to private field: ' + obj.name);

				return {
					type: 		'MemberExpression',
					computed: 	false,
					object: 	{ type: 'ThisExpression' },
					property: 	{ type: 'Identifier', name: obj.name }
				};

			} else {
				if (obj.type === 'CallExpression' && obj ['super']){
					if (name === null && obj.callee === null)
						throwError ({}, Messages.WtfMan);

					var parent = entry,
						callee = obj.callee ? obj.callee.name : name;

					for (var i = 0; i < obj ['super']; i ++){
						parent = classes [parent.parent];
						if (!parent)
							throwError ({}, Messages.WtfMan);
					}

					console.log (obj);

					obj.callee = memberExpression (
						callee === '@c' 
							? parent.name
							: memberExpression (
								memberExpression (
									parent.name, 
									'prototype'),
								callee),
						'call');

					obj.arguments = [ { type: 'ThisExpression' } ].concat (obj.arguments);
				}

				if (obj.type !== 'MemberExpression')
					for (var n in obj)
						obj [n] = update (obj [n], name, true) || obj [n];
			}
		}

	body 		= entry.data.expression.arguments [1].body.body;
	functions 	= body [body.length - 1].argument.properties.filter (lambda arg.key.name === '@o')[0].value.properties;

	if (entry.parent !== null)
		if (!classes [entry.parent]){
			throwError ({}, 'Parent class not found: ' + use);
		} else {
			setupClass (entry.parent);
			for (var n, v in classes [entry.parent].variables)
				if (!entry.variables [n])
					entry.variables [n] = v === 'private' ? 'locked' : v;
		}

	for (var use in-array entry.uses){
		if (!classes [use])
			throwError ({}, 'Using class not found: ' + use);
	}

	functions.forEach (lambda update (arg.value, arg.key.name));
	entry.done = true;
}

function setupClasses (){
	for (var name in classes)
		setupClass (name);

	return {
		before: [],
		after: []
	};
}

function resetClasses (){
	classes = undefined;
}
