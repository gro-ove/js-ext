/*
	Парсим запись вида «'string %0 %1' (a, b)», отдавая на выходе синтаксическое
	дерево, соответствующее коду «'string ' + a + ' ' + b»
*/
function parseComplexString (token){
	/*
		Разбиваем строку по знакам процента со следующими за ними числами. Числа
		ищем десятичные, из исключительно значащих цифр (то есть без «01»). Про-
		пускаем знаки «%», которым предшествует символ «\». Возвращаем массив из
		строк и чисел; пустые строки и числа, превышающие «max», исключаем.

		Если бы JavaScript умел в обратный просмотр, функция бы не понадобилась.
	*/
	function split (string, max){
		// Вычитаем единицу, так как искать надо лишь «%» с числом после.
		var length = string.length,
			index = 0, 
			previous = 0,
			character,
			temp,
			result = [];

		while (index < length)
			switch (string [index]){
				case '\\':
					if (string [index + 1] === '%'){
						if (previous < index)
							result.push (string.substring (previous, index));
						previous = index + 1;
					}

					index += 2;
					break;

				case '%':
					// Нашли «%», но это последний символ в строке. Пропускаем.
					if (index + 1 === length){
						index ++;
						break;
					}

					// Нашли ноль, а следом число - аналогично
					if (string [index + 1] === '0' && index + 2 < length && decimalDigit (string [index + 2])){
						index += 2;
						break;
					}

					// Обычный парсинг
					if (previous < index){
						result.push (string.substring (previous, index));
						previous = index;
					}

					index += 2;

					while (index < length && decimalDigit (string [index]))
						index ++;

					temp = +string.substring (previous + 1, index);

					if (temp < max)
						result.push (temp);

					previous = index;
					break;

				default:
					index ++;
			}

		if (previous < length)
			result.push (string.substring (previous, length));

		return result;
	}

	var string = stringLiteralValue (token),
		args = parseArguments (),
		splitted,
		result;

	// Со строкой короче двух символов возиться незачем
	if (string.length <= 1)
		return stringLiteral (token.value);

	splitted = split (string, args.length)
		// Конвертируем в куски AST-дерева
		.map (lambda 
			if (typeof arg === 'number'){
				var temp = args [arg];

				if (temp.type === Syntax.StringLiteral)
					return stringLiteral (temp.value);

				if (temp.type === Syntax.BooleanLiteral || temp.type === Syntax.NullLiteral 
					|| temp.type === Syntax.NumericLiteral || temp.type === Syntax.RegexpLiteral 
					|| temp.type === Syntax.UndefinedLiteral)
					return stringLiteralWithQuotes (temp.value);

				return temp;
			} else
				return stringLiteralWithQuotes (arg))
		// Склеиваем идущие подряд строки
		.filter (lambda (arg, index, array){
			// Если это не строка, оставляем
			if (arg.type !== Syntax.StringLiteral)
				return true;

			// Находим предыдущую строку
			for (var i = index - 1, previous; i >= 0 && array [i].type === Syntax.StringLiteral; i --)
				previous = array [i];

			if (previous){
				previous.value = stringLiteralWithQuotes (stringLiteralValue (previous) + stringLiteralValue (arg)).value;
				return false;
			} else
				return true;
		})
		// Выкидываем пустые строки, кроме первой
		.filter (lambda (arg, index, array){
			return arg.type !== Syntax.StringLiteral || index === 0 || !stringLiteralEmpty (arg);
		});

	if (splitted [0].type !== Syntax.StringLiteral && (splitted.length === 1 || splitted [1].type !== Syntax.StringLiteral))
		splitted = [ stringLiteral ('\'\'') ].concat (splitted);

	result = splitted [0];

	for (var i = 1; i < splitted.length; i ++)
		result = binaryExpression (result, '+', splitted [i]);

	return result;
}

function parsePrimaryExpression (){
	var token = lookahead ();

	switch (token.type){
		case Token.Identifier:
			lex ();
			return identifierFromToken (token);

		case Token.Keyword:
			if (token.value === 'this'){
				lex ();
				return thisExpressionFromToken (token);
			}

			if (token.value === 'function')
				return parseFunctionExpression ();

			if (token.value === 'lambda')
				return parseLambdaExpression ();

			break;

		case Token.StringLiteral:
			lex ();
			if (lookahead ().value === '(')
				return parseComplexString (token);
			else
				return stringLiteralFromToken (token);

		case Token.NumericLiteral:
			lex ();
			return numericLiteral (token.value);

		case Token.BooleanLiteral: 
			lex ();
			return booleanLiteral (token.value);

		case Token.NullLiteral: 
			lex ();
			return nullLiteral ();

		case Token.UndefinedLiteral: 
			lex ();
			return undefinedLiteral ();

		case Token.Punctuator:
			switch (token.value){
				case '[': 
					return parseArrayInitialiser ();

				case '{':
					return parseObjectInitialiser ();

				case '(':
					return parseGroupExpression ();

				case '/':
					lex ();
					return readRegexp ();
			}

		default:
			unexpected (token);
	}
}