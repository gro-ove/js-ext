	function parseComplexString (str){
		var temp,
			args = parseArguments ()/*.filter (lambda (arg, index, array)
				if (index && arg.type === Syntax.Literal && array [index - 1].type === Syntax.Literal){
					array [index - 1].value = String (array [index - 1].value) + String (arg.value);
					return false 
				} else
					return true)*/,
			splitted,
			result;

		if (args.length === 0 || str.length === 0)
			return literal (str);

		splitted = str
			.split (new RegExp ('%(' + args.map (lambda (a, i) i).join ('|') + ')', 'g'))
			.map (lambda (a, i) i % 2 ? args [+a] : a && literal (a))
			.filter (lambda arg);

		result = splitted [0];

		if (typeof result.value !== 'string')
			result = binaryExpression (literal (''), '+', result);

		for (var i = 1; i < splitted.length; i ++)
			result = binaryExpression (result, '+', splitted [i]);

		return result;
	}

	// 11.1 Primary Expressions
	
	function parsePrimaryExpression (){
		var token 	= lookahead (),
			type 	= token.type,
			temp;

		if (type === Token.Identifier)
			return identifier (lex ().value);

		if (type === Token.StringLiteral || type === Token.NumericLiteral){
			temp = lex ();
			return match ('(') ? parseComplexString (temp.value) : literal (temp);
		}

		if (type === Token.Keyword){
			if (matchKeyword ('this')){
				lex ();
				return thisExpression ();
			}

			if (matchKeyword ('function'))
				return parseFunctionExpression ();

			if (matchKeyword ('lambda'))
				return parseLambdaExpression ();
		}

		if (type === Token.BooleanLiteral){
			lex ();
			token.value = token.value === 'true';
			return literal (token);
		}

		if (type === Token.NullLiteral){
			lex ();
			token.value = null;
			return literal (token);
		}

		if (match ('['))
			return parseArrayInitialiser ();

		if (match ('{'))
			return parseObjectInitialiser ();

		if (match ('('))
			return parseGroupExpression ();

		if (match ('/') || match ('/='))
			return literal (scanRegExp ());

		return throwUnexpected (lex ());
	}