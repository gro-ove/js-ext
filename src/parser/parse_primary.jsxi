	function parseComplexString (str){
		var args = parseArguments (),
			splitted,
			result,
			temp;

		if (args.length === 0 || str.length === 0)
			return literal (str);

		splitted = str
			.split (new RegExp ('%(' + args.map (lambda (a, i) i).join ('|') + ')', 'g'))
			.map (lambda (a, i) i % 2 ? args [+a] : a && literal (a))
			.filter (lambda arg);

		result = splitted [0];
		for (var i = 1; i < splitted.length; i ++)
			result = binaryExpression (result, '+', splitted [i]);
		return result;
	}

	// 11.1 Primary Expressions
	
	function parsePrimaryExpression (){
		var token 	= lookahead (),
			type 	= token.type,
			temp;

		if (type === Token.Identifier)
			return identifier (lex ().value);

		if (type === Token.StringLiteral || type === Token.NumericLiteral){
			temp = lex ().value;
			return match ('(') ? parseComplexString (temp) : literal (temp);
		}

		if (type === Token.Keyword){
			if (matchKeyword ('this')){
				lex ();
				return { type: Syntax.ThisExpression };
			}

			if (matchKeyword ('function'))
				return parseFunctionExpression ();

			if (matchKeyword ('lambda'))
				return parseLambdaExpression ();
		}

		if (type === Token.BooleanLiteral){
			lex ();
			token.value = token.value === 'true';
			return literal (token);
		}

		if (type === Token.NullLiteral){
			lex ();
			token.value = null;
			return literal (token);
		}

		if (match ('['))
			return parseArrayInitialiser ();

		if (match ('{'))
			return parseObjectInitialiser ();

		if (match ('('))
			return parseGroupExpression ();

		if (match ('/') || match ('/='))
			return literal (scanRegExp ());

		return throwUnexpected (lex ());
	}