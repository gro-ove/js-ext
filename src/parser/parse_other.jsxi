	function parseNonComputedProperty (){
		var token = lex ();

		if (!isIdentifierName (token))
			throwUnexpected (token);

		return identifier (token.value);
	}

	function parseNonComputedMember (){
		expect ('.');
		return parseNonComputedProperty ();
	}

	function parseComputedMember (){
		expect ('[');
		var temp = parseExpression ();
		expect (']');

		return temp;
	}

	function parseNewExpression (){
		expectKeyword ('new');

		return newExpression (
			parseLeftHandSideExpression (), 
			match ('(') 
				? parseArguments () 
				: []
		);
	}

	function parseLeftHandSideExpressionAllowCall (){
		var temp = matchKeyword ('new') ? parseNewExpression () : parsePrimaryExpression (),
			token;

		while (match ('.') || match ('[') || match ('('))
			if (match ('(')){
				temp = callExpression (temp, parseArguments ());
			} else if (match ('[')){
				temp = memberExpression (temp, parseComputedMember (), true);
			} else {
				token = lookahead ();
				if (source [token.range [0] + 1] !== '.')
					temp = memberExpression (temp, parseNonComputedMember (), false);
				else
					break;
			}

		return temp;
	}

	function parseLeftHandSideExpression (){
		var temp = matchKeyword ('new') ? parseNewExpression () : parsePrimaryExpression ();

		while (match ('.') || match ('['))
			if (match ('['))
				temp = memberExpression (temp, parseComputedMember (), true);
			else 
				temp = memberExpression (temp, parseNonComputedMember (), false);

		return temp;
	}

	// 11.5 Multiplicative Operators

	function parseMultiplicativeExpression (){
		var temp = parseUnaryExpression ();

		while (match ('*') || match ('/') || match ('%'))
			temp = binaryExpression (temp, lex ().value, parseUnaryExpression ());

		return temp;
	}

	// 11.6 Additive Operators

	function parseAdditiveExpression (){
		var temp = parseMultiplicativeExpression ();

		while (match ('+') || match ('-'))
			temp = binaryExpression (temp, lex ().value, parseMultiplicativeExpression ());

		return temp;
	}

	// 11.7 Bitwise Shift Operators

	function parseShiftExpression (){
		var temp = parseAdditiveExpression ();

		while (match ('<<') || match ('>>') || match ('>>>'))
			temp = binaryExpression (temp, lex ().value, parseAdditiveExpression ());

		return temp;
	}

	// 11.8 Relational Operators

	function parseRelationalExpression (){
		var temp, previousAllowIn;

		previousAllowIn 	= state.allowIn;
		state.allowIn 		= true;
		temp 				= parseShiftExpression();

		while (match ('<') || match ('>') || match ('<=') || match ('>=') || previousAllowIn && matchKeyword ('in') || matchKeyword ('instanceof'))
			temp = binaryExpression (temp, lex ().value, parseShiftExpression ());

		state.allowIn 		= previousAllowIn;
		return temp;
	}

	// 11.9 Equality Operators

	function parseEqualityExpression (){
		var temp = parseRelationalExpression ();

		while (match ('==') || match ('!=') || match ('===') || match ('!=='))
			temp = binaryExpression (temp, lex ().value, parseRelationalExpression ());

		return temp;
	}

	// 11.10 Binary Bitwise Operators

	function parseBitwiseANDExpression (){
		var temp = parseEqualityExpression ();

		while (match ('&')){
			lex ();
			temp = binaryExpression (temp, '&', parseEqualityExpression ());
		}

		return temp;
	}

	function parseBitwiseXORExpression (){
		var temp = parseBitwiseANDExpression ();

		while (match ('^')){
			lex ();
			temp = binaryExpression (temp, '^', parseBitwiseANDExpression ());
		}

		return temp;
	}

	function parseBitwiseORExpression (){
		var temp = parseBitwiseXORExpression ();

		while (match ('|')){
			lex ();
			temp = binaryExpression (temp, '|', parseBitwiseXORExpression ());
		}

		return temp;
	}

	// 11.11 Binary Logical Operators

	function parseLogicalANDExpression (){
		var temp = parseBitwiseORExpression ();

		while (match ('&&')){
			lex ();
			temp = logicalExpression (temp, '&&', parseBitwiseORExpression ());
		}

		return temp;
	}

	function parseLogicalORExpression (){
		var temp = parseLogicalANDExpression ();

		while (match ('||')){
			lex ();
			temp = logicalExpression (temp, '||', parseLogicalANDExpression ());
		}

		return temp;
	}

	// 11.12 Conditional Operator

	function parseConditionalExpression (){
		var temp, previousAllowIn, consequent;

		temp = parseLogicalORExpression ();

		if (match ('?')){
			lex ();
			previousAllowIn 	= state.allowIn;
			state.allowIn 		= true;
			consequent 			= parseAssignmentExpression ();
			state.allowIn 		= previousAllowIn;
			expect (':');

			temp = conditionalExpression (temp, consequent, parseAssignmentExpression ());
		}

		return temp;
	}
	
	function parseAssignmentExpression (){
		var token, temp;

		token 	= lookahead ();
		temp 	= parseConditionalExpression ();

		if (matchAssign ()){
			if (!isLeftHandSide (temp))
				throwError ({}, Messages.InvalidLHSInAssignment);
			temp = assignmentExpression (temp, lex ().value, parseAssignmentExpression ());
		}

		return temp;
	}

	// 11.14 Comma Operator

	function parseExpression (){
		var temp = parseAssignmentExpression ();

		if (!state.preventSequence && match (',')){
			temp = sequenceExpression ([ temp ]);

			while (index < length){
				if (!match (',')) 
					break;
				lex ();
				temp.expressions.push (parseAssignmentExpression ());
			}
		}

		return temp;
	}