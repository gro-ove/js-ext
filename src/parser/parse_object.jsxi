	function parsePropertyFunction (param, first)
		return {
			type: 			Syntax.FunctionExpression,
			id: 			null,
			params: 		param,
			body: 			parseFunctionElements ()
		};

	function parseObjectPropertyKey (){
		var token = lex ();

		if (token.type === Token.StringLiteral)
			return stringLiteralFromToken (token);
		else
			return identifierFromToken (token);
	}

	function parseObjectProperty (){
		var token, key, id, param;

		token = lookahead ();

		if (token.type === Token.Identifier){
			id = parseObjectPropertyKey ();

			// Property Assignment: Getter and Setter.
			if (token.value === 'get' && !match (':')){
				key = parseObjectPropertyKey ();
				expect ('(');
				expect (')');
				return property (key, parsePropertyFunction ([]), 'get');
			} else if (token.value === 'set' && !match (':')){
				key = parseObjectPropertyKey();
				expect ('(');
				token = lookahead();

				if (token.type !== Token.Identifier){
					expect (')');
					unexpected (token);
					return property (key, parsePropertyFunction ([]), 'set');
				} else {
					param = [ parseIdentifier () ];
					expect (')');
					return property (key, parsePropertyFunction (param, token), 'set');
				}
			} else {
				expect (':');
				return property (id, parseAssignmentExpression ());
			}
		} else if (token.type === Token.EOF || token.type === Token.Punctuator){
			unexpected (token);
		} else {
			key = parseObjectPropertyKey ();
			expect (':');
			return property (key, parseAssignmentExpression ());
		}
	}

	function parseObjectContent (){
		var properties = [], property, name, kind, map = {}, comma = {};

		while (!match ('}')){
			if (properties.length){
				parseOptionalComma (comma);

				if (match ('}'))
					break;
			}

			property = parseObjectProperty ();

			name = property.key.type === Syntax.Identifier
				? property.key.name
				: String (property.key.value);

			kind = property.kind === 'init' 
				? PropertyKind.Data 
				: property.kind === 'get' 
					? PropertyKind.Get 
					: PropertyKind.Set;

			/*
				TODO: 
					'Object literal may not have data and accessor property with the same name'
					'Object literal may not have multiple get/set accessors with the same name'
			*/

			if (Object.prototype.hasOwnProperty.call (map, name)){
				throw new JsExtError ('NotImplementedError', 'Getters and setters', lookahead ());

				// if (map [name] === PropertyKind.Data){
				// 	if (kind !== PropertyKind.Data)
				// 		throwError ({}, Messages.AccessorDataProperty);
				// } else {
				// 	if (kind === PropertyKind.Data) 
				// 		throwError ({}, Messages.AccessorDataProperty);
				// 	else if (map [name] & kind) 
				// 		throwError ({}, Messages.AccessorGetSet);
				// }

				map [name] |= kind;
			} else
				map [name] = kind;

			properties.push (property);
		}

		return properties;
	}

	function parseObjectInitialiser (){
		expect ('{');
		var result = parseObjectContent ();
		expect ('}');
		
		return objectExpression (result);
	}