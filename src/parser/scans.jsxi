	function scanHexEscape (prefix){
		var i, len, ch, code = 0;

		len = prefix === 'u' ? 4 : 2;
		for (i = 0; i < len; ++ i){
			if (index < length && isHexDigit (source [index])){
				ch = source [index ++];
				code = code * 16 + '0123456789abcdef'.indexOf (ch.toLowerCase ());
			} else 
				return '';
		}
		return String.fromCharCode (code);
	}

	function scanIdentifier (){
		var start, id, restore;

		if (!isIdentifierStart (source [index]))
			return;

		start = index;
		id = source [index ++];

		if (id === 'i' && source.substr (index, 7) === 'n-array'){
			index += 7;
			
			return {
				type:           Token.Keyword,
				value:          'in-array',
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ start, index ]
			}
		}

		while (index < length){
			if (!isIdentifierPart (source [index]))
				break;
			id += source [index ++];
		}

		// There is no keyword or literal with only one character.
		// Thus, it must be an identifier.
		if (id.length === 1)
			return {
				type:           Token.Identifier,
				value:          id,
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ start, index ]
			};

		if (isKeyword (id))
			return {
				type:           Token.Keyword,
				value:          id,
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ start, index ]
			};

		// 7.8.1 Null Literals
		if (id === 'null')
			return {
				type:           Token.NullLiteral,
				value:          id,
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ start, index ]
			};

		// 7.8.2 Boolean Literals
		if (id === 'true' || id === 'false')
			return {
				type:           Token.BooleanLiteral,
				value:          id,
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ start, index ]
			};

		return {
			type:           Token.Identifier,
			value:          id,
			lineNumber:     lineNumber,
			lineStart:      lineStart,
			range:          [ start, index ]
		};
	}

	function scanPunctuator (){
		var start = index,
			ch1 = source[index],
			ch2,
			ch3,
			ch4;

		// Check for most common single-character punctuators.
		if (ch1 === ';' || ch1 === '{' || ch1 === '}' || ch1 === ',' || ch1 === '(' || ch1 === ')'){
			++ index;
			return {
				type:           Token.Punctuator,
				value:          ch1,
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ start, index ]
			};
		}

		// Dot (.) can also start a floating-point number, hence the need
		// to check the next character.
		ch2 = source [index + 1];
		if (ch1 === '.' && !isDecimalDigit (ch2))
			return {
				type:           Token.Punctuator,
				value:          source [index ++],
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ start, index ]
			};

		// Peek more characters.
		ch3 = source [index + 2];
		ch4 = source [index + 3];

		// 4-character punctuator: >>>=
		if (ch1 === '>' && ch2 === '>' && ch3 === '>' && ch4 === '='){
			index += 4;
			return {
				type:           Token.Punctuator,
				value:          '>>>=',
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ start, index ]
			};
		}

		// 3-character punctuators: === !== >>> <<= >>=
		if (ch1 === '=' && ch2 === '=' && ch3 === '=' ||
			ch1 === '!' && ch2 === '=' && ch3 === '=' ||
			ch1 === '>' && ch2 === '>' && ch3 === '>' ||
			ch1 === '<' && ch2 === '<' && ch3 === '=' ||
			ch1 === '>' && ch2 === '>' && ch3 === '='){
			index += 3;
			return {
				type:           Token.Punctuator,
				value:          ch1 + ch2 + ch3,
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ start, index ]
			};
		}

		// 2-character punctuators: <= >= == != ++ -- << >> && || += -= *= %= &= |= ^= /=
		if (ch2 === '=' && '<>=!+-*%&|^/'.indexOf (ch1) >= 0 ||
			ch1 === ch2 && '+-<>&|'.indexOf (ch1) >= 0){
			index += 2;
			return {
				type:           Token.Punctuator,
				value:          ch1 + ch2,
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ start, index ]
			};
		}

		// The remaining 1-character punctuators.
		if ('[]<>+-*%&|^!~?:=/'.indexOf (ch1) >= 0)
			return {
				type:           Token.Punctuator,
				value:          source [index ++],
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ start, index ]
			};
	}

	function scanNumericLiteral (){
		var number, start, ch;

		ch = source [index];
		console.assert (isDecimalDigit (ch) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');

		start = index;
		number = '';

		if (ch !== '.'){
			number = source [index ++];
			ch = source [index];

			// Hex number starts with '0x'.
			// Octal number starts with '0'.
			if (number === '0'){
				if (ch === 'x' || ch === 'X'){
					number += source [index ++];
					while (index < length){
						ch = source [index];
						if (!isHexDigit (ch))
							break;
						number += source [index ++];
					}

					// only 0x
					if (number.length <= 2)
						throwError({}, Messages.UnexpectedToken, 'ILLEGAL');

					if (index < length){
						ch = source [index];
						if (isIdentifierStart (ch))
							throwError ({}, Messages.UnexpectedToken, 'ILLEGAL');
					}

					return {
						type:           Token.NumericLiteral,
						value:          parseInt (number, 16),
						lineNumber:     lineNumber,
						lineStart:      lineStart,
						range:          [ start, index ]
					};
				} else if (isOctalDigit (ch)){
					number += source [index ++];
					while (index < length){
						ch = source [index];
						if (!isOctalDigit (ch))
							break;
						number += source [index ++];
					}

					if (index < length){
						ch = source [index];
						if (isIdentifierStart (ch) || isDecimalDigit (ch))
							throwError ({}, Messages.UnexpectedToken, 'ILLEGAL');
					}

					return {
						type:           Token.NumericLiteral,
						value:          parseInt (number, 8),
						octal:          true,
						lineNumber:     lineNumber,
						lineStart:      lineStart,
						range:          [ start, index ]
					};
				}

				// decimal number starts with '0' such as '09' is illegal.
				if (isDecimalDigit (ch)) 
					throwError ({}, Messages.UnexpectedToken, 'ILLEGAL');
			}

			while (index < length){
				ch = source [index];
				if (!isDecimalDigit (ch)) 
					break;
				number += source [index ++];
			}
		}

		if (ch === '.'){
			number += source [index ++];
			while (index < length){
				ch = source [index];
				if (!isDecimalDigit (ch))
					break;
				number += source [index ++];
			}
		}

		if (ch === 'e' || ch === 'E'){
			number += source [index ++];

			ch = source [index];
			if (ch === '+' || ch === '-')
				number += source [index ++];

			ch = source [index];
			if (isDecimalDigit (ch)){
				number += source [index++];
				while (index < length){
					ch = source [index];
					if (!isDecimalDigit (ch))
						break;
					number += source [index ++];
				}
			} else {
				ch = 'character ' + ch;
				if (index >= length)
					ch = '<end>';
				throwError ({}, Messages.UnexpectedToken, 'ILLEGAL');
			}
		}

		if (index < length){
			ch = source [index];
			if (isIdentifierStart (ch)) 
				throwError ({}, Messages.UnexpectedToken, 'ILLEGAL');
		}

		return {
			type:           Token.NumericLiteral,
			value:          parseFloat (number),
			lineNumber:     lineNumber,
			lineStart:      lineStart,
			range:          [ start, index ]
		};
	}

	function scanStringLiteral (){
		var str = '', quote, start, ch, code, unescaped, restore, octal = false;

		quote = source [index];
		console.assert (quote === '\'' || quote === '"' || quote === '`', 'String literal must starts with a quote');

		start = index;
		++ index;

		if (quote === '`'){
			while (index < length){
				ch = source [index ++];

				if (ch === quote){
					quote = '';
					break;
				} else if (ch === '\\' && source [index] === '`'){
					index ++;
					str += '`';
				} else
					str += ch;
			}
		} else {
			while (index < length){
				ch = source [index ++];

				if (ch === quote){
					quote = '';
					break;
				} else if (ch === '\\'){
					ch = source [index ++];
					if (!isLineTerminator (ch)){
						switch (ch){
							case 'n':
								str += '\n';
								break;
							case 'r':
								str += '\r';
								break;
							case 't':
								str += '\t';
								break;
							case 'u':
							case 'x':
								restore = index;
								unescaped = scanHexEscape (ch);
								if (unescaped){
									str += unescaped;
								} else {
									index = restore;
									str += ch;
								}
								break;
							case 'b':
								str += '\b';
								break;
							case 'f':
								str += '\f';
								break;
							case 'v':
								str += '\x0B';
								break;

							default:
								if (isOctalDigit (ch)){
									code = '01234567'.indexOf (ch);

									// \0 is not octal escape sequence
									if (code !== 0) 
										octal = true;

									if (index < length && isOctalDigit (source [index])) {
										octal = true;
										code = code * 8 + '01234567'.indexOf (source [index ++]);

										// 3 digits are only allowed when string starts
										// with 0, 1, 2, 3
										if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit (source [index]))
											code = code * 8 + '01234567'.indexOf (source [index ++]);
									}

									str += String.fromCharCode (code);
								} else 
									str += ch;
								break;
						}
					} else {
						++ lineNumber;
						if (ch ===  '\r' && source [index] === '\n') 
							++ index;
					}
				} else if (isLineTerminator (ch)){
					break;
				} else 
					str += ch;
			}
		}

		if (quote !== '') 
			throwError ({}, Messages.UnexpectedToken, 'ILLEGAL');

		return {
			type:           Token.StringLiteral,
			value:          str,
			octal:          octal,
			lineNumber:     lineNumber,
			lineStart:      lineStart,
			range:          [ start, index ]
		};
	}

	function scanRegExp (){
		var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;

		buffer = null;
		skipComment();

		start = index;
		ch = source [index];
		console.assert (ch === '/', 'Regular expression literal must start with a slash');
		str = source [index ++];

		while (index < length){
			ch = source [index ++];
			str += ch;
			if (ch === '\\'){
				ch = source [index ++];
				// ECMA-262 7.8.5
				if (isLineTerminator (ch))
					throwError ({}, Messages.UnterminatedRegExp);
				str += ch;
			} else if (classMarker){
				if (ch === ']')
					classMarker = false;
			} else if (ch === '/'){
				terminated = true;
				break;
			} else if (ch === '['){
				classMarker = true;
			} else if (isLineTerminator (ch))
				throwError ({}, Messages.UnterminatedRegExp);
		}

		if (!terminated)
			throwError ({}, Messages.UnterminatedRegExp);

		// Exclude leading and trailing slash.
		pattern = str.substr (1, str.length - 2);

		flags = '';
		while (index < length){
			ch = source [index];
			if (!isIdentifierPart (ch))
				break;

			++ index;
			if (ch === '\\' && index < length){
				ch = source [index];
				if (ch === 'u'){
					++ index;
					restore = index;
					ch = scanHexEscape ('u');
					if (ch){
						flags += ch;
						str += '\\u';
						for (; restore < index; ++ restore)
							str += source [restore];
					} else {
						index = restore;
						flags += 'u';
						str += '\\u';
					}
				} else 
					str += '\\';
			} else {
				flags += ch;
				str += ch;
			}
		}

		try
			value = new RegExp (pattern, flags);
		catch 
			throwError ({}, Messages.InvalidRegExp);

		return {
			literal: 	str,
			value: 		value,
			range: 		[ start, index ]
		};
	}