	function sliceSource (from, to) 
		return source.slice (from, to);

	function isDecimalDigit (ch)
		return '0123456789'.indexOf (ch) >= 0;

	function isHexDigit (ch)
		return '0123456789abcdefABCDEF'.indexOf (ch) >= 0;

	function isOctalDigit (ch)
		return '01234567'.indexOf (ch) >= 0;

	function isIdentifierName (token)
		return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;

	var newIdentifier = (lambda {
		function busy (str)
			return source.indexOf (str) !== -1;

		var lastIdentifier = 0;

		return lambda {
			var str;

			if (arg){
				if (busy (arg))
					for (var i = 0; busy (str = arg + (lastIdentifier ++).toString (32)); i ++);
				else 
					str = arg;
			} else 
				while (busy (str = '_' + (lastIdentifier ++).toString (32)));

			return str;
		}
	})();

	function saveAll ()
		return $.extend ({}, {
			source: 		source,
			index: 			index,
			lineNumber: 	lineNumber,
			lineStart: 		lineStart,
			length: 		length,
			buffer: 		buffer,
			state: 		 	state,
			options: 		options,
			helpers: 		helpers
		});

	function restoreAll (obj){
		source  			= obj.source;
		index  				= obj.index;
		lineNumber  		= obj.lineNumber;
		lineStart  			= obj.lineStart;
		length  			= obj.length;
		buffer  			= obj.buffer;
		state  		 		= obj.state;
		options  			= obj.options;
		helpers  			= obj.helpers;
	}

	function attemptTo (firstFn, secondFn, forceSecond)
		if (forceSecond){
			return secondFn ();
		} else {
			saved = saveAll ();

			try {
				return firstFn ();
			} catch {
				if (e instanceof Error && /^Unexpected .+? \[.+?\:\d+\]$/.test (e.message)){
					restoreAll (saved);
					return secondFn ();
				} else
					throw e;
			}
		}

	function advance (){
		var ch, token;

		skipComment ();

		if (index >= length) 
			return {
				type:           Token.EOF,
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ index, index ]
			};

		token = scanPunctuator ();
		if (token !== undefined)
			return token;

		ch = source [index];
		if (ch === '\'' || ch === '"' || ch === '`') 
			return scanStringLiteral ();

		if (ch === '.' || isDecimalDigit (ch)) 
			return scanNumericLiteral ();

		token = scanIdentifier ();
		if (token !== undefined)
			return token;

		throwError ({}, Messages.UnexpectedToken, 'ILLEGAL');
	}

	function lex (){
		var token;

		if (buffer){
			index       = buffer.range [1];
			lineNumber  = buffer.lineNumber;
			lineStart   = buffer.lineStart;
			token       = buffer;
			buffer      = null;
			return token;
		}

		buffer = null;
		return advance ();
	}

	function lookahead (){
		var pos, line, start;

		if (buffer !== null)
			return buffer;

		pos         = index;
		line        = lineNumber;
		start       = lineStart;
		buffer      = advance ();
		index       = pos;
		lineNumber  = line;
		lineStart   = start;

		return buffer;
	}

	// Return true if there is a line terminator before the next token.
	function peekLineTerminator (){
		var pos, line, start, found;

		pos         = index;
		line        = lineNumber;
		start       = lineStart;

		skipComment ();

		found       = lineNumber !== line;
		index       = pos;
		lineNumber  = line;
		lineStart   = start;

		return found;
	}

	function expect (value){
		var token = lex ();
		if (token.type !== Token.Punctuator || token.value !== value) 
			throwUnexpected (token);
	}

	function expectKeyword (keyword){
		var token = lex ();
		if (token.type !== Token.Keyword || token.value !== keyword) 
			throwUnexpected (token);
	}

	function match (value){
		var token = lookahead ();
		return token.type === Token.Punctuator && token.value === value;
	}

	function matchKeyword (keyword){
		var token = lookahead ();
		return token.type === Token.Keyword && token.value === keyword;
	}

	function matchKeywordAndLex (keyword){
		var token = lookahead (),
			result = token.type === Token.Keyword && token.value === keyword;
		if (result)
			lex ();
		return result;
	}

	function matchAssign (){
		var token = lookahead (),
			op = token.value;

		if (token.type !== Token.Punctuator)
			return false;

		return op === '=' ||
			   op === '*=' ||
			   op === '/=' ||
			   op === '%=' ||
			   op === '+=' ||
			   op === '-=' ||
			   op === '<<=' ||
			   op === '>>=' ||
			   op === '>>>=' ||
			   op === '&=' ||
			   op === '^=' ||
			   op === '|=';
	}

	function consumeSemicolon (){
		var token, line;

		// Catch the very common case first.
		if (source [index] === ';'){
			lex ();
			return;
		}

		line = lineNumber;
		skipComment ();
		if (lineNumber !== line)
			return;

		if (match (';')){
			lex ();
			return;
		}

		if (!state.preventSequence){
			token = lookahead ();
			if (token.type !== Token.EOF && !match ('}'))
				throwUnexpected (token);
		}
	}

	function isLeftHandSide (expr)
		return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;