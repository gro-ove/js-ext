	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.

	function assert (condition, message)
		if (!condition)
			throw new Error ('ASSERT: ' + message);

	function sliceSource (from, to) 
		return source.slice (from, to);

	function isDecimalDigit (ch)
		return '0123456789'.indexOf (ch) >= 0;

	function isHexDigit (ch)
		return '0123456789abcdefABCDEF'.indexOf (ch) >= 0;

	function isOctalDigit (ch)
		return '01234567'.indexOf (ch) >= 0;

	function isIdentifierName (token)
		return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;

	var newIdentifier = (lambda {
		function busy (str)
			return source.indexOf (str) !== -1;

		var lastIdentifier = 0;

		return lambda {
			var str;

			if (arg){
				if (busy (arg))
					for (var i = 0; busy (str = arg + (lastIdentifier ++).toString (32)); i ++);
				else 
					str = arg;
			} else 
				while (busy (str = '_' + (lastIdentifier ++).toString (32)));

			return str;
		}
	})();

	var $ = { extend: (function (){
		// Taken from Zepto

		function extend (target, source, deep)
			for (var key, value in source)
				if (deep && (typeof value === 'object' || value instanceof Array)){
					if (typeof value === 'object' && typeof target [key] !== 'object')
						target [key] = {};
					else if (value instanceof Array && !(target [key] instanceof Array))
						target [key] = [];

					extend (target [key], value, deep);
				} else if (value !== undefined) 
					target [key] = value;

		return function (target){
			var deep, 
				args = Array.prototype.slice.call (arguments, 1);

			if (typeof target == 'boolean'){
				deep = target;
				target = args.shift ();
			}

			args.forEach (lambda extend (target, arg, deep));
			return target;
		}
	})() };

	function clone (obj){
		return $.extend (true, {}, obj);
	}

	function saveAll ()
		return clone ({
			index: 			index,
			lineNumber: 	lineNumber,
			lineStart: 		lineStart,
			buffer: 		buffer
		});

	function restoreAll (obj){
		index 			= obj.index;
		lineNumber 		= obj.lineNumber;
		lineStart 		= obj.lineStart;
		buffer 			= obj.buffer;
	}

	function advance (){
		var ch, token;

		skipComment ();

		if (index >= length) 
			return {
				type:           Token.EOF,
				lineNumber:     lineNumber,
				lineStart:      lineStart,
				range:          [ index, index ]
			};

		token = scanPunctuator ();
		if (typeof token !== 'undefined')
			return token;

		ch = source [index];
		if (ch === '\'' || ch === '"' || ch === '`') 
			return scanStringLiteral ();

		if (ch === '.' || isDecimalDigit (ch)) 
			return scanNumericLiteral ();

		token = scanIdentifier ();
		if (typeof token !== 'undefined')
			return token;

		throwError ({}, Messages.UnexpectedToken, 'ILLEGAL');
	}

	function lex (){
		var token;

		if (buffer){
			index       = buffer.range [1];
			lineNumber  = buffer.lineNumber;
			lineStart   = buffer.lineStart;
			token       = buffer;
			buffer      = null;
			return token;
		}

		buffer = null;
		return advance ();
	}

	function lookahead (){
		var pos, line, start;

		if (buffer !== null)
			return buffer;

		pos         = index;
		line        = lineNumber;
		start       = lineStart;
		buffer      = advance ();
		index       = pos;
		lineNumber  = line;
		lineStart   = start;

		return buffer;
	}

	// Return true if there is a line terminator before the next token.
	function peekLineTerminator (){
		var pos, line, start, found;

		pos         = index;
		line        = lineNumber;
		start       = lineStart;

		skipComment ();

		found       = lineNumber !== line;
		index       = pos;
		lineNumber  = line;
		lineStart   = start;

		return found;
	}

	// Expect the next token to match the specified punctuator.
	// If not, an exception will be thrown.
	function expect (value){
		var token = lex ();
		if (token.type !== Token.Punctuator || token.value !== value) 
			throwUnexpected (token);
	}

	// Expect the next token to match the specified keyword.
	// If not, an exception will be thrown.
	function expectKeyword (keyword){
		var token = lex ();
		if (token.type !== Token.Keyword || token.value !== keyword) 
			throwUnexpected (token);
	}

	// Return true if the next token matches the specified punctuator.
	function match (value){
		var token = lookahead ();
		return token.type === Token.Punctuator && token.value === value;
	}

	// Return true if the next token matches the specified keyword
	function matchKeyword (keyword){
		var token = lookahead ();
		return token.type === Token.Keyword && token.value === keyword;
	}

	// Return true if the next token is an assignment operator
	function matchAssign (){
		var token = lookahead (),
			op = token.value;

		if (token.type !== Token.Punctuator)
			return false;

		return op === '=' ||
			   op === '*=' ||
			   op === '/=' ||
			   op === '%=' ||
			   op === '+=' ||
			   op === '-=' ||
			   op === '<<=' ||
			   op === '>>=' ||
			   op === '>>>=' ||
			   op === '&=' ||
			   op === '^=' ||
			   op === '|=';
	}

	function consumeSemicolon (){
		var token, line;

		// Catch the very common case first.
		if (source [index] === ';'){
			lex ();
			return;
		}

		line = lineNumber;
		skipComment ();
		if (lineNumber !== line)
			return;

		if (match (';')){
			lex ();
			return;
		}

		if (!state.preventSequence){
			token = lookahead ();
			if (token.type !== Token.EOF && !match ('}'))
				throwUnexpected (token);
		}
	}

	// Return true if provided expression is LeftHandSideExpression
	function isLeftHandSide (expr)
		return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;