var ch0 = '0'.charCodeAt (0),
	ch1 = '1'.charCodeAt (0),
	ch7 = '7'.charCodeAt (0),
	ch9 = '9'.charCodeAt (0),
	cha = 'a'.charCodeAt (0),
	chf = 'f'.charCodeAt (0),
	chz = 'z'.charCodeAt (0),
	chA = 'A'.charCodeAt (0),
	chF = 'F'.charCodeAt (0),
	chZ = 'Z'.charCodeAt (0),
	ch$ = '$'.charCodeAt (0),
	ch_ = '_'.charCodeAt (0);

function decimalDigit (c){
	c = c.charCodeAt (0);
	return ch0 <= c && c <= ch9;
}

function hexDigit (c){
	c = c.charCodeAt (0);
	return ch0 <= c && c <= ch9 || cha <= c && c <= chf || chA <= c && c <= chF;
}

function identifierStart (c){
	c = c.charCodeAt (0);
	return cha <= c && c <= chz || chA <= c && c <= chZ || c === ch$ || c === ch_;
}

function identifierPart (c){
	c = c.charCodeAt (0);
	return cha <= c && c <= chz || chA <= c && c <= chZ || ch0 <= c && c <= ch9 || c === ch$ || c === ch_;
}

var lastIdentifier = 0;

function newIdentifier (){
	return '__' + (lastIdentifier ++).toString (32);
}

/* TODO: state? helpers? */
function saveAll ()
	return { index: index, lineNumber: lineNumber, buffer: buffer };

function restoreAll (obj){
	index 		= obj.index;
	lineNumber 	= obj.lineNumber;
	buffer 		= obj.buffer;
}

function attemptTo (firstFn, secondFn, forceSecond)
	if (forceSecond){
		return typeof secondFn === 'function' ? secondFn () : secondFn;
	} else {
		saved = saveAll ();

		try 
			return typeof firstFn === 'function' ? firstFn () : firstFn;
		catch
			if (e instanceof Error && /^Unexpected .+? \[.+?\:\d+\]$/.test (e.message)){
				restoreAll (saved);
				return typeof secondFn === 'function' ? secondFn () : secondFn;
			} else
				throw e;
	}

function advance (){
	skipComments ();

	if (index >= length) 
		return { type: Token.EOF, lineNumber: lineNumber, range: [ index, index ] };

	var token = readPunctuator ();
	if (token !== undefined)
		return token;

	var character = source [index];
	if (character === '\'' || character === '"') 
		return readStringLiteral ();

	if (character === '`')
		return readMultilineString ();

	if (character === '.' || decimalDigit (character)) 
		return readNumericLiteral ();

	token = readIdentifier ();
	if (token !== undefined)
		return token;

	unexpected ();
}

function lex ()
	if (buffer){
		index = buffer.range [1];
		lineNumber = buffer.lineNumber;

		var token = buffer;
		buffer = null;
		return token;
	} else {
		buffer = null;
		return advance ();
	}

function lookahead (){
	if (buffer === null){
		var currentIndex = index,
			currentLineNumber = lineNumber;

		buffer = advance ();

		index = currentIndex;
		lineNumber = currentLineNumber;
	}
	
	return buffer;
}

function peekLineTerminator (){
	var pos = index, 
		line = lineNumber,
		found;

	skipComments ();

	found       = lineNumber !== line;
	index       = pos;
	lineNumber  = line;

	return found;
}

function expect (value){
	var token = lex ();
	if (token.type !== Token.Punctuator || token.value !== value) 
		unexpected (token);
}

function expectKeyword (keyword){
	var token = lex ();
	if (token.type !== Token.Keyword || token.value !== keyword) 
		unexpected (token);
}

function match (value){
	var token = lookahead ();
	return token.type === Token.Punctuator && token.value === value;
}

function matchKeyword (keyword){
	var token = lookahead ();
	return token.type === Token.Keyword && token.value === keyword;
}

function matchLex (value){
	var token = lookahead ();
	if (token.type === Token.Punctuator && token.value === value)
		return lex ();
	else
		return false;
}

function matchKeywordLex (keyword){
	var token = lookahead ();
	if (token.type === Token.Keyword && token.value === keyword)
		return lex ();
	else
		return false;
}

function consumeSemicolon (){
	if (source [index] === ';'){
		lex ();
		return;
	}

	var line = lineNumber;
	skipComments ();

	if (lineNumber !== line)
		return;

	if (matchLex (';'))
		return;

	if (!state.preventSequence && !match ('}') && lookahead ().type !== Token.EOF)
		unexpected (buffer);
}

function leftSideOnly (expression)
	if (!expression || expression.type !== Syntax.Identifier && expression.type !== Syntax.MemberExpression)
		throw new SyntaxError ('Invalid left-hand side', expression);
	else
		return expression;

function astEach (node, callback, result = []){
	if (typeof node.type === 'string'){
		var temp = callback (node);

		if (temp !== undefined)
			result.push (temp);
	}

	for (var key, child in node)
		if (child && (typeof child.type === 'string' || child instanceof Array))
			each (child, callback, result);

	return result;
}