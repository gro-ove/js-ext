	function markAll (obj, arg){
		if (obj.lineNumber)
			mark (obj, arg);

		for (var key, value in obj){
			if (value !== null && typeof value === 'object')
				markAll (value, arg);
		}

		return obj;
	}

	function mark (obj, arg)
		if (arg !== undefined){
			arg = mark (arg);
			obj.filename = arg.filename;
			obj.lineNumber = arg.lineNumber;
			obj.lineStart = arg.lineStart;
			obj.index = arg.index;
			return obj;
		} else if (index > length || obj && obj.filename){
			return obj || {};
		} else if (obj && obj.lineNumber){
			return $.extend (obj, { filename: options.filename });
		} else {
			return $.extend (obj || {}, {
				filename:     	options.filename,
				lineNumber: 	lineNumber,
				lineStart: 	 	lineStart,
				index: 		 	index
			});
		}

	function literal (value)
		return typeof value === 'object' && value !== null ? {
			type: 				Syntax.Literal,
			value: 				value.value,
			lineNumber: 		value.lineNumber,
			filename:     		options.filename
		} : mark ({
			type: 				Syntax.Literal,
			value: 				value
		})

	function identifier (arg)
		return typeof arg === 'string' ? mark ({
			type: 				Syntax.Identifier,
			name: 				arg
		}) : arg || null

	function property (key, value, kind = 'init')
		return mark ({
			type: 				Syntax.Property,
			key: 				identifier (key),
			value: 				identifier (value),
			kind: 				kind
		})

	function objectExpression (properties = [])
		return mark ({
			type: 				Syntax.ObjectExpression,
			properties: 		properties
		})

	function memberExpression (obj, property, computed = false)
		return mark ({
			type: 				Syntax.MemberExpression,
			computed: 			computed,
			object: 			identifier (obj),
			property: 			identifier (property)
		})

	function callExpression (name, arguments = []){
		if (name 
			&& name.type === Syntax.MemberExpression 
			&& name.property.type === Syntax.Identifier
			&& name.object.type === Syntax.MemberExpression 
			&& name.object.property.type === Syntax.Identifier 
			&& (name.property.name === 'call' || name.property.name === 'apply')){

			var obj = name.object.object;

			if (obj.type === Syntax.ArrayExpression && obj.elements.length === 0)
				name.object.object = memberExpression ('Array', 'prototype');

			else if (obj.type === Syntax.ObjectExpression && obj.properties.length === 0)
				name.object.object = memberExpression ('Object', 'prototype');
		}

		return mark ({
			type: 				Syntax.CallExpression,
			callee: 			identifier (name),
			arguments: 			arguments.map (identifier)
		})
	}

	function superExpression (name, args, level)
		return {
			type: 				Syntax.CallExpression,
			callee: 			identifier (name),
			arguments: 			args || null,
			'super': 			level || 1
		}

	function thisExpression ()
		return mark ({
			type: 				Syntax.ThisExpression
		})

	function arrayExpression (elements)
		return mark ({
			type:       		Syntax.ArrayExpression,
			elements:   		elements
		})

	function assignmentExpression (left, operator, right)
		return mark (typeof operator !== 'string' || operator [operator.length - 1] !== '=' ? {
			type: 				Syntax.AssignmentExpression,
			operator: 			'=',
			left: 				identifier (left),
			right: 				identifier (operator)
		} : {
			type: 				Syntax.AssignmentExpression,
			operator: 			operator,
			left: 				identifier (left),
			right: 				identifier (right)
		})

	function newExpression (callee, args = [])
		return mark ({
			type: 				Syntax.NewExpression,
			callee: 			identifier (callee),
			arguments: 			args.map (identifier)
		})

	function sequenceExpression (expressions)
		return mark ({
			type: 				Syntax.SequenceExpression,
			expressions: 		expressions
		})

	function conditionalExpression (test, trueExpression, falseExpression)
		return mark ({
			type: 				Syntax.ConditionalExpression,
			test: 				test,
			consequent: 		identifier (trueExpression),
			alternate: 			identifier (falseExpression)
		})

	function logicalExpression (left, operator, right)
		return mark ({
			type: 				Syntax.LogicalExpression,
			operator: 			operator,
			left: 				identifier (left),
			right: 				identifier (right)
		})

	function binaryExpression (left, operator, right)
		return mark ({
			type: 				Syntax.BinaryExpression,
			operator: 			operator,
			left: 				identifier (left),
			right: 				identifier (right)
		})

	function unaryExpression (argument, operator, prefix = false)
		return mark ({
			type: 				Syntax.UnaryExpression,
			operator: 			operator,
			argument: 			identifier (argument),
			prefix: 			prefix
		})

	function blockStatement (body = [], single)
		return body instanceof Array ? {
			type: 				Syntax.BlockStatement,
			body: 				body,
			single:         	single
		} : body

	function expressionStatement (expression)
		return mark ({
			type: 				Syntax.ExpressionStatement,
			expression: 		expression
		})

	function ifStatement (test, trueStatement, falseStatement = null)
		return mark ({
			type: 				Syntax.IfStatement,
			test: 				identifier (test),
			consequent: 		trueStatement,
			alternate: 			falseStatement
		})

	function whileStatement (test, body)
		return mark ({
			type: 				Syntax.WhileStatement,
			test: 				test,
			body: 				body
		})

	function doWhileStatement (body, test)
		return mark ({
			type: 				Syntax.DoWhileStatement,
			body: 				body,
			test: 				test
		})

	function doWhileStatement (body, test)
		return mark ({
			type: 				Syntax.DoWhileStatement,
			body: 				body,
			test: 				test
		})

	function forStatement (left, test, update, body)
		return mark ({
			type: 				Syntax.ForStatement,
			init: 				left,
			test: 				test,
			update: 			update,
			body: 				blockStatement (body)
		})

	function forInStatement (left, right, body)
		return mark ({
			type: 				Syntax.ForInStatement,
			left: 				left,
			right: 				right,
			body: 				body,
			each: 				false
		})

	function labeledStatement (label, statement)
		return mark ({
			type: 				Syntax.LabeledStatement,
			label: 				identifier (label),
			body: 				statement
		})

	function catchClause (param, body)
		return mark ({
			type:   			Syntax.CatchClause,
			param:  			identifier (param),
			body:  				body
		})

	function tryStatement (block, handlers, finalizer)
		return mark ({
			type:               Syntax.TryStatement,
			block:              block,
			guardedHandlers:    [],
			handlers:           handlers,
			finalizer:          finalizer
		})

	function returnStatement (arg)
		return mark ({
			type: 				Syntax.ReturnStatement,
			argument: 			identifier (arg)
		})

	function throwStatement (arg)
		return mark ({
			type: 				Syntax.ThrowStatement,
			argument: 			identifier (arg)
		})

	function breakStatement (arg)
		return mark ({
			type: 				Syntax.BreakStatement,
			label: 				identifier (arg)
		})

	function continueStatement (arg)
		return mark ({
			type: 				Syntax.ContinueStatement,
			label: 				identifier (arg)
		})

	function debuggerStatement ()
		return mark ({ 
			type: 				Syntax.DebuggerStatement
		})

	var tempId = 0;

	function functionExpression (name, params, body){
		if (name instanceof Array){
			body = params;
			params = name;
			name = null;
		}

		return {
			type: 				Syntax.FunctionExpression,
			id: 				identifier (name),
			params: 			params ? params.map (identifier) : [],
			defaults: 			[],
			body: 				blockStatement (body),
			rest: 				null,
			generator: 			false,
			expression: 		false,
			number: 			name + tempId ++
		};
	}

	function functionDeclaration (name, params = [], body)
		return {
			type: 				Syntax.FunctionDeclaration,
			id: 				identifier (name),
			params: 			params.map (identifier),
			defaults: 			[],
			body: 				blockStatement (body),
			rest: 				null,
			generator: 			false,
			expression: 		false,
			number: 			name + tempId ++
		}

	function variableDeclarator (name, value)
		return mark ({
			type: 				Syntax.VariableDeclarator,
			id: 				identifier (name),
			init: 				identifier (value)
		})

	function variableDeclaration (variables)
		return mark ({
			type: 				Syntax.VariableDeclaration,
			declarations: 		variables,
			kind: 				'var'
		})

	function program (elements, classes, initializations)
		return mark ({
			type: 				Syntax.Program,
			body: 				elements,
			classes: 			classes,
			initializations: 	initializations
		})