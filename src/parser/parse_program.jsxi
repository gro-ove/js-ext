function parseProgramElement (){
	var token = lookahead (), temp, result;

	switch (token.value){
		case 'public':
		case 'protected':
		case 'private':
		case 'static':
		case 'abstract':
		case 'class':
		case 'interface':
			return parseClassDeclaration ();

		case '(':
		case '{':
			if (options.initializationAllowed){
				saved = saveAll ();

				try {
					temp 			= token.value === '(' ? parseFunctionArguments () : [];
					result 			= expressionStatement (callExpression (functionExpression (null, temp, parseBlock ())));
					result.after 	= true;

					return result;
				} catch 
					restoreAll (saved);
			}
	}

	if (token.type !== Token.EOF) 
		return parseStatement ();
}

function parseProgram (){
	var sourceElements = [],
		initializations = [],
		temp;

	while (index < length) {
		temp = parseProgramElement ();
		if (temp === null)
			continue;
		if (temp === undefined) 
			break;
		sourceElements.push (temp);
	}

	state.parsingComplete = true;

	if (options.insertReturn && sourceElements.length === 1)
		setReturnStatement (sourceElements [0]);

	sourceElements = sourceElements.filter (lambda 
		if (arg.after){
			initializations.push (arg);
			return false;
		} else 
			return true);

	return program (sourceElements, state.classes, initializations);	
}
