	// 12 Statements
	
	function parseStatement (){
		var token = lookahead (), expr, saved, result;

		if (token.type === Token.EOF)
			throwUnexpected (token);

		if (token.type === Token.Punctuator)
			switch (token.value){
				case ';':
					return mark (parseEmptyStatement (), token);
				case '{':
					try {
						saved = saveAll ();
						expr = parseObjectInitialiser ();
						consumeSemicolon ();
						return expressionStatement (expr);
					} catch {
						restoreAll (saved);
						return parseBlock ();
					}
				case '(':
					return mark (parseExpressionStatement (), token);
				case '.':
					if (source [token.range [0] + 1] === '.' && source [token.range [0] + 2] === '.'){
						lex ();
						lex ();
						lex ();

						expr = callExpression (
							memberExpression ('console', 'warn'), 
							[ literal ('Not implemented at ' + lineNumber + ' line of ' + options.filename) ]);

						return mark (expressionStatement (expr), token);
					}
			}

		if (token.type === Token.Keyword){
			switch (token.value){
				case 'function':
					return parseFunctionDeclaration ();

				case 'if':
					result = parseIfStatement ();
					break;

				case 'var':
					result = parseVariableStatement ();
					break;

				case 'do':
					result = parseDoWhileStatement ();
					break;

				case 'for':
					result = parseForStatement ();
					break;

				case 'return':
					result = parseReturnStatement ();
					break;

				case 'switch':
					result = parseSwitchStatement ();
					break;

				case 'throw':
					result = parseThrowStatement ();
					break;

				case 'try':
					result = parseTryStatement ();
					break;

				case 'while':
					result = parseWhileStatement ();
					break;

				case 'with':
					result = parseWithStatement ();
					break;

				case 'break':
					result = parseBreakStatement ();
					break;

				case 'continue':
					result = parseContinueStatement ();
					break;

				case 'debugger':
					result = parseDebuggerStatement ();
					break;

				default:
					break;
			}

			if (result)
				return mark (result, token);
		}

		expr = parseExpression ();

		// 12.12 Labelled Statements

		if (expr.type === Syntax.Identifier && match (':')){
			lex ();

			return labeledStatement (expr, parseStatement ());
		}

		consumeSemicolon ();

		return mark (expressionStatement (expr), token);
	}