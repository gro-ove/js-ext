	// 12.6 Iteration Statements

	function parseDoWhileStatement (){
		var body, test;

		expectKeyword ('do');

		body = parseStatement ();

		expectKeyword ('while');
		expect ('(');

		test = parseExpression ();

		expect (')');

		if (match (';'))
			lex ();

		return {
			type: 	Syntax.DoWhileStatement,
			body: 	body,
			test: 	test
		};
	}

	function parseWhileStatement (){
		var test, body;

		expectKeyword ('while');
		expect ('(');

		test = parseExpression ();

		expect (')');

		body = parseStatement ();

		return {
			type: 	Syntax.WhileStatement,
			test: 	test,
			body: 	body
		};
	}

	function parseForVariableDeclaration (){
		var token = lex ();

		return {
			type: 			Syntax.VariableDeclaration,
			declarations: 	parseVariableDeclarationList(),
			kind: 			token.value
		};
	}

	function parseForStatement (){
		var init, test, update, left, right, body, temp;

		init = test = update = null;

		expectKeyword ('for');
		expect ('(');

		if (match (';')){
			lex ();
		} else {
			if (matchKeyword ('var')){
				state.allowIn 	= false;
				init			= parseForVariableDeclaration ();
				state.allowIn 	= true;

				if (init.declarations.length <= 2 && matchKeyword ('in')){
					lex ();
					left 	= init;
					right 	= parseExpression ();
					init 	= null;
				}
			} else {
				state.allowIn 	= false;
				init 			= parseExpression ();
				state.allowIn 	= true;

				if (matchKeyword ('in')){
					// LeftHandSideExpression
					if (!isLeftHandSide (init) && (init.type != 'SequenceExpression' || init.expressions.length != 2))
						throwErrorTolerant ({}, Messages.InvalidLHSInForIn);

					lex ();
					left 	= init;
					right 	= parseExpression();
					init 	= null;
				}
			}

			if (typeof left === 'undefined')
				expect (';');
		}

		if (typeof left === 'undefined'){
			if (!match (';'))
				test = parseExpression ();

			expect (';');

			if (!match (')'))
				update = parseExpression ();
		}

		expect (')');
		body = parseStatement ();

		if (typeof left === 'undefined'){
			return {
				type: 		Syntax.ForStatement,
				init: 		init,
				test: 		test,
				update: 	update,
				body: 		body
			};
		} else if (left.type === 'VariableDeclaration' && left.declarations.length === 2){
			temp = body;

			body = {
				type: 'BlockStatement',
				body: [
					{
						type: 'VariableDeclaration',
						declarations: [ left.declarations [1] ],
						kind: 'var'
					}
				]
			};

			body.body [0].declarations [0].init = {
				type: 'MemberExpression',
				computed: true,
				object: right,
				property: left.declarations [0].id
			};

			if (temp.type === 'BlockStatement')
				body.body = body.body.concat (temp.body);
			else
				body.body.push (temp);

			left.declarations.length = 1;
		} else if (left.type === 'SequenceExpression' && left.expressions.length === 2){
			temp = body;

			body = {
				type: 'BlockStatement',
				body: [
					{
						type: 'ExpressionStatement',
						expression: {
							type: 'AssignmentExpression',
							operator: '=',
							left: left.expressions [1],
							right: {
								type: 'MemberExpression',
								computed: true,
								object: right,
								property: left.expressions [0]
							}
						}
					}
				]
			};

			if (temp.type === 'BlockStatement')
				body.body = body.body.concat (temp.body);
			else
				body.body.push (temp);

			left = left.expressions [0];
		}

		return {
			type: 		Syntax.ForInStatement,
			left: 		left,
			right: 		right,
			body: 		body,
			each: 		false
		};
	}