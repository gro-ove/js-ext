	// 12.6 Iteration Statements

	function parseDoWhileStatement (){
		var body, test;

		expectKeyword ('do');

		body = parseStatement ();

		expectKeyword ('while');
		expect ('(');

		test = parseExpression ();

		expect (')');

		if (match (';'))
			lex ();

		return {
			type: 	Syntax.DoWhileStatement,
			body: 	body,
			test: 	test
		};
	}

	function parseWhileStatement (){
		var test, body;

		expectKeyword ('while');
		expect ('(');

		test = parseExpression ();

		expect (')');

		body = parseStatement ();

		return {
			type: 	Syntax.WhileStatement,
			test: 	test,
			body: 	body
		};
	}

	function parseForVariableDeclaration (){
		var token = lex ();

		return {
			type: 			Syntax.VariableDeclaration,
			declarations: 	parseVariableDeclarationList(),
			kind: 			token.value
		};
	}

	function parseForStatement (){
		var init, test, update, left, right, body, temp, result, arrayMode;

		init = test = update = null;

		expectKeyword ('for');
		expect ('(');

		if (match (';')){
			lex ();
		} else {
			if (matchKeyword ('var')){
				state.allowIn 	= false;
				init			= parseForVariableDeclaration ();
				state.allowIn 	= true;

				if (init.declarations.length <= 2 && (matchKeyword ('in-array') && (arrayMode = 1) || matchKeyword ('in'))){
					lex ();
					left 	= init;
					right 	= parseExpression ();
					init 	= null;
				}
			} else {
				state.allowIn 	= false;
				init 			= parseExpression ();
				state.allowIn 	= true;

				if (matchKeyword ('in-array') && (arrayMode = 1) || matchKeyword ('in')){
					// LeftHandSideExpression
					if (!isLeftHandSide (init) && (init.type != 'SequenceExpression' || init.expressions.length != 2))
						throwError ({}, Messages.InvalidLHSInForIn);

					lex ();
					left 	= init;
					right 	= parseExpression();
					init 	= null;
				}
			}

			if (typeof left === 'undefined')
				expect (';');
		}

		if (typeof left === 'undefined'){
			if (!match (';'))
				test = parseExpression ();

			expect (';');

			if (!match (')'))
				update = parseExpression ();
		}

		expect (')');
		body = parseStatement ();

		if (arrayMode)
			if (left.type === 'VariableDeclaration' && left.declarations.length === 1){
				left.declarations = [
					{
	                    type: 'VariableDeclarator',
	                    id: {
	                        type: 'Identifier',
	                        name: newIdentifier ()
	                    }
	                },
					left.declarations [0]
				]
			} else if (left.type === 'Identifier'){
				left = {
					type: 'VariableDeclaration',
					declarations: [
						{
		                    type: 'VariableDeclarator',
		                    id: {
		                        type: 'Identifier',
		                        name: newIdentifier ()
		                    }
		                },
		                {
		                	type: 'VariableDeclarator',
		                	id: left
		                }
					],
		            kind: 'var'
				};

				arrayMode = 2;
			}

		if (typeof left === 'undefined'){
			return {
				type: 		Syntax.ForStatement,
				init: 		init,
				test: 		test,
				update: 	update,
				body: 		body
			};
		} else if (left.type === 'SequenceExpression' && left.expressions.length === 2 || arrayMode === 2){
			temp = body;

			body = {
				type: 'BlockStatement',
				body: [
					{
						type: 'ExpressionStatement',
						expression: {
							type: 'AssignmentExpression',
							operator: '=',
							left: arrayMode === 2 ? left.declarations [1].id : left.expressions [1],
							right: {
								type: 'MemberExpression',
								computed: true,
								object: right,
								property: arrayMode === 2 ? left.declarations [0].id : left.expressions [0]
							}
						}
					}
				]
			};

			if (temp.type === 'BlockStatement')
				body.body = body.body.concat (temp.body);
			else
				body.body.push (temp);

			if (arrayMode === 2)
				left.declarations.length = 1;
			else
				left = left.expressions [0];
		} else if (left.type === 'VariableDeclaration' && left.declarations.length === 2){
			temp = body;

			body = {
				type: 'BlockStatement',
				body: [
					{
						type: 'VariableDeclaration',
						declarations: [ left.declarations [1] ],
						kind: 'var'
					}
				]
			};

			body.body [0].declarations [0].init = {
				type: 'MemberExpression',
				computed: true,
				object: right,
				property: left.declarations [0].id
			};

			if (temp.type === 'BlockStatement')
				body.body = body.body.concat (temp.body);
			else
				body.body.push (temp);

			left.declarations.length = 1;
		}

		if (arrayMode){
			if (left.type === 'VariableDeclaration' && !left.declarations [0].init)
				left.declarations [0].init = {
					type: 'Literal',
					value: 0
				};

			temp = left.type === 'VariableDeclaration' 
				? left.declarations [0].id 
				: left.type === 'SequenceExpression'
					? left.expressions [0]
					: left;

			result = {
				type: 		Syntax.ForStatement,
				init: 		left,
				test: 		{
								type: 'BinaryExpression',
								operator: '<',
								left: temp,
								right: {
									type: 'MemberExpression',
									computed: false,
									object: right,
									property: {
										type: 'Identifier',
										name: 'length'
									}
								}
							},
				update: 	{
				                type: 'UpdateExpression',
				                operator: '++',
				                argument: temp,
				                prefix: false
				            },
				body: 		body
			};
		} else {
			result = {
				type: 		Syntax.ForInStatement,
				left: 		left,
				right: 		right,
				body: 		body,
				each: 		false
			}
		}

		if (typeof temp !== 'undefined' && right.type !== 'Identifier'){
			var identifier = newIdentifier ();

			temp = clone (right);

			for (var n in right)
				delete right [n];

			right.type = 'Identifier';
			right.name = identifier;

			return {
				type: 'BlockStatement',
				body: [
					{
						type: 'VariableDeclaration',
						declarations: [
							{
								type: 'VariableDeclarator',
								id: right,
								init: temp
							}
						],
						kind: 'var'
					},
					result,
					{ 
						type: 'ExpressionStatement',
						expression: {
							type: 'AssignmentExpression',
							operator: '=',
							left: right,
							right: {
								type: 'Literal',
								value: null,
								raw: 'null'
							}
						}
					}
				]
			};
		}

		return result;
	}