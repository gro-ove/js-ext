	// 12.6 Iteration Statements

	function parseDoWhileStatement (){
		var body, test;

		expectKeyword ('do');

		body = parseStatement ();

		expectKeyword ('while');
		expect ('(');

		test = parseExpression ();

		expect (')');

		if (match (';'))
			lex ();

		return doWhileStatement (body, test);
	}

	function parseWhileStatement (){
		var test;

		expectKeyword ('while');
		expect ('(');

		test = parseExpression ();

		expect (')');

		return whileStatement (test, parseStatement ());
	}

	function parseForVariableDeclaration (){
		lex ();
		return variableDeclaration (parseVariableDeclarationList ());
	}

	function parseForStatement (){
		var init, test, update, left, right, body, temp, result, arrayMode, identifierMode, propertyName;

		init = test = update = null;

		expectKeyword ('for');
		expect ('(');

		if (match (';')){
			lex ();
		} else {
			if (matchKeyword ('var')){
				state.allowIn 	= false;
				init			= parseForVariableDeclaration ();
				state.allowIn 	= true;

				if (init.declarations.length <= 2 && (matchKeyword ('in-array') || matchKeyword ('in-object') || matchKeyword ('in'))){
					arrayMode 	= lex ().value;
					left 		= init;
					right 		= parseExpression ();
					init 		= null;
				}
			} else {
				state.allowIn 	= false;
				init 			= parseExpression ();
				state.allowIn 	= true;

				if (matchKeyword ('in-array') || matchKeyword ('in-object') || matchKeyword ('in')){
					if (!isLeftHandSide (init) && (init.type !== Syntax.SequenceExpression || init.expressions.length !== 2))
						throwError ({}, Messages.InvalidLHSInForIn);

					arrayMode 	= lex ().value;
					left 		= init;
					right 		= parseExpression();
					init 		= null;
				}
			}

			if (typeof left === 'undefined')
				expect (';');
		}

		if (typeof left === 'undefined'){
			if (!match (';'))
				test = parseExpression ();

			expect (';');

			if (!match (')'))
				update = parseExpression ();
		}

		expect (')');
		body = parseStatement ();

		if (arrayMode === 'in-array')
			if (left.type === Syntax.VariableDeclaration && left.declarations.length === 1){
				left.declarations = [ variableDeclarator (newIdentifier ()), left.declarations [0] ]
			} else if (left.type === Syntax.Identifier){
				left = variableDeclaration ([ variableDeclarator (newIdentifier ()), variableDeclarator (left) ]);
				identifierMode = true;
			}

		if (left === undefined){
			return forStatement (init, test, update, body);
		} else if (left.type === Syntax.SequenceExpression && left.expressions.length === 2 || identifierMode){
			temp = body;

			body = blockStatement ([ 
				expressionStatement (assignmentExpression (
						identifierMode ? left.declarations [1].id : left.expressions [1],
						memberExpression (right, identifierMode ? left.declarations [0].id : left.expressions [0], true))) ]);

			if (temp.type === Syntax.BlockStatement)
				body.body = body.body.concat (temp.body);
			else
				body.body.push (temp);

			if (identifierMode)
				left.declarations.length = 1;
			else
				left = left.expressions [0];
		} else if (left.type === Syntax.VariableDeclaration && left.declarations.length === 2){
			temp = body;
			body = blockStatement ([ variableDeclaration ([ left.declarations [1] ]) ]);
			body.body [0].declarations [0].init = memberExpression (right, left.declarations [0].id, true);

			if (temp.type === Syntax.BlockStatement)
				body.body = body.body.concat (temp.body);
			else
				body.body.push (temp);

			left.declarations.length = 1;
		}

		if (arrayMode === 'in-array'){
			if (left.type === Syntax.VariableDeclaration && !left.declarations [0].init)
				left.declarations [0].init = literal (0);

			temp = left.type === Syntax.VariableDeclaration
				? left.declarations [0].id 
				: left.type === Syntax.SequenceExpression
					? left.expressions [0]
					: left;

			if (left.type === Syntax.Identifier)
				left = assignmentExpression (left, literal (0));

			result = forStatement (
				left, 
				binaryExpression (temp, '<', memberExpression (right, 'length')), 
				unaryExpression (temp, '++', false), 
				body);
		} else {
			if (arrayMode === 'in-object'){
				propertyName = left.type === Syntax.VariableDeclaration ? left.declarations [0].id.name : left.name;
				body = ifStatement (callExpression (memberExpression (right, 'hasOwnProperty'), [ propertyName ]), body);
			}

			result = forInStatement (left, right, body);
		}

		if ((temp !== undefined || arrayMode === 'in-object') && right.type !== Syntax.Identifier){
			var identifier = newIdentifier ();

			temp = $.extend (true, {}, right);

			for (var n in right)
				delete right [n];

			right.type = Syntax.Identifier;
			right.name = identifier;

			return blockStatement ([
				variableDeclaration ([ variableDeclarator (right, temp) ]),
				result,
				expressionStatement (assignmentExpression (right, 'undefined'))
			]);
		}

		return result;
	}