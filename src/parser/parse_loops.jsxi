    // 12.6 Iteration Statements
    function parseDoWhileStatement (){
        var body, test;

        expectKeyword ('do');

        body = parseStatement ();

        expectKeyword ('while');
        expect ('(');

        test = parseExpression ();

        expect(')');

        if (match (';'))
            lex ();

        return {
            type: 	Syntax.DoWhileStatement,
            body: 	body,
            test: 	test
        };
    }

    function parseWhileStatement (){
        var test, body;

        expectKeyword ('while');
        expect ('(');

        test = parseExpression ();

        expect (')');

        body = parseStatement ();

        return {
            type: 	Syntax.WhileStatement,
            test: 	test,
            body: 	body
        };
    }

    function parseForVariableDeclaration (){
        var token = lex ();

        return {
            type: 			Syntax.VariableDeclaration,
            declarations: 	parseVariableDeclarationList(),
            kind: 			token.value
        };
    }

    function parseForStatement() {
        var init, test, update, left, right, body;

        init = test = update = null;

        expectKeyword ('for');
        expect ('(');

        if (match (';')){
            lex ();
        } else {
            if (matchKeyword ('var')){
                state.allowIn 	= false;
                init			= parseForVariableDeclaration ();
                state.allowIn 	= true;

                if (init.declarations.length === 1 && matchKeyword ('in')){
                    lex ();
                    left 	= init;
                    right 	= parseExpression ();
                    init 	= null;
                }
            } else {
                state.allowIn 	= false;
                init 			= parseExpression ();
                state.allowIn 	= true;

                if (matchKeyword ('in')){
                    // LeftHandSideExpression
                    if (!isLeftHandSide (init))
                        throwErrorTolerant ({}, Messages.InvalidLHSInForIn);

                    lex ();
                    left 	= init;
                    right 	= parseExpression();
                    init 	= null;
                }
            }

            if (typeof left === 'undefined')
                expect (';');
        }

        if (typeof left === 'undefined'){
            if (!match (';'))
                test = parseExpression ();

            expect (';');

            if (!match (')'))
                update = parseExpression ();
        }

        expect (')');
        body = parseStatement ();

        if (typeof left === 'undefined')
            return {
                type: 		Syntax.ForStatement,
                init: 		init,
                test: 		test,
                update: 	update,
                body: 		body
            };

        return {
            type: 		Syntax.ForInStatement,
            left: 		left,
            right: 		right,
            body: 		body,
            each: 		false
        };
    }