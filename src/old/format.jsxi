module Format {
	import Node;
		
	var eol = '\n';
	
	var additional, jsx;
		
	function reset (){
		previous = 0;
		additional = {};
		jsx = [];
	}
	
	function commentParse (tag, data){
		if (tag == 'jsx' || additional [tag]){
			[].push.apply (additional [tag] || jsx, data);
		} else
			additional [tag] = data;
	}
	
	var previous = 0,
	    randomName = lambda '__tmp_' + previous ++;

	var f = lambda {
		try {
			if (!types [arg.type])
				Node.fatalError ('No formatter for type: ' + arg.type, arg)
			else 
				return types [arg.type](arg);
		} catch {
			// console.log ('Error at:', '\n' + JSON.stringify (arg, false, 4));
			Node.fatalError ('Formatting error: ' + e);
		}
	};

	var types = {
			Program:                  lambda arg.elements.map (f).join (eol),
			Comment:                  lambda {

				var specialMode = arg.data [0].match (/^\s*\/\/s+==([a-z\d]+)==/i);
				if (specialMode){
					return specialMode [0];
				}

				return '';
			},
			ForInStatement:           lambda {
				// TODO: initialization expressions

				var vars        = arg.iterator.type == 'VariableDeclarations',
					direct      = vars && arg.iterator.declarations.length == 2 || arg.iterator.type == 'BinaryExpression' && arg.iterator.operator == ',',
					cacheMode   = arg.token == 'in-array' && arg.collection.type != 'Variable',
					collection  = cacheMode ? randomName () : f (arg.collection),
					body        = f (arg.statement) + ';',
					result      = '';

				if (arg.token == 'in-array'){
					var key    = direct ? vars ? 'var ' + arg.iterator.declarations [0].name : arg.iterator.left.name : 'var ' + randomName (),
						keyn   = key.match (/[^\s]+$/)[0],
						value  = direct ? vars ? 'var ' + arg.iterator.declarations [1].name : arg.iterator.right.name : f (arg.iterator);

					result = 'for(' + key + '=0;' + keyn + '<' + collection + '.length;' + keyn + '++){' 
						+ eol + value + '=' + collection + '[' + keyn + '];' + eol + body 
						+ value.match (/[^\s]+$/)[0] + '=undefined }';
				} else if (arg.token == 'in'){
					if (direct){
						if (vars){
							var temp = 'var ' + arg.iterator.declarations [1].name + '=' + collection + '[' + arg.iterator.declarations [0].name + '];' + eol;
							arg.iterator.declarations.length = 1;
						} else {
							var temp = arg.iterator.right.name + '=' + collection + '[' + arg.iterator.left.name + '];' + eol;
							arg.iterator = arg.iterator.left;
						}
						body = '{' + eol + temp + body + '}' + eol;
					}

					result = 'for(' + f (arg.iterator) + ' in ' + collection + ')' + body;
				} else
					Node.fatalError ('No formatter for ForInStatement (token: ' + arg.token + ')');

				return (cacheMode ? '{ var ' + collection + '=' + f (arg.collection) + ';' + eol + result + collection + '=undefined }' : result) + eol;
			},
			FunctionCall:             lambda f (arg.name) + '(' + arg.arguments.map (f).join (',') + ')',

			Raw:                      lambda arg.value,
			SpecialComment:           lambda commentParse (arg.tag, arg.value) || '',
			NumericLiteral:           lambda arg.value,
			UnaryExpression:          lambda arg.operator + ' ' + f (arg.expression),
			BinaryExpression:         lambda f (arg.left) + ' ' + arg.operator + ' ' + f (arg.right),
			ConditionalExpression:    lambda f (arg.condition) + ' ? ' + f (arg.trueExpression) + ' : ' + f (arg.falseExpression),
			ParenthesizedExpression:  lambda '(' + f (arg.value) + ')',
			VariableStatement:        lambda 'var ' + arg.declarations.map (f).join (', ') + ';',
			VariableDeclarations:     lambda 'var ' + arg.declarations.map (f).join (', '),
			VariableDeclaration:      lambda arg.value ? arg.name + ' = ' + f (arg.value) : arg.name,
			Function:                 lambda 'function' + (arg.name ? ' ' + arg.name : '') + ' (' + arg.params.join (',') + '){'
				+ eol + arg.elements.map (f).join (eol) + eol + '}',
			StringLiteral:            lambda JSON.stringify (arg.value),
			BooleanLiteral:           lambda arg.value ? 'true' : 'false',
			NullLiteral:              lambda 'null',
			Variable:                 lambda arg.name,
			PropertyAccess:           lambda f (arg.base) + (arg.name.type ? ' [' + f (arg.name) + ']' : '.' + arg.name),
			IfStatement:              lambda 'if (' + f (arg.condition) + ')' + eol + f (arg.ifStatement) 
				+ (arg.elseStatement ? eol + 'else' + eol + f (arg.elseStatement) : ''),
			Block:                    lambda '{' + eol + arg.statements.map (f).join (eol) + eol + '}',
			ReturnStatement:          lambda arg.value ? 'return ' + f (arg.value) + ';' : 'return;',
			EmptyStatement:           lambda ';',
			ExpressionStatement:      lambda f (arg.value) + ';',
			AssignmentExpression:     lambda f (arg.left) + ' ' + arg.operator + ' ' + f (arg.right),
			PostfixExpression:        lambda f (arg.expression) + arg.operator,
			ArrayLiteral:             lambda '[' + arg.elements.map (f).join (',') + ']',
			ObjectLiteral:            lambda '{' + arg.properties.map (f).join (',') + '}',
			RegularExpressionLiteral: lambda '/' + arg.body + '/' + arg.flags,
			This:                     lambda 'this',
			ThrowStatement:           lambda 'throw ' + f (arg.exception) + ';',
			ForStatement:             lambda 'for (' + (arg.initializer ? f (arg.initializer) : '') + '; ' + eol 
				+ (arg.test ? f (arg.test) : '') + '; ' + (arg.counter ? f (arg.counter) : '') + ')' + eol + f (arg.statement),
			WhileStatement:           lambda 'while (' + f (arg.condition) + ')' + eol + f (arg.statement),
			DoWhileStatement:         lambda 'do' + eol + f (arg.statement) + eol + ' while (' + f (arg.condition) + ');',
			SwitchStatement:          lambda 'switch (' + f (arg.expression) + '){' + eol + arg.clauses.map (f).join (eol) 
				+ eol + '}',
			CaseClause:               lambda 'case ' + f (arg.selector) + ':' + eol + arg.statements.map (f).join (eol),
			DefaultClause:            lambda 'default:' + arg.statements.map (lambda f (arg)).join (' '),
			BreakStatement:           lambda arg.label ? 'break ' + arg.label + ';' : 'break;',
			ContinueStatement:        lambda arg.label ? 'continue ' + arg.label + ';' : 'continue;',
			TryStatement:             lambda 'try' + (arg.block.type == 'Block' ? f (arg.block) : '{' + eol + f (arg.block) + eol + '}') 
				+ (arg ['catch'] ? f (arg ['catch']) : '') + (arg ['finally'] ? f (arg ['finally']) : '')
				+ (!arg ['catch'] && !arg ['finally'] ? 'catch (e){}' : ''),
			Catch:                    lambda 'catch (' + arg.identifier + ')' 
				+ (arg.block.type == 'Block' ? f (arg.block) : '{' + eol + f (arg.block) + eol + '}'),
			Finally:                  lambda 'finally' 
				+ (arg.block.type == 'Block' ? f (arg.block) : '{' + eol + f (arg.block) + eol + '}'),
			PropertyAssignment:       lambda JSON.stringify (arg.name) + ':' + f (arg.value),
			NewOperator:              lambda 'new ' + f (arg.constructor) + '(' + arg.arguments.map (f).join (', ') + ')',
			GetterDefinition:         lambda 'get ' + arg.name + ' (){' + arg.body.map (f).join (eol) + '}',
			SetterDefinition:         lambda 'set ' + arg.name + ' (' + arg.param + '){' + arg.body.map (f).join (eol) + '}',
			LabelledStatement:        lambda arg.label + ':' + f (arg.statement),
			WithStatement:            lambda 'with (' + f (arg.environment) + '){' + eol + f (arg.statement) + eol + '}',
			PhpLiteral:               lambda {
				additional.php = true;
				return '/*!<? echo "*"."/"; include "' + arg.value + '"; echo "||/*" ?>*/ null'
			}
		};
		
	export function work (arg){
		reset ();

		var code = f (arg).trim ();

		// console.log (code);
	
		return {
			code: code, 
			additional: additional,
			jsx: jsx
		}
	}
}