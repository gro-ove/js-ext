module Generator {
	var currentFileName, tabs, tab = '    ';

	function _ (s)
		return s [s.length - 1] === '\n' 
			? s.slice (0, -1) 
			: s.slice (-tab.length) === tab 
				? s.slice (0, -tab.length)
				: s;

	function t (s, full)
		return s.replace (full ? (/(\/\/[\s\S]+)?[\n\s]+$/g) : (/[\n\s]+$/g), '');

	function n (n, s){
		if (n === 1){
			tabs += tab;
		} else if (n === -1){
			tabs = _ (tabs);
			console.assert (tabs.length, 'Too much tabs have been removed!');
		}

		return tabs;
	}

	function x (b, s)
		return b.type === 'BlockStatement' 
			? f (b, s)
			: n (1) + t (f (b)) + n (-1);

	function $ (arg, mn){
		if (mn)
			n (-1);

		if (!arg.comment && !arg.lineNumber)
			return ';' + tabs;

		var result = '; // ';

		if (arg.lineNumber)
			result += currentFileName + ' [' + arg.lineNumber + ':' + (arg.index - arg.lineStart) + ']';
		if (arg.comment)
			if (arg.lineNumber)
				result += ' (' + arg.comment + ')';
			else
				result += arg.comment;

		return result + tabs;
	}

	function c (a, j = '', b)
		return a.map (lambda f (arg, b)).join (j);

	function f (element, arg){
		if (!fn [element.type]){
			console.log (element);
			return '[ ' + element.type.toUpperCase () + ' ]' + $ (element);
		} else {
			var oldTabs = tabs,
				result = fn [element.type](element, arg);

			tabs = oldTabs;
			return result;
		}
	}

	var fn = {
		Identifier: 			lambda arg.name,
		Literal:                lambda arg.value === null 
									? 'null'
									: typeof arg.value === 'string' 
										? JSON.stringify (arg.value)
										: typeof arg.value === 'number' 
											? arg.value 
											: '[ ' + arg.value + ' ]',
		Property: 				lambda f (arg.key) + ': ' + f (arg.value),

		BlockStatement:         lambda arg.body.length ? '{' + n (1) + _ (c (arg.body)) + '}' + (arguments [1] ? ' ' : n (-1)) : '{}',
		ExpressionStatement:    lambda f (arg.expression) + $ (arg),
		ReturnStatement:        lambda 'return' + (arg.argument ? ' ' + f (arg.argument) : '') + $ (arg),
		IfStatement:        	lambda 'if (' + f (arg.test) + ')' + x (arg.consequent, arg.alternate) + (arg.alternate ? 'else ' + x (arg.alternate) : ''),
		WhileStatement:    		lambda 'while (' + f (arg.test) + ')' + x (arg.body),
		DoWhileStatement: 		lambda 'do ' + x (arg.body, true) + 'while (' + f (arg.test) + ')' + $ (arg),
		ForStatement:    		lambda 'for (' + (arg.init ? f (arg.init, true) : '') + ';' + (arg.test ? ' ' + f (arg.test) : '') + ';' + (arg.update ? ' ' + f (arg.update) : '') + ')' + x (arg.body),
		ForInStatement:    		lambda 'for (' + f (arg.left, true) + ' in ' + f (arg.right) + ')' + x (arg.body),
		TryStatement:    		lambda 'try ' + f (arg.block, true) + c (arg.handlers, '', arg.finalizer) + (arg.finalizer ? 'finally ' + f (arg.finalizer) : '') + tabs, 
		CatchClause:            lambda 'catch (' + f (arg.param) + ')' + f (arg.body, arguments [1]),
		LabeledStatement:       lambda f (arg.label) + ': ' + f (arg.body),
		BreakStatement:       	lambda 'break' + (arg.label ? ' ' + f (arg.label) : '') + $ (arg),
		ContinueStatement:      lambda 'continue' + (arg.label ? ' ' + f (arg.label) : '') + $ (arg),
		ThrowStatement:      	lambda 'throw ' + f (arg.argument) + $ (arg),
		DebuggerStatement:      lambda 'debugger' + $ (arg),
		SwitchStatement:        lambda 'switch (' + f (arg.discriminant) + '){' + n (1) + _ (c (arg.cases)) + '}',
		SwitchCase:             lambda (arg.test ? 'case ' + f (arg.test) : 'default') + ':' + n (1) + _ (c (arg.consequent)),

		NewExpression:          lambda 'new ' + f (arg.callee) + ' (' + c (arg.arguments, ', ') + ')',
		ThisExpression:         lambda 'this',
		CallExpression:         lambda f (arg.callee) + ' (' + c (arg.arguments, ', ') + ')',
		ArrayExpression:        lambda arg.elements.length ? '[' + n (1) + c (arg.elements, ',' + tabs) + n (-1) + ']' : '[]',
		ObjectExpression:       lambda arg.properties.length ? '{' + n (1) + c (arg.properties, ',' + tabs) + n (-1) + '}' : '{}',
		MemberExpression:       lambda f (arg.object) + (arg.computed ? '[' + f (arg.property) + ']' : '.' + f (arg.property)),
		FunctionExpression:     lambda 'function ' + (arg.id ? f (arg.id) + ' ' : '') + '(' + c (arg.params, ', ') + ')' + f (arg.body),
		BinaryExpression:   	lambda f (arg.left) + ' ' + arg.operator + ' ' + f (arg.right),
		LogicalExpression:   	lambda f (arg.left) + ' ' + arg.operator + ' ' + f (arg.right),
		AssignmentExpression:   lambda f (arg.left) + ' ' + arg.operator + ' ' + f (arg.right),
		UnaryExpression:   		lambda arg.prefix ? (arg.operator.length == 1 ? arg.operator : arg.operator + ' ') + f (arg.argument) : f (arg.argument) + ' ' + arg.operator,
		SequenceExpression:     lambda n (1) && c (arg.expressions, ',' + tabs),
		ConditionalExpression:  lambda f (arg.test) + ' ? ' + f (arg.consequent) + ' : ' + f (arg.alternate),
		
		VariableDeclaration:    lambda n (1) && arg.kind + ' ' + arg.declarations.map (f).join (',' + tabs) + (arguments [1] ? '' : $ (arg, true)),
		VariableDeclarator:     lambda arg.init ? f (arg.id) + ' = ' + f (arg.init) : f (arg.id),

		FunctionDeclaration:    lambda 'function ' + f (arg.id) + ' (' + c (arg.params, ', ') + ')' + f (arg.body) + tabs,

		Program: 				lambda c (arg.body),
	};

	export function work (element, fileName){
		currentFileName = fileName;
		tabs = '\n';

		return f (element);
	}
}