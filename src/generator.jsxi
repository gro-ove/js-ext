// https://developer.mozilla.org/ru/docs/JavaScript/Reference/Operators/Operator_Precedence
var priorities = [
	[ 
		Syntax.MemberExpression, 
		Syntax.NewExpression 
	],

	[ 
		Syntax.CallExpression 
	],

	[
		{ type: Syntax.UnaryExpression, operator: '++' },
		{ type: Syntax.UnaryExpression, operator: '--' },
	],

	[
		{ type: Syntax.UnaryExpression, operator: '!' },
		{ type: Syntax.UnaryExpression, operator: '~' },
		{ type: Syntax.UnaryExpression, operator: '+' },
		{ type: Syntax.UnaryExpression, operator: '-' },
		{ type: Syntax.UnaryExpression, operator: 'typeof' },
		{ type: Syntax.UnaryExpression, operator: 'void' },
		{ type: Syntax.UnaryExpression, operator: 'delete' },
	],

	[
		{ type: Syntax.BinaryExpression, operator: '*' },
		{ type: Syntax.BinaryExpression, operator: '/' },
		{ type: Syntax.BinaryExpression, operator: '%' }
	],

	[
		{ type: Syntax.BinaryExpression, operator: '+' },
		{ type: Syntax.BinaryExpression, operator: '-' }
	],

	[
		{ type: Syntax.BinaryExpression, operator: '<<' },
		{ type: Syntax.BinaryExpression, operator: '>>' },
		{ type: Syntax.BinaryExpression, operator: '>>>' }
	],

	[
		{ type: Syntax.BinaryExpression, operator: '<' },
		{ type: Syntax.BinaryExpression, operator: '<=' },
		{ type: Syntax.BinaryExpression, operator: '>' },
		{ type: Syntax.BinaryExpression, operator: '>=' },
		{ type: Syntax.BinaryExpression, operator: 'in' },
		{ type: Syntax.BinaryExpression, operator: 'instanceof' }
	],

	[
		{ type: Syntax.BinaryExpression, operator: '==' },
		{ type: Syntax.BinaryExpression, operator: '!=' },
		{ type: Syntax.BinaryExpression, operator: '===' },
		{ type: Syntax.BinaryExpression, operator: '!==' }
	],

	[
		{ type: Syntax.BinaryExpression, operator: '&' }
	],

	[
		{ type: Syntax.BinaryExpression, operator: '^' }
	],

	[
		{ type: Syntax.BinaryExpression, operator: '|' }
	],

	[
		{ type: Syntax.LogicalExpression, operator: '&&' }
	],

	[
		{ type: Syntax.LogicalExpression, operator: '||' }
	],

	[
		Syntax.ConditionalExpression
	],

	[
		Syntax.AssignmentExpression
	],

	[
		Syntax.SequenceExpression
	]
];

function generate (node, params = { lineBreak: '\n' }){
	function child (obj, newParams){
		return generate (obj, $.extend ({ parent: node, lineBreak: params.lineBreak, parentParams: params }, newParams));
	}

	function indent (obj, newParams = {}){
		var lineBreak = params.lineBreak + '\t';
		return (newParams.force ? lineBreak : '') + generate (obj, $.extend ({ parent: node, lineBreak: lineBreak, parentParams: params }, newParams));
	}

	function array (obj, arrayParams){
		var data, lineBreak, result;

		if (arrayParams.indent !== false){
			data = obj.map (lambda indent (arg, { array: true }));
			lineBreak = params.lineBreak + '\t';
		} else {
			data = obj.map (lambda child (arg, { array: true }));
			lineBreak = params.lineBreak;
		}

		result = data.join (arrayParams.join || '');

		if (result.length > 120 && obj.length > 1 || arrayParams.wrap){
			result = data.join ((arrayParams.join || '') + lineBreak);
			if (arrayParams.autospaces)
				result = lineBreak + result + (arrayParams.indent === false ? params.lineBreak.slice (0, -1) : params.lineBreak);
		} else if (arrayParams.autospaces)
			result = ' ' + result + ' ';

		return result;
	}

	function sub (obj, newParams){
		return obj.type === Syntax.BlockStatement ? child (obj) : indent (obj, $.extend ({ force: true }, newParams))
	}

	function safe (obj, newParams){
		if (!obj)
			return '';

		var result = child (obj, newParams);
		return result + (/[_$a-zA-Z\d]$/.test (result) ? ' ' : '');
	}

	function brackets (string){
		// Как и с записью ниже - парсинг обычно начинается с «Program», так что родитель должен быть.
		console.assert (params.parent, 'Not implemented');

		function index (type, operator){
			for (var priority, group in-array priorities)
				for (var entry in-array group)
					if (entry === type 
						|| typeof entry === 'object' 
						&& entry.type === type 
						&& entry.operator === operator)

						return priority;
			return -1;
		} // result += currentFileName + ' [' + arg.lineNumber + ':' + (arg.index - arg.lineStart) + ']';

		var that = index (node.type, node.operator),
			parent = index (params.parent.type, params.parent.operator);

		console.assert (that !== -1, 'Priority not defined (' + node.type + ', "' + node.operator + '")');

		if ((!params.array || node.type === Syntax.SequenceExpression) && parent !== -1 && that > parent)
			return '(' + string + ')';
		else
			return string;
	}

	switch (node.type){
		/* Base */
		case Syntax.Identifier:
			return node.name;

		case Syntax.Literal:
			if (typeof node.value === 'string')
				return '\'' + JSON.stringify (node.value).slice (1, -1).replace (/'/g, '\\\'') + '\'';
			else
				return String (node.value);

		case Syntax.Property:
			return child (node.key) + ': ' + child (node.value);


		/* Expressions: Access */
		case Syntax.MemberExpression:
			return child (node.object) + (node.computed ? '[' + child (node.property) + ']' : '.' + child (node.property));

		case Syntax.ThisExpression:
			return 'this';

		/* Expressions: Calls */
		case Syntax.CallExpression:
			var args = array (node.arguments, { join: ', ' }),
				match = args.match (/\n\t*/);
			if (match && match [0].length > params.lineBreak.length + 1)
				args = args.replace (/\n\t/g, '\n');
			return safe (node.callee) + '(' + args + ')';

		case Syntax.NewExpression:
			var args = array (node.arguments, { join: ', ' }),
				match = args.match (/\n\t*/);
			if (match && match [0].length > params.lineBreak.length + 1)
				args = args.replace (/\n\t/g, '\n');
			return 'new ' + safe (node.callee) + '(' + args + ')';

		/* Expressions: Operator */
		case Syntax.UnaryExpression:
			if (node.prefix){
				var result = node.operator;

				if (result !== '!')
					result += ' ';

				result += child (node.argument);

				return brackets (result);
			} else
				return brackets (child (node.argument) + ' ' + node.operator);

		case Syntax.AssignmentExpression:
		case Syntax.BinaryExpression:
		case Syntax.LogicalExpression:
			return brackets (child (node.left) + ' ' + node.operator + ' ' + child (node.right));

		case Syntax.SequenceExpression:
			return brackets (array (node.expressions, { join: ', ' }));

		case Syntax.ConditionalExpression:
			return brackets (child (node.test) + ' ? ' + child (node.consequent) + ' : ' + child (node.alternate));

		/* Expressions: Creating */
		case Syntax.ArrayExpression:
			if (node.elements.length === 0)
				return '[]';
			else
				return '[' + array (node.elements, { join: ', ', autospaces: true }) + ']';

		case Syntax.ObjectExpression:
			if (node.properties.length === 0)
				return '{}';
			else
				return '{' + array (node.properties, { join: ', ', autospaces: true }) + '}';

		case Syntax.FunctionExpression:
			return 'function ' + safe (node.id) + '(' + array (node.params, { join: ', ' }) + ')' + child (node.body);


		/* Declarations */
		case Syntax.FunctionDeclaration:
			return 'function ' + child (node.id) + ' (' + array (node.params, { join: ', ' }) + ')' + child (node.body);

		case Syntax.VariableDeclaration:
			return 'var ' + array (node.declarations, { join: ', ' }) + ';';

		case Syntax.VariableDeclarator:
			return node.init ? child (node.id) + ' = ' + child (node.init) : child (node.id);


		/* Statements: Base */
		case Syntax.BlockStatement:
			if (node.body.length === 0){
				return '{}';
			} else if (0 && node.body.length === 1){
				return '{ ' + child (node.body [0]).replace (/;$/, '') + ' }';
			} else
				return '{' + params.lineBreak + '\t' + array (node.body, { wrap: true }) + params.lineBreak + '}';

		case Syntax.ExpressionStatement:
			var result = child (node.expression);
			if (/^function\s*\(/.test (result))
				return '(' + result + ');';
			else
				return result + ';';

		case Syntax.LabeledStatement:
			return child (node.label) + ': ' + child (node.body);

		/* Statements: Control */
		case Syntax.ReturnStatement:
			return 'return' + (node.argument ? ' ' + child (node.argument) : '') + ';';

		case Syntax.BreakStatement:
			if (node.label)
				return 'break ' + child (node.label) + ';';
			else
				return 'break;'

		case Syntax.ContinueStatement:
			if (node.label)
				return 'continue ' + child (node.label) + ';';
			else
				return 'continue;'

		/* Statements: Conditional */
		case Syntax.IfStatement:
			var result = 'if (' + child (node.test) + ')' + sub (node.consequent);

			if (node.alternate){
				if (node.consequent.type !== Syntax.BlockStatement)
					result += params.lineBreak;
				else
					result += ' ';

				result += 'else';

				if (node.alternate.type === Syntax.IfStatement){
					result += ' ' + child (node.alternate)
				} else {
					if (node.alternate.type === Syntax.BlockStatement)
						result += ' ';
					result += sub (node.alternate);
				}
			}

			return result;

		case Syntax.SwitchStatement:
			var result = 'switch (' + child (node.discriminant) + '){';

			for (var obj in-array node.cases)
				result += indent (obj, { force: true });

			result += params.lineBreak + '}';

			return result;

		case Syntax.SwitchCase:
			var result = '';

			if (node.test)
				result += 'case ' + child (node.test);
			else
				result += 'default';

			result += ':' + params.lineBreak + '\t' + array (node.consequent, { wrap: true });

			return result;

		/* Statements: Loops */
		case Syntax.WhileStatement:
			return 'while (' + child (node.test) + ')' + sub (node.body);

		case Syntax.DoWhileStatement:
			var result = 'do';
			if (node.body.type !== Syntax.BlockStatement)
				result += sub (node.body) + params.lineBreak;
			else
				result += ' ' + sub (node.body) + ' ';
			result += 'while (' + child (node.test) + ');';
			return result;

		case Syntax.ForStatement:
			var result = 'for (';

			if (node.init)
				result += child (node.init);
			if (result [result.length - 1] !== ';')
				result += ';';

			if (node.test)
				result += ' ' + child (node.test);
			result += ';';

			if (node.update)
				result += ' ' + child (node.update);
			result += ')' + sub (node.body);

			return result;

		case Syntax.ForInStatement:
			return 'for (' + child (node.left).replace (/;$/, '') + ' in ' + child (node.right) + ')' + sub (node.body);

		/* Statements: Errors, debugging */
		case Syntax.TryStatement:
			var result = 'try ' + sub (node.block) + ' ';

			for (var handler in-array node.handlers)
				result += child (handler) + ' ';

			if (node.finalizer)
				result += 'finally ' + sub (node.finalizer);

			return result;

		case Syntax.CatchClause:
			return 'catch (' + child (node.param) + ')' + sub (node.body);

		case Syntax.ThrowStatement:
			return 'throw ' + child (node.argument) + ';';

		case Syntax.DebuggerStatement:
			return 'debugger;';


		/* Stuff */
		case Syntax.Program:
			return node.body.map (child).join ('\n');

		default:
			throw new Error ('Unsupported type: ' + node.type + ' (' + JSON.stringify (params.parent, false, 4) + ')');
	}
}