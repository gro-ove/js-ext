	function Queue (object = null, mode = Queue.MODE_SEQUENT){
		if (typeof object === 'string'){
			mode 			= object;
			object 			= null;
		}

		console.assert (mode, 'Wrong mode');

		this.total 			= 0;
		this.finished 		= 0;
		this.results 		= [];
		this.mode 			= mode;
		this.object 		= object;
		this.delayed 		= [];
	}

	Queue.MODE_SEQUENT		= 'MODE_SEQUENT';
	Queue.MODE_PARALLEL 	= 'MODE_PARALLEL';

	Queue.prototype.finish = function (id, args, data){
		if (id !== undefined){
			console.assert (!this.results [id], 'Already returned');

			this.finished ++;
			this.results [id] = {
				result: 	args instanceof Array ? args : [].slice.call (args),
				data: 		data
			};
		}

		if (this.mode === Queue.MODE_SEQUENT && this.finished < this.total && this.finished == this.results.length){
			console.assert (typeof this.delayed [this.finished] === 'function', 'Delayed call missing');
			this.delayed [this.finished]();
		}

		if (this.finished === this.total && this.callback){
			if (this.done)
				console.log (this.previous);
			console.assert (!this.done, 'Already finished');

			this.callback.call (this.object, this.results);
			this.done = true;

			try 
				throw new Error ();
			catch 
				this.previous = e.stack;
		}
	}

	Queue.prototype.makeCall = function (fn, args, data){
		var id 		= this.total ++,
			that 	= this;

		args.push (lambda that.finish (id, arguments, data));

		return lambda {
			that.results [id] = undefined;
			var result = fn.apply (that.object, args);

			if (result !== undefined)
				that.finish (id, [ result ], data);
		};
	}

	Queue.prototype.add = function (data, fn){
		var args;

		if (typeof data === 'function'){
			args 	= [].slice.call (arguments, 1);
			fn 		= data;
			data 	= undefined;
		} else 
			args 	= [].slice.call (arguments, 2);

		console.assert (typeof fn === 'function', 'Invalid argument');

		var call = this.makeCall (fn, args, data);

		if (this.mode === Queue.MODE_PARALLEL || this.mode === Queue.MODE_SEQUENT && this.finished == this.results.length){
			call ();
		} else {
			this.delayed [this.total - 1] = call;
		}

		return this;
	}

	Queue.prototype.run = function (callback){
		console.assert (!this.callback, 'Already runned');
		console.assert (typeof callback === 'function', 'Invalid argument');

		this.callback = callback;
		this.finish ();

		return this;
	}