	function Macro (name, level, context, macroArgs, macroBody){
		this.name 			= name;

		if (!macroBody){
			macroBody 		= macroArgs;
			macroArgs 		= null;
		}
		
		this.level 			= level;
		this.arguments 		= macroArgs === null ? [ 'arg' ] : macroArgs; 
		this.context 		= context;
		this.rawBody 		= macroBody;
		this.asyncMode 		= this.arguments [this.arguments.length - 1] === 'callback';
		this.localStorage 	= {};
	};

	addLog (Macro, 3, lambda '@' + this.name);

	Macro.ReturnType = { 
		Object: 		'MacroReturnTypeObject',
		String: 		'MacroReturnTypeString',
		Raw: 			'MacroReturnTypeRaw',
		RawWithMacros: 	'MacroRawWithMacros',
		SourceTree: 	'MacroReturnTypeSourceTree',
	};

	Macro.Defaults = {
		fs: 			fs,
		path: 			path,
		params: 		paramsManager,
		ReturnType: 	Macro.ReturnType
	};

	Macro.globalStorage = {};

	Macro.prototype.defaults = function (context){
		var result 	= {},
			obj 	= {
				name: 			this.name,
				context: 		context,
				macroContext: 	this.context
			};

		for (var key, value in Macro.Defaults){
			if (typeof value === 'function')
				result [key] = value.call (obj);
			else
				result [key] = value;
		}

		return result;
	}

	Macro.prototype.initialize = function (callback){
		function macroCalls (macroBody){
			var used = [],
				lastIdentifier,
				liteParser,
				name,
				found,
				temp;

			if (macroBody.search (/@[_$a-zA-Z]/) !== -1){
				lastIdentifier 	= 0;
				liteParser 		= new LiteParser (macroBody)
					.on ('//', lambda this.findSimple ('\n', '\r', LiteParser.EOF))
					.on ('/*', lambda this.findSimple ('*/'))
					.on ('\'', '"', '`', lambda {
						while (temp = liteParser.findSimple ('\\' + arg.value, arg.value))
							if (temp.value === arg.value)
								return true;
						return false;
					});

				while (found = liteParser.findNext (/@([_$a-zA-Z][_$a-zA-Z0-9]*)/)){
					while (macroBody.indexOf (name = '_' + (lastIdentifier ++).toString (32)) !== -1);
					used.push ({ name: name, macro: found.raw [1] });

					temp = liteParser.whatNext (/[^\s]/);
					if (!temp || temp.value !== '(')
						name = name + ' ()';

					liteParser.update (macroBody = macroBody.substr (0, found.index) + name + macroBody.substr (liteParser.index), liteParser.index + name.length - found.value.length);
				}
			}

			return {
				used: 	used,
				body: 	macroBody
			};
		}

		if (this.callee){
			callback ();
			return;
		}

		var phase 		= macroCalls (this.rawBody),
			converted 	= convert (phase.body, { filename: 'macro', insertReturn: true }),
			variables 	= [],
			queue 		= new Queue (macroStorage, Queue.MODE_PARALLEL).description ('macros inside other macro');

		variables.push ('context = this.context');
		variables.push ('macroContext = this.macroContext');
		variables.push ('global = this.global');
		variables.push ('local = this.local');

		for (var key in Macro.Defaults)
			variables.push (key + ' = this.defaults.' + key);

		for (var entry in-array phase.used){
			queue.add (macroStorage.get, entry.macro, this.level);
			variables.push (entry.name + ' = function (){ return this.macros.' + entry.macro + '.call (this.context, arguments) }.bind (this)');
		}

		this.macros 	= {};
		this.debug 		= (variables.length ? 'var ' + variables.join (', ') + ';\n' : '') + converted;
		this.callee 	= new Function (this.arguments.join (','), this.debug);

		queue.run (lambda {
			arg.map (lambda arg.result [0]).forEach (lambda (other){
				this.log ('found @' + other.name + ' for using inside');
				this.macros [other.name] = other;
			}.bind (this));

			this.log ('initialized');
			callback ();
		}.bind (this));
	}

	Macro.prototype.call = function (context, args){
		console.assert (this.callee, 'Macro is not initialized');
		console.assert (args && typeof args.length === 'number', 'Wrong argument');
		console.assert (context instanceof Context, 'Context required');

		var object = { 
			defaults: 		this.defaults (context), 
			macros: 		this.macros,
			macroContext: 	this.context,
			context: 		context,
			global: 		Macro.globalStorage,
			local: 			this.localStorage
		};

		try
			return this.callee.apply (object, args);
		catch
			if (e.name === 'MacroError')
				throw e;
			else
				throw new MacroError (this.name, args, e);
	}

	function MacroError (name, args, parent, message){
		if (typeof args === 'string'){
			message 	= args;
			args 		= undefined;
			parent 		= undefined;
		}

		this.name 		= 'MacroError';
		this.message 	= 'Error at @' + name + (args ? ' (' + Array.prototype.map.call (args, lambda JSON.stringify (arg)).join (', ') + ')' : '') + (parent ? '\n' + parent.stack : message ? ': ' + message : '');
	};

	MacroError.prototype = Error.prototype;