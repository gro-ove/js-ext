	function Macro (name, level, macroArgs, macroBody){
		this.name 			= name;

		if (typeof level === 'function'){
			this.level 		= '';
			this.rawFn 		= level;
		} else {
			if (!macroBody){
				macroBody = macroArgs;
				macroArgs = null;
			}
			
			this.level 		= level;
			this.arguments 	= macroArgs === null ? [ 'arg' ] : macroArgs; 
			this.rawBody 	= macroBody;
			this.asyncMode 	= this.arguments [this.arguments.length - 1] === 'callback';
		}
	};

	addLog (Macro, '-', lambda '@' + this.name);

	Macro.ReturnType = { 
		Object: 		'MacroReturnTypeObject',
		String: 		'MacroReturnTypeString',
		Raw: 			'MacroReturnTypeRaw',
		RawWithMacros: 	'MacroRawWithMacros',
		SourceTree: 	'MacroReturnTypeSourceTree',
	};

	Macro.Defaults = {
		fs: 			require ('fs'),
		path: 			require ('path'),
		ReturnType: 	Macro.ReturnType
	};

	Macro.prototype.initialize = function (callback){
		function macroCalls (macroBody){
			var used = [],
				lastIdentifier,
				liteParser,
				name,
				found,
				temp;

			if (macroBody.search (/@[_$a-zA-Z]/) !== -1){
				lastIdentifier 	= 0;
				liteParser 		= new LiteParser (macroBody)
					.on ('//', lambda this.findSimple ('\n', '\r', LiteParser.EOF))
					.on ('/*', lambda this.findSimple ('*/'))
					.on ('\'', '"', '`', lambda {
						while (temp = liteParser.findSimple ('\\' + arg.value, arg.value))
							if (temp.value === arg.value)
								return true;
						return false;
					});

				while (found = liteParser.findNext (/@([_$a-zA-Z][_$a-zA-Z0-9]*)/)){
					while (macroBody.indexOf (name = '_' + (lastIdentifier ++).toString (32)) !== -1);
					used.push ({ name: name, macro: found.raw [1] });

					temp = liteParser.whatNext (/[^\s]/);
					if (!temp || temp.value !== '(')
						name = name + ' ()';

					liteParser.update (macroBody = macroBody.substr (0, found.index) + name + macroBody.substr (liteParser.index), liteParser.index + name.length - found.value.length);
				}
			}

			return {
				used: 	used,
				body: 	macroBody
			};
		}

		if (this.callee || this.rawFn){
			callback ();
			return;
		}

		var phase 		= macroCalls (this.rawBody),
			converted 	= convert (phase.body, { fileName: 'macro', insertReturn: true }),
			variables 	= [],
			queue 		= new Queue (macroStorage, Queue.MODE_PARALLEL).description ('macros inside other macro');

		for (var key in Macro.Defaults)
			variables.push (key + ' = this.defaults.' + key);

		for (var entry in-array phase.used){
			queue.add (macroStorage.get, entry.macro, this.level);
			variables.push (entry.name + ' = this.macros.' + entry.macro);
		}

		this.object 	= { defaults: Macro.Defaults, macros: {} };
		this.debug 		= (variables.length ? 'var ' + variables.join (', ') + ';\n' : '') + converted;
		this.callee 	= new Function (this.arguments.join (','), this.debug);

		queue.run (lambda {
			arg.map (lambda arg.result [0]).forEach (lambda (other){
				this.log ('found @' + other.name + ' for using inside');
				this.object.macros [other.name] = lambda other.call (arguments);
			}.bind (this));

			this.log ('initialized');
			callback ();
		}.bind (this));
	}

	Macro.prototype.call = function (args){
		console.assert (this.callee || this.rawFn, 'Macro is not initialized');

		try
			return this.rawFn 
				? this.rawFn.apply (null, args) 
				: this.callee.apply (this.object, args);
		catch
			throw new MacroError (this.name, args, e);
	}

	function MacroError (name, args, parent){
		this.name 		= 'MacroError';
		this.message 	= 'Error at @' + name + ' (' + args.map (lambda JSON.stringify (arg)).join (', ') + ')\n' + parent.stack;
	};

	MacroError.prototype = Error.prototype;