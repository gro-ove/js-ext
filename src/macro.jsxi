	function Macro (name, level, macroArgs, macroBody){
		this.name 			= name;

		if (typeof level === 'function'){
			this.level 		= '';
			this.rawFn 		= level;
		} else {
			if (!macroBody){
				macroBody = macroArgs;
				macroArgs = null;
			}
			
			this.level 		= level;
			this.arguments 	= macroArgs === null ? [ 'arg' ] : macroArgs; 
			this.rawBody 	= macroBody;
			this.asyncMode 	= this.arguments [this.arguments.length - 1] === 'callback';
		}
	};

	Macro.ReturnType = { 
		Object: 		'MacroReturnTypeObject',
		String: 		'MacroReturnTypeString',
		Raw: 			'MacroReturnTypeRaw',
		RawWithMacros: 	'MacroRawWithMacros',
		SourceTree: 	'MacroReturnTypeSourceTree',
	};

	Macro.Defaults = {
		fs: 			require ('fs'),
		path: 			require ('path'),
		ReturnType: 	Macro.ReturnType
	};

	function macroCalls (macroBody){
		var used = [],
			lastIdentifier,
			liteParser,
			name,
			found,
			temp;

		if (macroBody.search (/@[_$a-zA-Z]/) !== -1){
			lastIdentifier 	= 0;
			liteParser 		= new LiteParser (macroBody)
				.on ('//', lambda this.findSimple ('\n', '\r', LiteParser.EOF)) // FIXME: EOF
				.on ('/*', lambda this.findSimple ('*/'))
				.on ('\'', '"', '`', lambda {
					while (temp = liteParser.findSimple ('\\' + arg.value, arg.value))
						if (temp.value === arg.value)
							return true;
					return false;
				});

			while (found = liteParser.findNext (/@([_$a-zA-Z][_$a-zA-Z0-9]*)/)){
				while (macroBody.indexOf (name = '_' + (lastIdentifier ++).toString (32)) !== -1);
				used.push ({ name: name, macro: found.raw [1] });

				temp = liteParser.whatNext (/[^\s]/);
				if (!temp || temp.value !== '(')
					name = name + ' ()';

				liteParser.update (macroBody = macroBody.substr (0, found.index) + name + macroBody.substr (liteParser.index), liteParser.index + name.length - found.value.length);
			}
		}

		return {
			used: 	used,
			body: 	macroBody
		};
	}

	Macro.prototype.initialize = function (macros){
		if (this.rawFn)
			return;

		var phase 		= macroCalls (this.rawBody),
			converted 	= convert (phase.body, { fileName: 'macro', insertReturn: true }),
			variables 	= [],
			that 		= this;

		for (var key in Macro.Defaults)
			variables.push (key + ' = this.defaults.' + key);

		this.object 	= { defaults: Macro.Defaults, macros: {} };

		phase.used.forEach (lambda (entry, temp){
			variables.push (entry.name + ' = this.macros.' + entry.macro);
			temp = getNearestMacro (macros, entry.macro, this.level);

			if (!temp)
				throw new MacroNotFoundError (entry.macro);
				// throwError ({}, 'Macro @%0 not found', entry.macro);

			this.object.macros [entry.macro] = temp.call (arguments);
		}.bind (this));

		this.debug 		= (variables.length ? 'var ' + variables.join (', ') + ';\n' : '') + converted;
		this.callee 	= new Function (this.arguments.join (','), this.debug);

		console.log ('=== MACRO ' + this.name + ' ===\n' + this.debug + '\n');
	}

	Macro.prototype.call = function (args){
		console.assert (this.callee || this.rawFn, 'Callee not found');

		try
			return this.rawFn 
				? this.rawFn.apply (null, args) 
				: this.callee.apply (this.object, args);
		catch
			throw new MacroError (this.name, args, e);
	}

	function MacroError (name, args, parent){
		this.name 		= 'MacroError';
		this.message 	= 'Error at @' + name + ' (' + args.map (lambda JSON.stringify (arg)).join (', ') + ')\n' + parent.stack;
	};

	MacroError.prototype = Error.prototype;

	function MacroNotFoundError (name, args, parent){
		this.name 		= 'MacroNotFoundError';
		this.macroName 	= name;
	};

	MacroNotFoundError.prototype = Error.prototype;