# Это здесь временно

	/*
		Класс A, наследующий класс B и интерфейсы C и D и использующий класс E.
		Описывать используемые классы более чем необязательно — это влияет лишь
		на их взаимное расположение в результирующем .js-файле (которое, в свою 
		очередь, влияет на порядок инициализации).
		
		Конструктор записывается так же, как и метод, но без имени. Кстати, ука-
		зывать ключевые слова «var» и «function» необязательно.
		
		Доступны в том числе и статические поля и методы. И, как и методы и поля 
		объекта, они могут быть «private», «protected» и «public».

		Статическая  инициализация  похожа на конструктор,  но с ключевым словом
		«static» в начале.

		Ключевые слова  «extends», «implements» и «uses»  (а также их содержимое)
		могут идти в произвольном порядке.
	*/

	class A extends B implements C, D uses E {
		public var a = 1;
		private b = 2;

		static test = 3;

		(a){
			this.a = a + b;
		}
	}

	/*
		Класс Q  с модификатором «static», что автоматически делает все его поля
		статическими.  Ничего  особенного, лишь упрощает  обычно громоздкий код. 
		К тому статический класс нельзя инстанцировать или взять родительским.

		Из интересного  —  как и везде в js-ext, скобки у методов опциональны. А
		вот фигурные скобки конструкторам нужны.

		(На самом деле нет, но препроцессор, встретив какое-то выражение, сперва
		пытается распарсить его как переменную.  Если у конструктора не будет ни
		простых,  ни фигурных скобок,  в некоторых случаях его вполне можно при-
		нять за переменную.)

		(С методами такого не случится — у них,  кроме всего прочего, есть ещё и
		имя.)
	*/

	static class Q {
		a = 1;

		{
			a = 2;
		}
	}

	/*
		Класс  W  с  абстрактным методом.  В отличие  от обычных  методов  после
		абстрактных методов должна стоять точка с запятой.

		Абстрактных полей,  разумеется,  быть не может. И,  конечно же,  попытка
		создать экземпляр абстрактного класса, или класса, что-то унаследовавше-
		го от абстрактного, но так и не определившего, приведёт к ошибке.

		Статические поля, методы и инициализатор работают как обычно.

		Если  дописать модификатор  «abstract»  к реализованной функции,  js-ext
		всё равно  потребует переопределить её.  Пусть даже  это будет пустышка,
		вызывающая суперметод.
	*/

	class W {
		abstract test (a);

		moreThanZero (a){
			return a > 0;
		}

		public static var g = 1;
	}

	/*
		Как и с модификатор «static»,  «abstract»  может быть применим  к целому
		классу. К слову, как и «public», «protected» или «private». В таком слу-
		чае  бедному разработчику дочернего класса придётся  переопределять  все
		функции, насколько бы они не были уже определены.

		Добавлю  про модификаторы видимости  к классу:  в отличие  от прочих, их
		можно переопределять.

		А, и вот ещё — класс не может быть одновременно  абстрактным и статичес-
		ким. А то получается какая-то ерунда.
	*/

	abstract class F {
		example ();

		moreThanZero (a){
			return a > 0;
		}
	}

	/*
		Например, так. Разумеется, поле «v» будет доступно снаружи.
	*/

	public class P {
		private var h;

		var v;

		(h){
			this.h = h;
		}
	}

	/*
		А это, например, интерфейс. Чем-то похож на абстрактный класс.

		Статические поля и методы (кроме приватных) доступны из классов,  реали-
		зующих интерфейс. А если они публичные, то ещё и, конечно же, снаружи.

		Замечу, что интерфейсы не бывают абстрактными. Но зато могут быть стати-
		ческими  (но включаться статические интерфейсы  могут лишь в статические 
		классы).
	*/

	interface I {
		static calculate (x, y)
			Math.pow (x, y)

		test (a);
	}

	/*
		Ну и, наконец, нечто новое — своего рода реализованный интерфейс. У него
		нет уже практически ничего,  его предназначение  —  сообщать интерпрета-
		тору, что такой класс с подобными полями и методами с той или иной види-
		мостью уже существуют.

		Могут иметь родителей,  наследоваться от интерфейсов и использовать дру-
		гие классы — но лишь реализованные.

		Ниже — класс и интерфейс.

		Обычно генерируются автоматически при сборке скрипта. Один из кейсов ис-
		пользования — например, сперва написать некую библиотеку и запаковать её
		в .js-файл, а после продолжать писать код в другом файле, расширяя клас-
		сы и реализуя интерфейсы и при этом не трогая исходный код.
	*/

	implemented class J {
		static protected method (x, y, z);
		static protected variable;

		public test ();
	}

	implemented interface K {
		static protected method (x, y, z);
		static protected variable;
	}

	/*
		Или ещё один небезынтересный кейс.
	*/

	implemented class Object {
		public toString ();
		public valueOf ();
	}

	class Child extends Object {
		(){
			console.log ('Created ' + toString ());
		}
	}

	/*
		На текущем этапе оператор «instanceof», увы, не срабатывает, если речь за-
		ходит о «interface» или «implented».  Но, возможно, в будущем какой-нибудь 
		способ всё-таки будет найден.
	*/


