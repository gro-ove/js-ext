# Disclaimer

###### I'M GOING TO TRANLATE THIS TO ENGLISH LATER

But now I have to quickly redesign some parts of this, so I've written this text just to do some king of cleaning and sorting in my head.
My English isn't very well (especially for writing), and if I decided to write in English, I would spend much more time.

# Коротко о главном

	/*
		Js-Ext

		Ещё  один  из  многочисленных  языков,  конвертирующихся  в  JavaScript.
		По  большей  части   добавляет   лишь  синтаксический   сахар.   Написан
		на Node.JS.

		Ключевые особенности:

			- Валидный JavaScript чаще всего отлично распарсится как код Js-Ext.

			- Имеется ООП (подробнее - см. ниже), причём классы конвертируются в
			  старые добрые прототипы.  Прототипы сами по себе - отличная штука,
			  но (по крайней мере мне) иногда не хватает приватных полей или ме-
			  тодов.   Или  статических.  Или   простого  вызова  супер-методов.
			  Ну и всё время  биндить методы  и  на любой чих писать «this» тоже
			  несколько утомляет.  Кстати, эта фича заслуживает того, чтобы быть
			  вынесенной отдельно.

			- В классах не нужно чуть что писать «this».  Препроцессор сам опре-
			  делит, куда именно и как лучше его подставить. То же самое со ста-
			  тическими или унаследованными полями и методами.

			- Самая  прикольная,  на мой взгляд,  функция - макросы.  Могут быть
			  определены или вызваны  в любом месте.  В начале  конвертации  все
			  макросы будут аккуратно вырезаны из исходного файла,  а все вызовы
			  макросов будут заменены на  результат,  который  вернули  макросы.
			  Подробнее можно прочести ниже.

			- Сокращение  объёма  вводимого  кода  -  функции  можно  записывать
			  короче,  фигурные скобки  в большинстве  случаев ставить  необяза-
			  тельно,  даже запятые, разделяющие выражения в массивах,  объектах
			  или аргументах функции теперь опциональны.

			- Добавлено немного новых операторов,  некоторые из имеющихся слегка
			  переработаны.
	*/

# Изменения синтаксиса, новые операторы и всё такое

	/*
		Чуть ниже - четыре равноценных варианта функции.  Обратите внимание, что
		при отсутствии списка аргументов будет автоматически подставлен аргумент
		«arg»,  а при отсутствии фигурных скобок «return» будет подставлен авто-
		матически.
	*/

	function test (argument){
		if (argument > 0)
			return Math.sqrt (argument);
	}

	function test (argument)
		if (argument > 0)
			Math.sqrt (argument);

	function test {
		if (arg > 0)
			Math.sqrt (arg);
	}

	function test
		if (arg > 0)
			Math.sqrt (arg);

	/*
		Небезынтересная деталь:  если будет найдена фигурная скобка, но при этом
		содержимое  не получится распарсить как тело функции,  будет произведена
		попытка распарсить его как объект.

		Может показаться удивительным, но в первом случае парсер считает «label»
		не ключём, а меткой. В этом Js-Ext повторяет поведение того же V8.

		Если не верится,  попробуйте ввести «{ label: 'value' }» в консоль брау-
		зера.
	*/

	function thisIsDefaultFunction (){
		label: 'value'
	}

	/* 	
		Аргументы функции по умолчанию. Сверху код до обработки, внизу - после.
	*/

	function argumentsTest (a = 1, b = [ { key: 'value' } ]){
		console.log (a, b);
	}

	function argumentsTest (a, b){
		if (a === undefined)
			a = 1;
		if (b === undefined)
			b = [ { key: 'value' } ];
		console.log (a, b);
	}

	/*
		Четыре примера  обработки ошибок — классический вариант записи и три но-
		вых.  Обратите внимание, что фигурные скобки и имя ошибки можно опускать
		(значение по умолчанию — «e»). 

		На всякий раз уточню  -  лучше  не пишите так,  как показано в последних
		двух примерах, особенно если не совсем понимаете, на какие грабли можете
		наступить, если будете просто игнорировать ошибки.
	*/

	try {
		...
	} catch (error){ 
		console.error (error);
		...
	}

	try
		...
	catch
		console.error (e);

	try {
		...
	}

	try value = JSON.parse (localStorage ['data']);

	/*
		Небольшое изменение цикла «for-in».  Сверху — традиционный,  скажем так,
		вариант.
	*/

	for (var key in dictionary)
		console.log (key, dictionary [key]);

	for (var key, value in dictionary)
		console.log (key, value);

	/*
		И нечто вроде нового цикла, схожего с «for-in». Только этот цикл переби-
		рает массив. Или любой другой объект со свойством «length». В отличие от
		цикла «for-in», если у этого цикла будет использована лишь одна перемен-
		ная, в ней окажется значение. 

		Последний цикл  -  пример использования на практике.  Тем самым я как бы
		подчёркиваю, что «document.querySelectorAll» будет вызван лишь единожды.
	*/

	for (var element in-array list)
		console.log (element);

	for (var position, element in-array list)
		console.log (position, element);

	for (var node in-array document.querySelectorAll ('[data-remove-me]'))
		node.parentNode.removeChild (node);

	/*
		Строки  с переносами  без экранирования.  Да и вообще  с чем угодно  без
		экранирования,  кроме своей кавычки и обратного слеша  для экранирования
		кавычки.

		До введения  макросов  активно использовались,  но теперь,  когда задачу
		хранения в скрипте больших строк отлично решают макросы, эти строки ока-
		зались никому не нужны и, возможно, скоро вообще покинут Js-Ext.

		Забавная деталь: я один, кто использует Js-Ext, так что могу не обращать
		внимания на обратную совместимость.  Если вдруг кто-то захочет присоеди-
		ниться к использованию, столь мило уже не повеселишься.
	*/

	var html = `<div>
					<span>My dog's website</span>
				</div>`;

	/*
		А вот эта штука - из новых, и используется активно до безобразия.  Пред-
		положим, стоит задача вывести такую строку (а вместо угловых скобок под-
		ставить соответствующие поля переданного объекта):
			«"< LABEL >"(< CURRENT_TIME >): < FIRST_VALUE >, < SECOND_VALUE >»

		Так вот,  в Js-Ext больше не нужно путаться  с кавычками  и знаками сло-
		жения или запускать кучу  регулярных выражений для поиска и замены вхож-
		дений.  Не подумайте чего,  я люблю и ценю регулярные выражения,  но для
		данного  случая  есть вариант проще.  Лишь отметьте в строке места, куда
		нужно воткнуть  то или иное выражение, с помощью «%N», а после  перечис-
		лите выражения в скобках, идущих сразу после строки.  На мой взгляд, так
		несколько удобнее!

		Чувствую себя коммивояжёром, продающим пылесос. «Больше никакого собачь-
		его дерьма на ковре!»

		(Ниже, как обычно, результат работы конвертера.)
	*/

	console.log ('"%0"(%1): %2, %3' (
			arg.label, 
			arg.currentTime, 
			arg.firstValue,
			arg.secondValue));

	console.log ('"' 
			+ arg.label + '"(' 
			+ arg.currentTime + '): ' 
			+ arg.firstValue + ', ' 
			+ arg.secondValue);

	/*
		Этот встреченный  на Хабрахабре оператор сразу запал мне в душу,  откуда
		вскоре выпал в Js-Ext.  Он - вверху,  а то, во что превратит его Js-Ext,
		внизу.

		На всякий случай уточню - речь идёт о вот этом милом троеточии. Говорят,
		обычно такими штуками балуются в Perl'е.
	*/

	...

	console.warn ('Not implemented at < Номер строки > line of < Имя Файла >');

	/*
		Ещё один оператор Perl'а. Неплохо помогает задавать массивы. Если элеме-
		нтов будет немного,  они появятся прямо  в результирующем коде,  а иначе 
		будут сгенерированы функцией.

		Уточню кое-что: функция может называться и не «__pa». Это одна из многих
		функций, которые будут добавлены при необходимости. При добавлении подо-
		бных функций подбирается такое имя, которое ещё нигде не использовалось.
		Все подобные функции,  как и все прочие  вспомогательные поля  Js-Ext'а,
		начинаются с «__».  Постарайтесь не использовать подобную запись в своих
		проектах  —  как минимум код будет приятнее  (Js-Ext сможет использовать
		стандартные читаемые имена вместо того,  чтобы подбирать кучу уникальных
		чисел).
	*/

	[ 3 .. 6 ] 			=> 			[ 3, 4, 5, 6 ]
	[ 6 .. 3 ] 			=> 			[ 6, 5, 4, 3 ]
	[ 'a' .. 'c' ] 		=> 			[ 'a', 'b', 'c' ]
	[ 0 .. 100 ] 		=> 			__pa (0, 100);
	[ from .. to ] 		=> 			__pa (from, to);

	/*
		Напоследок осталось едва ли не самое ценное. Сокращённая запись функций.
		Что-то вроде лямбда-функций. Весьма и весьма, на мой взгляд, удобно.

		Они  совпадают  с функциями  во всём за исключением  лишь  пары деталей:
		
			- Не могут иметь имени, а потому не могут определять новые функции.

			- В то время как  функции пытаются содержимое,  начинающееся с  «{»,
			  сперва распарсить  как обычный блок,  лямбда-функции  первым делом
			  пробуют, не объект ли это.  Так что с ними можно возвращать объект
			  с одним полем или даже пустой объект без «return» или скобок.

		В отличие  от стрелочных функции  из ES6,  эти как-бы-лямбда-функции  не
		сохраняют ни this, ни что-нибудь ещё.
	*/

	var multiplyByTwo 		= lambda arg * 2,
		appendTm 			= lambda (str) str + '™',
		returnOnlyIfZero 	= lambda if (n === 0) n,
		withoutRetunt 		= lambda { log ('Эта функция ничего не вернёт') },
		justLikeFunction 	= lambda (a, b){
			for (var key in a)
				console.log (key, a [key]);
			return key
		};

	elementsList
		.filter (lambda arg.parentNode)
		.sort (lambda (a, b) a.textContent > b.textContent)
		.map (lambda { element: arg });

# Описание классов

### Обычные классы

	/*
		Ниже - объявление класса A, наследующего класс B, реализующего интерфей-
		сы C и D и использующего класс E.  Записывать используемые классы необя-
		зательно,  но транслятор перед выводом сортирует классы так,  чтобы дан-
		ный, например, класс всегда находился после классов B, C, D и E.

		Ключевые слова  «extends»,  «implements»  и  «uses»  могут идти в произ-
		вольном порядке.

		Писать  «var» и «function»  перед полями или методами необязательно. При
		их отсутствии вначале  будет произведена попытка  распарсить член класса 
		как поле, и если js-ext обломается,  то попробует подобраться к нему как
		к методу. Аргументы или фигурные скобки, как и с функциями, опциональны.
		
		Конструктор записывается так же, как и метод, но без имени.  Инициализа-
		тор похож на конструктор,  но с ключевым словом  «static»  в начале. Что 
		для конструктора,  что для инициализатора нужно ставить хотя бы фигурные 
		скобки - иначе распарсить код часто будет невозможно.
		
		Доступны в том числе и статические поля и методы. Инициализация статиче-
		ских полей и запуск самого инициализатора выполняются ещё до глобального 
		объявления класса, но уже после объявления предыдущих классов.

		И статические, и обычные поля и методы могут быть «private», «protected»
		и  «public». По умолчанию все поля и методы - «private»,  но для отдель-
		ного класса  это можно изменить,  добавив соответсвующее  ключевое слово
		перед ключевым словом «class».

		К слову, рекомендую ознакомиться с расположенным ниже разделом «Обратите
		внимание».
	*/

	class A extends B implements C, D uses E {
		// Публичная переменная
		public var a = 1;

		// Приватная переменная
		private b = 2;

		// Приватная статическая переменная
		static c = 3;

		(a){
			// Это конструктор.
			// Обратите внимание, «this» перед обращением к полям можно и не пи-
			// сать.

			this.a = a + b;
		}

		static (a, b){
			// Это статический инициализатор, или просто инициализатор
			// Сколько аргументов не пиши, всё равно ничего в них не появится

			c ++;
		}
	}

	/*
		Пример публичного класса - поле «v» доступно снаружи
	*/

	public class P {
		private var h;

		var v;

		(h){
			this.h = h;
		}
	}

### Статические классы

	/*
		Далее - класс Q  с модификатором «static»,  что автоматически делает все
		его поля статическими.  Ничего особенного, лишь упрощает громоздкий код.
		К тому статический класс нельзя инстанцировать или взять родительским.
	*/

	static class Q {
		a = 1;

		{
			a = 2;
		}
	}

### Абстрактные классы

	/*
		Если у класса (как, например, у класса W) есть хоть один - свой или уна-
		следованный,  но не реализованный - абстрактный метод,  класс становится
		абстрактным.

		У абстрактных методов  обычно нет реализации,  но даже если она и будет,
		Js-Ext всё равно потребует переопределить её.  Пусть даже это будет лишь
		один вызов супер-метода.

		Поле, статический член или приватный метод абстрактными быть не могут.

		Попытка создать экземпляр абстрактного класса,  или класса,  унаследова-
		вшего абстрактный метод, но так его и не определившего,  приведёт к оши-
		бке. Для этого в начало любого конструктора абстрактного класса добавля-
		ется проверка. Для большего сжатия её можно выключить, но в таком случае
		исключение вывалится лишь при попытке обратиться  к абстрактному  методу 
		без реализации.
	*/

	class W {
		abstract test (a);

		moreThanZero (a){
			return a > 0;
		}

		public static var g = 1;
	}

	/*
		По аналогии с модификатором «static», «abstract» также может действовать
		и на классы. Все «public» и «protected» методы в таком случае будут счи-
		таться абстрактными.

		Класс не может быть одновременно абстрактным и статическим.
	*/

	abstract class F {
		example ();

		moreThanZero (a){
			return a > 0;
		}
	}

### Интерфейсы

	/*
		А это, например, интерфейс.

		Статические неприватные поля и методы интерфейса  доступны всем классам,
		которые  этот интерфейс  реализовали.  А если  они публичные,  то вообще
		всем.

		Интерфейсы не могут быть абстрактными, но могут быть статическими. Вклю-
		чаться статические интерфейсы могут в любой другой интерфейс или класс.
	*/

	interface I {
		static calculate (x, y)
			Math.pow (x, y)

		// Странная штука ниже - объявление функции.  Если это кажется  ужасным,
		// спереди всегда можно добавить «function».
		test (a);
	}

	/*
		Ну и, наконец, нечто новое - своего рода реализованный интерфейс. У него
		нет практически ничего, его предназначение  -  сообщать транслятору, что
		такой класс с подобными полями и методами уже существуют.

		Может иметь родителей,  наследоваться от интерфейсов и использовать дру-
		гие классы - но лишь реализованные.

		Ниже - пример класса и интерфейса.

		Файлы, описывающие реализованные в той или иной программе, могут генери-
		роваться автоматически  при её трансляции.  Один из кейсов использования 
		- например, сперва написать некую библиотеку и запаковать её в .js-файл,
		а после писать код отдельно,  расширяя классы, реализуя интерфейсы и при
		этом не трогая исходный код.
	*/

	implemented class J {
		static protected method (x, y, z);
		static protected variable;

		public test ();
	}

	implemented interface K {
		static protected method (x, y, z);
		static protected variable;
	}

	/*
		Или ещё один небезынтересный кейс.
	*/

	implemented class Object {
		public toString ();
		public valueOf ();
	}

	class Child extends Object {
		(){
			console.log ('Created ' + toString ());
		}
	}

### Обратите внимание

	/*
		Переопределение полей и методов класса:

			- Приватные члены  никак не заграгиваются,  сохраняя своё значение и
			  приватность для использования исключительно в своём классе. Факти-
			  чески,  в отличие  от остальных,  приватные члены  всегда остаются 
			  доступны лишь методам своего класса.

			- Во всех остальных случаях,  если у дочернего класса  есть поле или
			  метод  с тем же именем,  что и у родительского класса,  фактически 
			  методы обоих классов будут работать с одним и тем же членом.

			- Причём если у родительского класса есть публичный член, а дочерний
			  класс имеет член с тем же названием,  но при этом защищённый, пре-
			  процессор сообщит об ошибке.

		Такая схема,  вероятно,  неудобна в отношении полей, но неплохо подходит
		для шаблонов JavaScript'а.
	*/

	/*
		На текущем этапе оператор «instanceof», увы, не срабатывает, если речь за-
		ходит о «interface» или «implented».  Но, возможно, в будущем какой-нибудь 
		способ всё-таки будет найден.
	*/


